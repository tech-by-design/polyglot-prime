 
/****************************************************************************************
 * Comprehensive view of HTTP interactions and their associated requests.
 * 
 * This view joins the hub_interaction table with the sat_interaction_http_request table
 * to provide a detailed record of each interaction and its related HTTP requests.
 * 
 * Purpose:
 * - To offer a business-level overview of HTTP interactions processed by the system.
 * - Each request is typically represented by a single row. However, in scenarios where 
 *   completing a request involves multiple asynchronous HTTP requests, multiple rows 
 *   might be associated with a single interaction.
 * - This is particularly useful for understanding complex interactions that involve 
 *   several steps or dependent requests to fulfill a single client request.
 ****************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_request CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_request
AS 
SELECT interaction_id,
    uri,
    interaction_created_at,
    interaction_created_by,
    interaction_provenance,
    sat_interaction_http_request_id,
    nature,
    tenant_id,
    user_agent,
    client_ip_address,
    content_type,
    payload,
    elaboration,
    from_state,
    to_state,
    state_transition_reason,
    request_created_at,
    request_created_by,
    request_provenance,
    issues_count,
    resource_types,
    start_time,
    finish_time,
    duration_millisecs
   FROM ( SELECT htt_req.hub_interaction_id AS interaction_id,
            htt_req.uri,
            htt_req.created_at AS interaction_created_at,
            htt_req.created_by AS interaction_created_by,
            htt_req.provenance AS interaction_provenance,
            htt_req.sat_interaction_fhir_request_id AS sat_interaction_http_request_id,
            htt_req.nature,
            htt_req.tenant_id,
            htt_req.user_agent,
            htt_req.client_ip_address,
            'application/json'::text AS content_type,
            htt_req.payload,
            htt_req.elaboration,
            htt_req.from_state,
            htt_req.to_state,
            htt_req.state_transition_reason,
            htt_req.created_at AS request_created_at,
            htt_req.created_by AS request_created_by,
            htt_req.provenance AS request_provenance,
            htt_req.issues_count,
            htt_req.resource_type_set AS resource_types,
            htt_req.interaction_start_time AS start_time,
            htt_req.interaction_end_time AS finish_time,
            EXTRACT(epoch FROM htt_req.interaction_end_time::timestamp without time zone - htt_req.interaction_start_time::timestamp without time zone) * 1000::numeric AS duration_millisecs
           FROM techbd_udi_ingress.sat_interaction_fhir_request htt_req
        UNION ALL
         SELECT user_req.hub_interaction_id AS interaction_id,
            user_req.uri,
            user_req.created_at AS interaction_created_at,
            user_req.created_by AS interaction_created_by,
            user_req.provenance AS interaction_provenance,
            user_req.sat_interaction_user_id AS sat_interaction_http_request_id,
            user_req.nature,
            user_req.tenant_id,
            user_req.user_agent,
            user_req.client_ip_address,
            'application/json'::text AS content_type,
            NULL::unknown AS payload,
            user_req.elaboration,
            NULL::unknown AS from_state,
            NULL::unknown AS to_state,
            NULL::unknown AS state_transition_reason,
            user_req.created_at AS request_created_at,
            user_req.created_by AS request_created_by,
            user_req.provenance AS request_provenance,
            NULL::unknown AS issue_count,
            NULL::unknown AS resource_types,
            user_req.interaction_start_time AS start_time,
            user_req.interaction_end_time AS finish_time,
            EXTRACT(epoch FROM user_req.interaction_end_time::timestamp without time zone - user_req.interaction_start_time::timestamp without time zone) * 1000::numeric AS duration_millisecs
           FROM techbd_udi_ingress.sat_interaction_user user_req where user_req.uri not ilike '%/Bundle%' and user_req.uri not ilike '%/Hl7/v2%') combined_query
  ORDER BY interaction_created_at DESC;

/*******************************************************************************************
This view combines data from hub_interaction and sat_interaction_http_request tables to 
provide a consolidated view of HTTP FHIR requests, including resource types, 
interaction details, request attributes, and validation issues.
******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_fhir_request CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_fhir_request
AS SELECT hub_interaction_id AS interaction_id,
    uri,
    bundle_id,
    created_at AS interaction_created_at,
    created_by AS interaction_created_by,
    provenance AS interaction_provenance,
    sat_interaction_fhir_request_id AS sat_interaction_http_request_id,
    nature,
    tenant_id,
    user_agent,
    client_ip_address,
    'application/json'::text AS content_type,
    payload,
    elaboration,
    from_state,
    to_state,
    state_transition_reason,
    created_at AS request_created_at,
    created_by AS request_created_by,
    provenance AS request_provenance,
    issues_count,
    resource_type_set AS resource_types,
    interaction_start_time::text AS start_time,
    interaction_end_time::text AS finish_time,
    EXTRACT(epoch FROM interaction_end_time::timestamp without time zone - interaction_start_time::timestamp without time zone) * 1000::numeric AS duration_millisecs,
    patient_id,
    patient_mrn,
    patient_mrn_source_system,
    organization_id,
    organization_name,
    concat_ws('-'::text, tenant_id, organization_id, patient_mrn) AS source_mrn,
    CASE
        WHEN 'ServiceRequest' = ANY(string_to_array(resource_type_set, ', ')) OR 'Task' = ANY(string_to_array(resource_type_set, ', '))
            THEN 'Referral'
        WHEN 'Consent' = ANY(string_to_array(resource_type_set, ', '))
            THEN 'Screening'
        WHEN 'Condition' = ANY(string_to_array(resource_type_set, ', '))
            THEN 'Assessment'
        ELSE NULL
    END AS bundle_resource_type,
    CASE 
    	WHEN (source_type = 'CSV') then 'CSV'
    	WHEN (source_type = 'fhir') then 'FHIR'
    	WHEN (source_type = 'FHIR') then 'FHIR'
    	ELSE 'FHIR'
    END as source_type,   
    source_hub_interaction_id,
    	CASE
            WHEN is_bundle_valid = true THEN 'Valid'::text
            WHEN is_bundle_valid = false THEN 'Invalid'::text
        END AS is_bundle_valid  
   FROM techbd_udi_ingress.sat_interaction_fhir_request htt_req
   WHERE uri != '/api/expect/fhir/bundle'; 


-- techbd_udi_ingress.interaction_http_request_payload source
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_request_payload;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_request_payload
AS SELECT sat_interaction_http_request_id,
    hub_interaction_id as interaction_id,
    payload
   FROM techbd_udi_ingress.sat_interaction_http_request sihr;   

/*******************************************************************************************
This materialized view is to extract observability metrics from interaction_http_request
******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_observe CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_observe
AS 
SELECT 	intr_observe.interaction_id,
		intr_observe.uri,
		intr_observe.start_time,
		intr_observe.finish_time,   
		EXTRACT(epoch FROM intr_observe.finish_time::timestamp without time zone - intr_observe.start_time::timestamp without time zone) * 1000::numeric AS duration_millisecs,
		intr_observe.sat_interaction_http_request_id AS interaction_http_request_id
FROM techbd_udi_ingress.interaction_http_request intr_observe
WHERE intr_observe.start_time IS NOT NULL AND intr_observe.finish_time IS NOT null
 ORDER BY duration_millisecs DESC;

/*****************************************
This view extracts diagnostic information from JSON payloads of HTTP requests stored in 
'sat_interaction_http_request'. It transforms and presents fields such as 'tenant_id', 'uri', 
'session_id', 'severity', 'message', 'line', 'column', 'diagnostics', 'encounteredAt', 
and 'elaboration' for further analysis or reporting.
******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.fhir_session_diagnostics CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.fhir_session_diagnostics
AS SELECT tenant_id,
    uri,
    session_id,
    severity,
    message,
    line,
    "column",
    diagnostics,
    to_timestamp(intr_diagno.encountered_at::double precision) AS encounteredat, 
    elaboration
   FROM techbd_udi_ingress.sat_interaction_fhir_session_diagnostic intr_diagno;

/*******************************************************************************************************************************
 * Function to register an HTTP interaction request, handling potential unique constraint violations
 * and logging exceptions when necessary.
 *
 * Parameters:
 * @param interaction_id TEXT - The unique identifier of the interaction.
 * @param interaction_key TEXT - The key to identify the interaction.
 * @param payload JSONB (nullable) - The JSON payload associated with the interaction. Default is NULL.
 * @param payload_text TEXT (nullable) - The text version of the payload. Default is NULL.
 * @param rule_namespace TEXT (nullable) - The namespace for JSON action rules. Default is NULL.
 * @param elaboration JSONB (nullable) - Additional JSON data to elaborate on the interaction. Default is NULL.
 * @param nature JSONB (nullable) - Describes the nature of the HTTP interaction, including tenant details. Default is NULL.
 * @param content_type TEXT (nullable) - The content type of the HTTP interaction. Default is NULL.
 * @param from_state TEXT (nullable) - The state before the HTTP interaction. Default is NULL.
 * @param to_state TEXT (nullable) - The state after the HTTP interaction. Default is NULL.
 * @param state_transition_reason TEXT (nullable) - The reason for the state transition. Default is NULL.
 * @param user_id TEXT (nullable) - The ID of the user involved in the interaction. Default is NULL.
 * @param user_name TEXT (nullable) - The name of the user involved in the interaction. Default is NULL.
 * @param user_session TEXT (nullable) - The session ID of the user involved in the interaction. Default is NULL.
 * @param user_role TEXT (nullable) - The role of the user involved in the interaction. Default is NULL.
 * @param created_at TIMESTAMPTZ (nullable) - The timestamp of when the interaction was created. Defaults to the current timestamp.
 * @param created_by TEXT (nullable) - The user who created the interaction. Defaults to the current user.
 * @param provenance TEXT (nullable) - Metadata providing the provenance or origin of the interaction. Defaults to 'unknown'.
 * @param hub_upsert_behavior BOOLEAN - Controls whether unique constraint violations should be treated as an error (FALSE) or ignored (TRUE). Defaults to TRUE.
 *
 * Returns:
 * @return JSONB - The JSON result of the operation or NULL if the interaction registration fails.
 *
 * Description:
 * This function handles the upserting (inserting or updating) of an HTTP interaction request into the system. It first attempts to insert
 * the interaction into the 'hub_interaction' table and handles any unique constraint violations based on the `hub_upsert_behavior`.
 * It then proceeds to insert the interaction into the 'sat_interaction_http_request' table, extracting relevant details from the `nature` parameter.
 * Depending on the `interaction_key` and `nature`, the function conditionally upserts additional data into satellite tables for FHIR and HL7 requests.
 * Recursive function calls are used to further process FHIR bundles and perform additional validation. 
 * If an error occurs during any step, the function logs the error using the `register_issue` procedure and returns NULL.
 *******************************************************************************************************************************/


DROP FUNCTION IF EXISTS techbd_udi_ingress.register_interaction_http_request(text, text, jsonb, text, text, jsonb, jsonb, text, text, text, text, text, text, text, text, timestamptz, text, text, bool, text, bytea, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text);

DROP FUNCTION IF EXISTS techbd_udi_ingress.register_interaction_http_request(text, text, jsonb, text, text, jsonb, jsonb, text, text, text, text, text, text, text, text, timestamptz, text, text, bool, text, bytea, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text);

DROP FUNCTION IF EXISTS techbd_udi_ingress.register_interaction_http_request(text, text, jsonb, text, text, jsonb, jsonb, text, text, text, text, text, text, text, text, timestamptz, text, text, bool, text, bytea, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text);

DROP FUNCTION IF EXISTS techbd_udi_ingress.register_interaction_http_request(text, text, jsonb, text, text, jsonb, jsonb, text, text, text, text, text, text, text, text, timestamptz, text, text, bool, text, bytea, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text);

CREATE OR REPLACE FUNCTION techbd_udi_ingress.register_interaction_http_request(interaction_id text, interaction_key text, payload jsonb DEFAULT NULL::jsonb, payload_text text DEFAULT NULL::text, rule_namespace text DEFAULT NULL::text, elaboration jsonb DEFAULT NULL::jsonb, nature jsonb DEFAULT NULL::jsonb, content_type text DEFAULT NULL::text, from_state text DEFAULT NULL::text, to_state text DEFAULT NULL::text, state_transition_reason text DEFAULT NULL::text, user_id text DEFAULT NULL::text, user_name text DEFAULT NULL::text, user_session text DEFAULT NULL::text, user_role text DEFAULT NULL::text, created_at timestamp with time zone DEFAULT NULL::timestamp with time zone, created_by text DEFAULT NULL::text, provenance text DEFAULT NULL::text, hub_upsert_behavior boolean DEFAULT true, csv_zip_file_name text DEFAULT NULL::text, csv_zip_file_content bytea DEFAULT NULL::bytea, csv_group_id text DEFAULT NULL::text, csv_status text DEFAULT NULL::text, csv_screening_observation_data_payload_text text DEFAULT NULL::text, csv_screening_profile_data_payload_text text DEFAULT NULL::text, csv_demographic_data_payload_text text DEFAULT NULL::text, csv_qe_admin_data_payload_text text DEFAULT NULL::text, csv_screening_observation_data_file_name text DEFAULT NULL::text, csv_screening_profile_data_file_name text DEFAULT NULL::text, csv_demographic_data_file_name text DEFAULT NULL::text, csv_qe_admin_data_file_name text DEFAULT NULL::text, source_hub_interaction_id text DEFAULT NULL::text, client_ip_address text DEFAULT NULL::text, user_agent text DEFAULT NULL::text, origin text DEFAULT NULL::text, source_type text DEFAULT NULL::text, group_hub_interaction_id text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_error_msg 		TEXT;
    v_error_type 		TEXT;
    v_sqlstate 			TEXT;
    v_pg_detail 		TEXT;
    v_pg_hint 			TEXT;
    v_pg_context 		TEXT;
    v_created_at 		TIMESTAMPTZ := COALESCE(created_at, CURRENT_TIMESTAMP);
    v_created_by 		TEXT 		:= COALESCE(created_by, current_user);
    v_provenance 		TEXT 		:= COALESCE(provenance, 'unknown');
    v_exception_id 		TEXT		:= gen_random_uuid()::text;
   	v_nature_denorm 	TEXT;
   	v_tenant_id_denorm 	TEXT;
   
   	v_from_state				TEXT;
   	v_to_state					TEXT;
   	v_state_transition_reason 	TEXT;
   	v_nature 					JSONB;   
   	v_return 					JSONB := NULL;
   	v_disposition_json			JSONB := NULL;
   	v_payload					JSONB := NULL;
    v_elaboration 				JSONB := NULL;
    v_user_id 					TEXT  := COALESCE(register_interaction_http_request.user_id, current_user);	
   
BEGIN 
	/* This function is designed to handle the registration and upserting of HTTP interaction requests into various tables in the 
     * techbd_udi_ingress schema. It first attempts to insert a record into the hub_interaction table and handles unique constraint violations 
     * based on the hub_upsert_behavior flag. It then inserts data into the sat_interaction_http_request table, capturing details such as 
     * payload, state transitions, and user information. Based on the interaction key and nature of the request, the function conditionally calls 
     * upsert functions for user, FHIR, HL7, CCDA or CSV request data. Additionally, it recursively handles FHIR bundle requests, 
     * processing them through further state transitions. In case of any error, it logs detailed exception information using the 
     * register_issue function. The function returns a JSONB object, representing either the inserted data or a processed result.
     * origin : http/sftp
     * source_type : fhir/hl7/csv/ccda
     */
    -- Attempt to insert into hub_interaction
	BEGIN	   	    
        INSERT INTO techbd_udi_ingress.hub_interaction (hub_interaction_id, key, created_at, created_by, provenance)
        VALUES (register_interaction_http_request.interaction_id, interaction_key, v_created_at, v_created_by, v_provenance);
        /*---register diagnostic log---*/
       	v_elaboration := jsonb_build_object(
         						'interaction_id', register_interaction_http_request.interaction_id,
         						'interaction_key', register_interaction_http_request.interaction_key,
         						'nature', register_interaction_http_request.nature->>'nature',
         						'from_state', register_interaction_http_request.from_state,
         						'to_state', register_interaction_http_request.to_state,
         						'step', '1. Insert into hub_interaction'
         						);
        CALL techbd_udi_ingress.register_diagnostic_log(v_exception_id, register_interaction_http_request.interaction_key, v_created_by, v_provenance, 'info'::text, 
       																'Insert into hub_interaction'::text, v_user_id, 'success'::text, NULL::text, 0, v_elaboration);
        /*------------------------------*/   
    EXCEPTION
        WHEN unique_violation THEN
            IF NOT hub_upsert_behavior THEN
                -- Capture exception details
                GET STACKED DIAGNOSTICS
                    v_error_msg = MESSAGE_TEXT,
                    v_sqlstate = RETURNED_SQLSTATE,
                    v_pg_detail = PG_EXCEPTION_DETAIL,
                    v_pg_hint = PG_EXCEPTION_HINT,
                    v_pg_context = PG_EXCEPTION_CONTEXT;
                    v_error_type = 'SQL';

                -- Call register_issue to log the exception and get the exception ID
                v_exception_id := techbd_udi_ingress.register_issue(
                    COALESCE(v_exception_id, NULL), register_interaction_http_request.interaction_key, v_error_msg, v_error_type, v_sqlstate, v_pg_detail, v_pg_hint, v_pg_context, v_created_by, v_provenance
                );
            END IF; 
       WHEN OTHERS THEN
        	GET STACKED DIAGNOSTICS
                v_error_msg = MESSAGE_TEXT,
                v_sqlstate = RETURNED_SQLSTATE,
                v_pg_detail = PG_EXCEPTION_DETAIL,
                v_pg_hint = PG_EXCEPTION_HINT,
                v_pg_context = PG_EXCEPTION_CONTEXT;
                v_error_type = 'SQL';

         	v_elaboration := jsonb_build_object(
         						'interaction_id', register_interaction_http_request.interaction_id,
         						'interaction_key', register_interaction_http_request.interaction_key,
         						'payload', register_interaction_http_request.payload,
         						'payload_text', register_interaction_http_request.payload_text,
         						'nature', register_interaction_http_request.nature,
         						'from_state', register_interaction_http_request.from_state,
         						'to_state', register_interaction_http_request.to_state
         						);        
               
            -- Log the exception, reusing the previous exception ID if it exists
            v_exception_id := techbd_udi_ingress.register_issue(
                COALESCE(v_exception_id, NULL), register_interaction_http_request.interaction_key, v_error_msg, v_error_type, v_sqlstate, v_pg_detail, v_pg_hint, v_pg_context, v_created_by, v_provenance, v_elaboration
            );
           RETURN NULL;
    END;
    -- Attempt to insert into sat_interaction_http_request
    BEGIN
  
	    v_nature_denorm = trim(nature->>'nature');
	   	v_tenant_id_denorm = nature->>'tenant_id';
	   	/*INSERT INTO techbd_udi_assurance.pgtap_fixtures_json("name","jsonb")
	   	values(gen_random_uuid()::TEXT, register_interaction_http_request.payload);*/
	  
	    -- The insertion to sat_interaction_http_request table needs only once. Need to be corrected later.
        INSERT INTO techbd_udi_ingress.sat_interaction_http_request (
            sat_interaction_http_request_id, hub_interaction_id, nature, content_type, payload, payload_text, from_state, 
            to_state, state_transition_reason, elaboration, created_at, created_by, provenance, nature_denorm, tenant_id_denorm
        )
        VALUES (
            gen_random_uuid()::text, register_interaction_http_request.interaction_id, nature, content_type, payload, payload_text, from_state, to_state, 
            state_transition_reason, elaboration, v_created_at, v_created_by, v_provenance, v_nature_denorm, v_tenant_id_denorm
        );
        /*---register diagnostic log---*/
       	v_elaboration := jsonb_build_object(
         						'interaction_id', register_interaction_http_request.interaction_id,
         						'interaction_key', register_interaction_http_request.interaction_key,
         						'nature', register_interaction_http_request.nature->>'nature',
         						'from_state', register_interaction_http_request.from_state,
         						'to_state', register_interaction_http_request.to_state,
         						'step', '2. Insert into sat_interaction_http_request'
         						);
        CALL techbd_udi_ingress.register_diagnostic_log(v_exception_id, register_interaction_http_request.interaction_key, v_created_by, v_provenance, 'info'::text, 
       																'Insert into sat_interaction_http_request'::text, v_user_id, 'success'::text, NULL::text, 0, v_elaboration);
        /*------------------------------*/
       	--1) Call the function with the defined parameters to upsert user info
       	IF((v_nature_denorm = 'org.techbd.service.http.Interactions$RequestResponseEncountered' AND trim(register_interaction_http_request.interaction_key) NOT IN ('/Hl7/v2', '/Hl7/v2/', '/flatfile/csv/Bundle', '/flatfile/csv/Bundle/', '/flatfile/csv/Bundle/$validate')) /*fhir bundle*/
       	   OR (v_nature_denorm = 'Original HL7 Payload'	AND trim(register_interaction_http_request.interaction_key) IN ('/Hl7/v2', '/Hl7/v2/'))			/*hl7*/
       	   OR (v_nature_denorm = 'Original CSV Zip Archive' AND trim(register_interaction_http_request.interaction_key) IN ('/flatfile/csv/Bundle', '/flatfile/csv/Bundle/', '/flatfile/csv/Bundle/$validate'))   	/*csv*/
       	  ) THEN     		       	
	    	PERFORM techbd_udi_ingress.sat_interaction_user_upserted(
		        hub_interaction_id 			=> register_interaction_http_request.interaction_id,
		        hub_interaction_key			=> register_interaction_http_request.interaction_key, 
	            nature						=> v_nature_denorm,
		        payload						=> register_interaction_http_request.payload, 
		        user_id						=> register_interaction_http_request.user_id, 
		        user_name					=> register_interaction_http_request.user_name, 
		        user_session				=> register_interaction_http_request.user_session, 
		        user_role					=> register_interaction_http_request.user_role,
		        tenant_id					=> v_tenant_id_denorm,
		        elaboration					=> register_interaction_http_request.elaboration,
		        created_at 					=> v_created_at,
		        created_by 					=> v_created_by,
		        provenance 					=> v_provenance
	       	); 
	      	/*---register diagnostic log---*/
	      	v_elaboration := jsonb_build_object(
         						'interaction_id', register_interaction_http_request.interaction_id,
         						'interaction_key', register_interaction_http_request.interaction_key,
         						'nature', register_interaction_http_request.nature->>'nature',
         						'from_state', register_interaction_http_request.from_state,
         						'to_state', register_interaction_http_request.to_state,
         						'step', '3. Insert into user info'
         						);
         	CALL techbd_udi_ingress.register_diagnostic_log(v_exception_id, register_interaction_http_request.interaction_key, v_created_by, v_provenance, 'info'::text, 
       																'Insert into user info'::text, v_user_id, 'success'::text, NULL::text, 0, v_elaboration);
	      	/*------------------------------*/
	    END IF;
	   
	    --2.1) Call the function with the defined parameters to upsert interaction FHIR request info.
	   	IF trim(register_interaction_http_request.interaction_key) IN ('/Bundle', '/Bundle/', '/Bundle/$validate', '/api/expect/fhir/bundle', '/Hl7/v2', '/Hl7/v2/', '/flatfile/csv/Bundle', '/flatfile/csv/Bundle/', '/flatfile/csv/Bundle/$validate')
	   		AND v_nature_denorm NOT IN ('Original HL7 Payload', 'Original CSV Zip Archive', 'Original Flat File CSV', 'CSV Validation Result', 'Converted to FHIR') THEN
	   		
	   		PERFORM techbd_udi_ingress.sat_interaction_fhir_request_upserted(
	   			hub_interaction_id 			=> register_interaction_http_request.interaction_id,
		        tenant_id 					=> v_tenant_id_denorm,
		        uri 						=> register_interaction_http_request.interaction_key,
		        nature 						=> v_nature_denorm,
		        from_state 					=> register_interaction_http_request.from_state,
		        to_state 					=> register_interaction_http_request.to_state,
		        payload						=> register_interaction_http_request.payload,
		        state_transition_reason		=> register_interaction_http_request.state_transition_reason,
		        created_at 					=> v_created_at,
		        created_by 					=> v_created_by,
		        provenance 					=> v_provenance,
		        elaboration					=> register_interaction_http_request.elaboration,	     
		      	source_type					=> register_interaction_http_request.source_type, 
		      	source_hub_interaction_id	=> register_interaction_http_request.source_hub_interaction_id,
		      	group_hub_interaction_id	=> register_interaction_http_request.group_hub_interaction_id
	       	);
	       	/*---register diagnostic log---*/
	       	v_elaboration := jsonb_build_object(
         						'interaction_id', register_interaction_http_request.interaction_id,
         						'interaction_key', register_interaction_http_request.interaction_key,
         						'nature', register_interaction_http_request.nature->>'nature',
         						'from_state', register_interaction_http_request.from_state,
         						'to_state', register_interaction_http_request.to_state,
         						'step', '4. Insert into sat_interaction_fhir_request'
         						);
           	CALL techbd_udi_ingress.register_diagnostic_log(v_exception_id, register_interaction_http_request.interaction_key, v_created_by, v_provenance, 'info'::text, 
       																'Insert into sat_interaction_fhir_request'::text, v_user_id, 'success'::text, NULL::text, 0, v_elaboration);
       	   	/*------------------------------*/															
	    --2.2) Call the function with the defined parameters to upsert interaction HL7 request info.
	    ELSIF trim(register_interaction_http_request.interaction_key) IN ('/Hl7/v2', '/Hl7/v2/') AND v_nature_denorm = 'Original HL7 Payload' THEN
	   		PERFORM techbd_udi_ingress.sat_interaction_hl7_request_upserted(
		        hub_interaction_id 			=> register_interaction_http_request.interaction_id,
		        tenant_id 					=> v_tenant_id_denorm,
		        uri 						=> register_interaction_http_request.interaction_key,
		        nature 						=> v_nature_denorm,
		        from_state 					=> register_interaction_http_request.from_state,
		        to_state 					=> register_interaction_http_request.to_state,
		        payload						=> register_interaction_http_request.payload,
		        state_transition_reason		=> register_interaction_http_request.state_transition_reason,
		        created_at 					=> v_created_at,
		        created_by 					=> v_created_by,
		        provenance 					=> v_provenance,
		        elaboration					=> register_interaction_http_request.elaboration,
		        client_ip_address 			=> register_interaction_http_request.client_ip_address, 
		        user_agent					=> register_interaction_http_request.user_agent, 
		        origin						=> register_interaction_http_request.origin
	       	);
	       	/*---register diagnostic log---*/
	       	v_elaboration := jsonb_build_object(
         						'interaction_id', register_interaction_http_request.interaction_id,
         						'interaction_key', register_interaction_http_request.interaction_key,
         						'nature', register_interaction_http_request.nature->>'nature',
         						'from_state', register_interaction_http_request.from_state,
         						'to_state', register_interaction_http_request.to_state,
         						'step', '4. Insert into sat_interaction_hl7_request'
         						);
           	CALL techbd_udi_ingress.register_diagnostic_log(v_exception_id, register_interaction_http_request.interaction_key, v_created_by, v_provenance, 'info'::text, 
       																'Insert into sat_interaction_hl7_request'::text, v_user_id, 'success'::text, NULL::text, 0, v_elaboration);
       	   	/*------------------------------*/
       	--2.3) Call the function with the defined parameters to upsert interaction CSV request info.													
		ELSIF trim(register_interaction_http_request.interaction_key) IN ('/flatfile/csv/Bundle', '/flatfile/csv/Bundle/', '/flatfile/csv/Bundle/$validate') AND v_nature_denorm IN ('Original CSV Zip Archive', 'Original Flat File CSV', 'CSV Validation Result', 'Converted to FHIR') THEN
			PERFORM techbd_udi_ingress.sat_interaction_csv_request_upserted(
		        interaction_id 				=> register_interaction_http_request.interaction_id,
		        uri 						=> register_interaction_http_request.interaction_key,
		        nature 						=> v_nature_denorm,
		        tenant_id 					=> v_tenant_id_denorm,
		        csv_zip_file_name 			=> register_interaction_http_request.csv_zip_file_name,
		        csv_zip_file_content 		=> register_interaction_http_request.csv_zip_file_content,
		        group_id 					=> register_interaction_http_request.csv_group_id,
		        status						=> register_interaction_http_request.csv_status,
		        csv_screening_observation_data_payload_text => register_interaction_http_request.csv_screening_observation_data_payload_text, 
		        csv_screening_profile_data_payload_text		=> register_interaction_http_request.csv_screening_profile_data_payload_text, 
		        csv_demographic_data_payload_text 			=> register_interaction_http_request.csv_demographic_data_payload_text, 
		        csv_qe_admin_data_payload_text 				=> register_interaction_http_request.csv_qe_admin_data_payload_text,
				csv_screening_observation_data_file_name 	=> register_interaction_http_request.csv_screening_observation_data_file_name, 
		        csv_screening_profile_data_file_name 		=> register_interaction_http_request.csv_screening_profile_data_file_name, 
		        csv_demographic_data_file_name 				=> register_interaction_http_request.csv_demographic_data_file_name, 
		        csv_qe_admin_data_file_name 				=> register_interaction_http_request.csv_qe_admin_data_file_name,
		        validation_result_payload 					=> register_interaction_http_request.payload,		        
		        from_state 					=> register_interaction_http_request.from_state,
		        to_state 					=> register_interaction_http_request.to_state,
		        state_transition_reason 	=> register_interaction_http_request.state_transition_reason,
		        created_at 					=> v_created_at,
		        created_by 					=> v_created_by,
		        provenance 					=> v_provenance,
		        elaboration 				=> NULL::jsonb,
		        zip_file_hub_interaction_id => register_interaction_http_request.source_hub_interaction_id,
		        client_ip_address 			=> register_interaction_http_request.client_ip_address, 
		        user_agent 					=> register_interaction_http_request.user_agent,
		        origin						=> register_interaction_http_request.origin
	       	);
	       	/*---register diagnostic log---*/
	       	v_elaboration := jsonb_build_object(
         						'interaction_id', register_interaction_http_request.interaction_id,
         						'interaction_key', register_interaction_http_request.interaction_key,
         						'nature', register_interaction_http_request.nature->>'nature',
         						'from_state', register_interaction_http_request.from_state,
         						'to_state', register_interaction_http_request.to_state,
         						'step',  '4. Insert into ' || CASE WHEN v_nature_denorm = 'Original CSV Zip Archive' THEN 'sat_interaction_flat_file_csv_request' ELSE 'sat_interaction_zip_file_request' END 
         						);
           	CALL techbd_udi_ingress.register_diagnostic_log(v_exception_id, register_interaction_http_request.interaction_key, v_created_by, v_provenance, 'info'::text, 
       																'Insert into sat_interaction_csv_request'::text, v_user_id, 'success'::text, NULL::text, 0, v_elaboration);
       	   	/*------------------------------*/ 
       	END IF;	
	    /*==============================================================================================================================*/
       
		--RECURSIVE FUNCTION CALL
	   	/*----------------------------- FHIR Bundle inserts into sat_interaction_http_request ----------------------*/
		IF trim(register_interaction_http_request.interaction_key) IN ('/Bundle', '/Bundle/', '/Hl7/v2', '/Hl7/v2/', '/flatfile/csv/Bundle', '/flatfile/csv/Bundle/', '/flatfile/csv/Bundle/$validate') THEN  
			IF (v_nature_denorm = 'org.techbd.service.http.Interactions$RequestResponseEncountered') THEN	--Check previous nature				
				v_from_state 	:= 'NONE';
				v_to_state 		:= 'ACCEPT_FHIR_BUNDLE';
				v_nature 		:= jsonb_build_object('nature', 'Original FHIR Payload', 'tenant_id', v_tenant_id_denorm);
				v_payload 		:= COALESCE(register_interaction_http_request.payload->'request'->'requestBody', 'null'::jsonb);
			
			   	/*---register diagnostic log---*/
	       		v_elaboration := jsonb_build_object(
         						'interaction_id', register_interaction_http_request.interaction_id,
         						'interaction_key', register_interaction_http_request.interaction_key,
         						'nature', register_interaction_http_request.nature->>'nature',
         						'from_state', register_interaction_http_request.from_state,
         						'to_state', register_interaction_http_request.to_state,
         						'step', '5. Insert into sat_interaction_http_request - in recursive call'
         						);
           		CALL techbd_udi_ingress.register_diagnostic_log(v_exception_id, register_interaction_http_request.interaction_key, v_created_by, v_provenance, 'info'::text, 
       																'Insert into sat_interaction_http_request'::text, v_user_id, 'success'::text, NULL::text, 0, v_elaboration);
       	   		/*------------------------------*/
			
				   
				-- Recursive call with adjusted parameters
				v_return := techbd_udi_ingress.register_interaction_http_request(
					interaction_id				=> register_interaction_http_request.interaction_id, 
					interaction_key				=> register_interaction_http_request.interaction_key,  
					payload						=> v_payload,--register_interaction_http_request.payload,  -- Adjust this if needed
					payload_text				=> register_interaction_http_request.payload_text, -- payload_text IS NULL FOR FHIR
					rule_namespace				=> register_interaction_http_request.rule_namespace,
					elaboration					=> register_interaction_http_request.elaboration, 
					nature						=> v_nature,   -- Adjust this if needed
					content_type				=> register_interaction_http_request.content_type, 
					from_state					=> v_from_state, 
					to_state					=> v_to_state, 
					state_transition_reason		=> register_interaction_http_request.state_transition_reason, 
					user_id						=> register_interaction_http_request.user_id, 
					user_name					=> register_interaction_http_request.user_name, 
					user_session				=> register_interaction_http_request.user_session, 
					user_role					=> register_interaction_http_request.user_role, 
					created_at					=> register_interaction_http_request.created_at, 
					created_by					=> register_interaction_http_request.created_by, 
					provenance					=> register_interaction_http_request.provenance, 
					hub_upsert_behavior			=> register_interaction_http_request.hub_upsert_behavior,
					source_hub_interaction_id	=> register_interaction_http_request.source_hub_interaction_id,
					origin 						=> register_interaction_http_request.origin,
					source_type					=> register_interaction_http_request.source_type,
					group_hub_interaction_id	=> register_interaction_http_request.group_hub_interaction_id
			    );
			ELSEIF (v_nature_denorm = 'Original FHIR Payload') THEN	
				v_from_state 	:= 'ACCEPT_FHIR_BUNDLE';
				v_to_state		:= 'DISPOSITION';
				v_nature 		:= jsonb_build_object('nature', 'techByDesignDisposition', 'tenant_id', v_tenant_id_denorm);
				
				SELECT sat_intr_req.payload
				INTO v_payload
				FROM techbd_udi_ingress.sat_interaction_http_request sat_intr_req
				WHERE sat_intr_req.hub_interaction_id = register_interaction_http_request.interaction_id
				AND sat_intr_req.nature_denorm = 'org.techbd.service.http.Interactions$RequestResponseEncountered'
				AND sat_intr_req.tenant_id_denorm = v_tenant_id_denorm;
				
				--Function call to validate with Json Action Rule
				v_disposition_json := techbd_udi_ingress.process_json_action_rules(
					v_payload,
					register_interaction_http_request.rule_namespace,
					register_interaction_http_request.interaction_key
				);
			
				/*---register diagnostic log---*/
	       		v_elaboration := jsonb_build_object(
         						'interaction_id', register_interaction_http_request.interaction_id,
         						'interaction_key', register_interaction_http_request.interaction_key,
         						'nature', register_interaction_http_request.nature->>'nature',
         						'from_state', register_interaction_http_request.from_state,
         						'to_state', register_interaction_http_request.to_state,
         						'v_disposition_json', v_disposition_json::TEXT,
         						'step', '6. Insert into sat_interaction_http_request - in recursive call after process_json_action_rules'
         						);
           		CALL techbd_udi_ingress.register_diagnostic_log(v_exception_id, register_interaction_http_request.interaction_key, v_created_by, v_provenance, 'info'::text, 
       																'Insert into sat_interaction_http_request'::text, v_user_id, 'success'::text, NULL::text, 0, v_elaboration);
       	   		/*------------------------------*/
			
				v_disposition_json := v_disposition_json-> 'response'->'responseBody';
			
					
				-- Recursive call with adjusted parameters
				v_return := techbd_udi_ingress.register_interaction_http_request(
					interaction_id				=> register_interaction_http_request.interaction_id, 
					interaction_key				=> register_interaction_http_request.interaction_key,    
					payload						=> v_disposition_json, -- Adjust this if needed
					payload_text				=> register_interaction_http_request.payload_text, -- payload_text IS NULL FOR FHIR
					rule_namespace				=> register_interaction_http_request.rule_namespace,
					elaboration					=> register_interaction_http_request.elaboration, 
					nature						=> v_nature,   -- Adjust this if needed
				    content_type				=> register_interaction_http_request.content_type, 
					from_state					=> v_from_state, 
					to_state					=> v_to_state, 
					state_transition_reason		=> register_interaction_http_request.state_transition_reason, 
					user_id						=> register_interaction_http_request.user_id, 
					user_name					=> register_interaction_http_request.user_name, 
					user_session				=> register_interaction_http_request.user_session, 
					user_role					=> register_interaction_http_request.user_role, 
					created_at					=> register_interaction_http_request.created_at, 
					created_by					=> register_interaction_http_request.created_by, 
					provenance					=> register_interaction_http_request.provenance, 
					hub_upsert_behavior			=> register_interaction_http_request.hub_upsert_behavior,
					source_hub_interaction_id	=> register_interaction_http_request.source_hub_interaction_id,
					origin 						=> register_interaction_http_request.origin,
					source_type					=> register_interaction_http_request.source_type,
					group_hub_interaction_id	=> register_interaction_http_request.group_hub_interaction_id
			    );
			   
			ELSEIF (v_nature_denorm = 'techByDesignDisposition') THEN
			
				--v_return := register_interaction_http_request.payload;
			
				SELECT sat_intr_req.payload
					INTO v_payload
					FROM techbd_udi_ingress.sat_interaction_http_request sat_intr_req
					WHERE sat_intr_req.hub_interaction_id = register_interaction_http_request.interaction_id
					AND sat_intr_req.nature_denorm = 'techByDesignDisposition'
					AND sat_intr_req.tenant_id_denorm = v_tenant_id_denorm;
	
				v_return := v_payload;
			
				/*---register diagnostic log---*/
	       		v_elaboration := jsonb_build_object(
         						'interaction_id', register_interaction_http_request.interaction_id,
         						'interaction_key', register_interaction_http_request.interaction_key,
         						'nature', register_interaction_http_request.nature->>'nature',
         						'from_state', register_interaction_http_request.from_state,
         						'to_state', register_interaction_http_request.to_state,
         						'v_disposition_json', v_disposition_json::TEXT,
         						'step', '7. Insert into sat_interaction_http_request - in recursive call techByDesignDisposition'
         						);
           		CALL techbd_udi_ingress.register_diagnostic_log(v_exception_id, register_interaction_http_request.interaction_key, v_created_by, v_provenance, 'info'::text, 
       																'Insert into sat_interaction_http_request'::text, v_user_id, 'success'::text, NULL::text, 0, v_elaboration);
       	   		/*------------------------------*/
			
			END IF;	
		END IF;	
	/*==============================================================================================================================*/	 	
    EXCEPTION
        WHEN OTHERS THEN
            -- Capture exception details
            GET STACKED DIAGNOSTICS
                v_error_msg = MESSAGE_TEXT,
                v_sqlstate = RETURNED_SQLSTATE,
                v_pg_detail = PG_EXCEPTION_DETAIL,
                v_pg_hint = PG_EXCEPTION_HINT,
                v_pg_context = PG_EXCEPTION_CONTEXT;
                v_error_type = 'SQL';

         	--RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/ 
         	v_elaboration := jsonb_build_object(
         						'interaction_id', register_interaction_http_request.interaction_id,
         						'interaction_key', register_interaction_http_request.interaction_key,
         						'payload', register_interaction_http_request.payload,
         						'payload_text', register_interaction_http_request.payload_text,
         						'nature', register_interaction_http_request.nature->>'nature',
         						'from_state', register_interaction_http_request.from_state,
         						'to_state', register_interaction_http_request.to_state
         						);        
               
            -- Log the exception, reusing the previous exception ID if it exists
            v_exception_id := techbd_udi_ingress.register_issue(
                COALESCE(v_exception_id, NULL), register_interaction_http_request.interaction_key, v_error_msg, v_error_type, v_sqlstate, v_pg_detail, v_pg_hint, v_pg_context, v_created_by, v_provenance, v_elaboration
            );
           v_return := NULL;
    END;
   	RETURN v_return;
END;
$function$
;







/*******************************************************************************************
 * Comprehensive view of Orchctl issue classification. * 
 ******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.orch_session_issue_classification CASCADE;
CREATE OR REPLACE
VIEW techbd_udi_ingress.orch_session_issue_classification as
WITH cte_business_rule AS (
SELECT
	worksheet AS worksheet,
	field AS field,
	required AS required,
	"Resolved by QE/QCS" AS resolved_by_qe_qcs,
	CONCAT(
          case
		when UPPER("True Rejection") = 'YES' then 'REJECTION'
		else ''
	end,
	case
		when UPPER("Warning Layer") = 'YES' then 'WARNING'
		else ''
	end
      ) AS record_action
FROM
	techbd_orch_ctl.business_rules
GROUP BY
	worksheet,
	field,
	required,
	resolved_by_qe_qcs,
	record_action
)
SELECT
	DISTINCT ON
	(isi.orch_session_issue_id) 
  isi.*,
	CASE
		WHEN
        UPPER(isi.issue_type) = 'MISSING COLUMN'
      THEN
        'STRUCTURAL ISSUE'
		ELSE
        br.record_action
	END
  AS disposition,
	CASE
		WHEN UPPER(br.resolved_by_qe_qcs) = 'YES' THEN 'Resolved By QE/QCS'
		ELSE null
	END AS remediation2
FROM
	techbd_orch_ctl.orch_session_issue AS isi
LEFT JOIN cte_business_rule br ON
	br.field = isi.issue_column
WHERE
	isi.orch_session_issue_id is not null
;

/*******************************************************************************************
 * Comprehensive view of SFTP interactions and their associated requests. * 
 ******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_sftp CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_sftp AS 
WITH issue_count AS (
SELECT
	osi.session_id,
	count(osi.orch_session_issue_id) AS issue_count
FROM
	techbd_udi_ingress.orch_session_issue_classification osi
GROUP BY
	osi.session_id
),
rejection_count AS (
SELECT
	osi.session_id,
	count(osi.orch_session_issue_id) AS rejection_count
FROM
	techbd_udi_ingress.orch_session_issue_classification osi
WHERE 
		osi.disposition = 'REJECTION'
GROUP BY
	osi.session_id
),
warning_count AS (
SELECT
	osi.session_id,
	count(osi.orch_session_issue_id) AS warning_count
FROM
	techbd_udi_ingress.orch_session_issue_classification osi
WHERE 
		osi.disposition = 'WARNING'
GROUP BY
	osi.session_id
)
SELECT
	"substring"(ose.ingest_src::text,
	'/SFTP/([^/]+)/'::text) AS qe,
	os.orch_started_at::timestamptz AS request_time,
	ose.session_id,
	os."version",
	count(ose.ingest_src) AS ingress_count,
	count(ose.ingest_src) AS consumed_count,
	coalesce(ic.issue_count,
	0) AS issue_count,
	coalesce(rc.rejection_count,
	0) AS rejection_count,
	coalesce(wc.warning_count,
	0) AS warning_count
FROM
	techbd_orch_ctl.orch_session_entry ose
JOIN techbd_orch_ctl.orch_session os ON
	ose.session_id = os.orch_session_id
LEFT JOIN issue_count ic ON
	ose.session_id = ic.session_id
LEFT JOIN rejection_count rc ON
	ose.session_id = rc.session_id
LEFT JOIN warning_count wc ON
	ose.session_id = wc.session_id
WHERE
	"substring"(ose.ingest_src::text,
	'/SFTP/([^/]+)/'::text) is not null
GROUP BY
	ose.session_id,
	qe,
	os."version",
	os.orch_started_at::timestamptz,
	ic.issue_count,
	rc.rejection_count,
	wc.warning_count;


/*******************************************************************************************
 * Comprehensive view of Latest FHIR Interactions per Tenant IDs* 
 ******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_recent_fhir CASCADE;
 CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_recent_fhir AS
 WITH ranked_records AS (
    SELECT 
        sihr.sat_interaction_fhir_request_id,
        sihr.hub_interaction_id AS interaction_id,
        sihr.tenant_id AS tenant_id,
        sihr.created_at AS interaction_created_at,
        row_number() OVER (PARTITION BY (upper(sihr.tenant_id)) ORDER BY sihr.created_at DESC) AS rn,
        COUNT(*)
 OVER (PARTITION BY (upper(sihr.tenant_id))) AS interaction_count
    FROM 
        techbd_udi_ingress.sat_interaction_fhir_request sihr 
    WHERE sihr.uri = ANY (ARRAY['/Bundle'::text, '/Bundle/$validate'::text, '/Bundle/'::text, '/Bundle/$validate/'::text])
)
SELECT 
    sat_interaction_fhir_request_id as sat_interaction_http_request_id,
    interaction_id,
    tenant_id,
    interaction_created_at,
    interaction_count
FROM 
    ranked_records
WHERE rn = 1;


/**
 * View to summarize FHIR submission interactions from the database.
 * This view provides an aggregated overview of HTTP request interactions based on
 * different types of nature values recorded in the `sat_interaction_http_request` table.
 * The view calculates the following metrics over the past 7 days:
 *
 * 1. `total_submissions`: Counts submissions where the nature is 'Original FHIR Payload'.
 * 2. `accepted_submissions`: Counts submissions where the nature is 'Forwarded HTTP Response'.
 * 3. `rejected_submissions`: Counts submissions where the nature is 'Forwarded HTTP Response Error'.
 * 4. `pending_submissions`: Counts submissions where the nature is neither 'Forwarded HTTP Response',
 *    'Forwarded HTTP Response Error', nor 'org.techbd.service.http.Interactions$RequestResponseEncountered'.
 *
 * This view aggregates data for all interactions related to FHIR submissions based on the following:
 * - Interaction metadata including the nature of HTTP requests.
 * - Filtering interactions that occurred in the last 7 days.
 * - Using a specific key value (`/Bundle`) to filter interactions.
 *
 * The view helps in monitoring and analyzing FHIR interaction statuses, providing insight into:
 * - Total count of submissions made in the specified period.
 * - Number of submissions that were accepted or rejected.
 * - Submissions that are pending or still not categorized as accepted or rejected.
 *
 * Usage:
 * SELECT * FROM techbd_udi_ingress.fhir_submission_summary;
 *
 * @return TABLE - A table summarizing total, accepted, rejected, and pending FHIR submissions
 *         for interactions within the past 7 days.
 */

DROP VIEW IF EXISTS techbd_udi_ingress.fhir_submission_summary CASCADE;

CREATE OR REPLACE VIEW techbd_udi_ingress.fhir_submission_summary AS 
   WITH submission_counts AS (
    SELECT  
        --NONE    -> ACCEPT_FHIR_BUNDLE
        COUNT(CASE WHEN sihr.nature = 'Original FHIR Payload' THEN 1 END) AS total_submissions,
        --FORWARD-> COMPLETE
        COUNT(CASE WHEN sihr.nature = 'Forwarded HTTP Response' THEN 1 END) AS accepted_submissions,
        --FORWARD-> FAIL
        COUNT(CASE WHEN sihr.nature = 'Forwarded HTTP Response Error' THEN 1 END) AS rejected_submissions
    FROM 
        techbd_udi_ingress.sat_interaction_fhir_request AS sihr
    WHERE 
        sihr."uri" = '/Bundle'
        AND sihr.created_at >= CURRENT_DATE - INTERVAL '7 days'
)
SELECT  
    total_submissions,
    accepted_submissions,
    rejected_submissions,
    total_submissions - accepted_submissions - rejected_submissions AS pending_submissions
FROM 
    submission_counts;


/****************************************************************************************
 * View for tracking recent FHIR submissions and identifying missed submissions per tenant.
 *
 * Purpose:
 * - Summarizes total and successful FHIR interactions for each tenant over the last 7 days.
 * - Highlights missed submissions not forwarded to Shinny Datalake.
 *
 * Columns:
 * - **qe_name**: Tenant name.
 * - **qe_total_submissions**: Total interactions with request-response nature.
 * - **shinny_datalake_submissions**: Count of forwarded submissions.
 * - **missed_shinny_datalake_submissions**: Submissions not forwarded.
 * - **recently_created_at**: Most recent interaction timestamp.
 *
 * Filters:
 * - Focused on '/Bundle/' URIs and recent interactions, excluding 'N/A' tenants.
 * - Ordered by recent activity for quick prioritization.
 ****************************************************************************************/

DROP VIEW IF EXISTS techbd_udi_ingress.fhir_needs_attention CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.fhir_needs_attention AS  
WITH submission_counts AS (
         SELECT sihr.tenant_id_lower AS qe_name,
            count(
                CASE
                    WHEN sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered'::text THEN 1
                    ELSE NULL::integer
                END) AS qe_total_submissions,
 
            count(
                CASE
                    WHEN sihr.nature = 'Forwarded HTTP Response'::text THEN 1
                    ELSE NULL::integer
                END) AS shinny_datalake_submissions,
           count(
                CASE
                    WHEN sihr.nature = 'Forwarded HTTP Response Error'::text THEN 1
                    ELSE NULL::integer
                END) AS shinny_datalake_submissions_failed,
            max(sihr.created_at) AS recently_created_at
           FROM techbd_udi_ingress.sat_interaction_fhir_request sihr
          WHERE (sihr.uri = ANY (ARRAY['/Bundle/'::text, '/Bundle'::text])) AND sihr.created_at >= (CURRENT_DATE - '7 days'::interval) AND sihr.tenant_id <> 'N/A'::text
          GROUP BY sihr.tenant_id_lower
        )
  SELECT 
    qe_name,
    qe_total_submissions,  
    shinny_datalake_submissions,
    shinny_datalake_submissions_failed,
    recently_created_at 
   FROM submission_counts sc
  ORDER BY recently_created_at DESC;


/*************************************
* The stored procedure register_expectation_http_request aims to insert expectation data into two tables: hub_expectation and sat_expectation_http_request. It performs the following steps:

* Input Parameters:

* expectation_id: Unique identifier for the expectation.
* expectation_key: Key associated with the expectation.
* payload: JSONB data containing the request payload.
* content_type (optional): Type of content being registered.
* created_at (optional): Timestamp when the record was created.
* created_by (optional): User who created the record.
* provenance (optional): Source of the record.
* hub_upsert_behavior (optional): Boolean flag to determine upsert behavior (default is true).
*
* Default Values:
*
* v_created_at: Defaults to the current timestamp if not provided.
* v_created_by: Defaults to the current user if not provided.
* v_provenance: Defaults to 'unknown' if not provided.
*
* Insert into hub_expectation:
*
* Attempts to insert the expectation data into the hub_expectation table.
* If a unique constraint violation occurs and hub_upsert_behavior is false, it logs the exception details by calling techbd_udi_ingress.register_issue.
* Insert into sat_expectation_http_request:

* Attempts to insert the HTTP request details into the sat_expectation_http_request table.
* If any exception occurs, it logs the exception details and associates it with a previously logged exception if available.
* Exception Handling:

* Captures various exception details such as error message, SQL state, and additional context.
* Logs the captured exception details using techbd_udi_ingress.register_issue. 
****************************************************************************/

DROP PROCEDURE IF EXISTS techbd_udi_ingress.register_expectation_http_request;
CREATE OR REPLACE PROCEDURE techbd_udi_ingress.register_expectation_http_request(IN expectation_id text, IN expectation_key text, IN payload jsonb, IN content_type text DEFAULT NULL::text, IN created_at timestamp with time zone DEFAULT NULL::timestamp with time zone, IN created_by text DEFAULT NULL::text, IN provenance text DEFAULT NULL::text, IN hub_upsert_behavior boolean DEFAULT true)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    v_error_msg TEXT;
    v_error_type TEXT;
    v_sqlstate TEXT;
    v_pg_detail TEXT;
    v_pg_hint TEXT;
    v_pg_context TEXT;
    v_created_at TIMESTAMPTZ := COALESCE(created_at, CURRENT_TIMESTAMP);
    v_created_by TEXT := COALESCE(created_by, current_user);
    v_provenance TEXT := COALESCE(provenance, 'unknown');
    v_exception_id TEXT;
BEGIN
    -- Attempt to insert into hub_expectation
    BEGIN
        INSERT INTO techbd_udi_ingress.hub_expectation (hub_expectation_id, key, created_at, created_by, provenance)
        VALUES (expectation_id, expectation_key, v_created_at, v_created_by, v_provenance);

    EXCEPTION
        WHEN unique_violation THEN
            IF NOT hub_upsert_behavior THEN
                -- Capture exception details
                GET STACKED DIAGNOSTICS
                    v_error_msg = MESSAGE_TEXT,
                    v_sqlstate = RETURNED_SQLSTATE,
                    v_pg_detail = PG_EXCEPTION_DETAIL,
                    v_pg_hint = PG_EXCEPTION_HINT,
                    v_pg_context = PG_EXCEPTION_CONTEXT;
                    v_error_type = 'SQL';

                -- Call register_issue to log the exception and get the exception ID
                v_exception_id := techbd_udi_ingress.register_issue(
                    NULL, expectation_key, v_error_msg, v_error_type, v_sqlstate, v_pg_detail, v_pg_hint, v_pg_context, v_created_by, v_provenance
                );
            END IF;
    END;

    -- Attempt to insert into sat_expectation_http_request
    BEGIN
        INSERT INTO techbd_udi_ingress.sat_expectation_http_request (
            sat_expectation_http_request_id, hub_expectation_id, content_type, payload, created_at, created_by, provenance
        )
        VALUES (
            gen_random_uuid()::text, expectation_id, content_type, payload, v_created_at, v_created_by, v_provenance);

    EXCEPTION
        WHEN OTHERS THEN
            -- Capture exception details
            GET STACKED DIAGNOSTICS
                v_error_msg = MESSAGE_TEXT,
                v_sqlstate = RETURNED_SQLSTATE,
                v_pg_detail = PG_EXCEPTION_DETAIL,
                v_pg_hint = PG_EXCEPTION_HINT,
                v_pg_context = PG_EXCEPTION_CONTEXT;
                v_error_type= 'SQL';

            -- Log the exception, reusing the previous exception ID if it exists
            v_exception_id := techbd_udi_ingress.register_issue(
                COALESCE(v_exception_id, NULL), expectation_key, v_error_msg, v_error_type, v_sqlstate, v_pg_detail, v_pg_hint, v_pg_context, v_created_by, v_provenance
            );
    END;
END;
$procedure$
;    

/****************************************************************************************
 * View: fhir_needs_attention_details
 * 
 * Purpose:
 * - Provides a filtered view of recent FHIR interactions that encountered HTTP response errors.
 * - Focuses on records related to 'Forwarded HTTP Response Error' events within the last 7 days.
 * - This view is especially useful for monitoring and troubleshooting FHIR Bundle-related issues 
 *   and identifying tenants with recurring errors.
 * 
 * Key Fields:
 * - hub_interaction_id: Unique identifier for each interaction within the hub.
 * - sat_interaction_http_request_id: Maps to the associated HTTP request ID for tracking purposes.
 * - qe_name: Tenant identifier (in lowercase) representing the source of the interaction.
 * - created_at: Timestamp for when the interaction was recorded.
 * 
 * Notes:
 * - The view filters by specific URI patterns ('/Bundle/' and '/Bundle') to target Bundle interactions.
 * - Data is restricted to interactions within the last 7 days to focus on recent issues.
 * - Results are ordered by creation date in descending order, highlighting the most recent interactions.
 ****************************************************************************************/

 
DROP VIEW IF EXISTS techbd_udi_ingress.fhir_needs_attention_details CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.fhir_needs_attention_details
AS select
	sihr.hub_interaction_id,
	sihr.sat_interaction_fhir_request_id as sat_interaction_http_request_id,
	sihr.tenant_id_lower as qe_name,
	sihr.created_at
from
	techbd_udi_ingress.sat_interaction_fhir_request sihr
where
	sihr.nature = 'Forwarded HTTP Response Error'
	and (uri = any (array['/Bundle/',
	'/Bundle']))
	and created_at >= (CURRENT_DATE - '7 days'::interval)
order by
	created_at desc;

/****************************************************************************************
 * Summary of recent FHIR interactions for key tenants.
 * 
 * This view provides a breakdown of HTTP interactions for the past 7 days, grouped by
 * tenant (qe_name), focusing on:
 * - Total submissions by tenant, filtered by specific URI patterns.
 * - Submissions forwarded to Shinny Datalake by tenant.
 * 
 * Purpose:
 * - To monitor recent FHIR-related activity across specific tenants.
 * - Enables tracking of each tenant's submissions, including those forwarded to
 *   the Shinny Datalake.
 * - Useful for identifying trends and ensuring consistent data ingestion.
 ****************************************************************************************/

DROP VIEW IF EXISTS techbd_udi_ingress.fhir_needs_attention_dashbaord CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.fhir_needs_attention_dashbaord AS     
WITH combined_counts AS (
         SELECT sihr.tenant_id_lower AS qe_name,
            count(
                CASE
                    WHEN sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered'::text THEN 1
                    ELSE NULL::integer
                END) AS qe_total_submissions,
            count(
                CASE
                    WHEN sihr.nature = 'Forwarded HTTP Response'::text THEN 1
                    ELSE NULL::integer
                END) AS shinny_datalake_submissions,
            max(sihr.created_at) AS recently_created_at
           FROM techbd_udi_ingress.sat_interaction_fhir_request sihr
          WHERE sihr.created_at >= (CURRENT_DATE - '7 days'::interval) AND (sihr.uri = ANY (ARRAY['/Bundle/'::text, '/Bundle'::text])) AND (sihr.tenant_id_lower = ANY (ARRAY['healthelink'::text, 'healtheconn'::text, 'healthix'::text, 'grrhio'::text, 'hixny'::text]))
          GROUP BY sihr.tenant_id_lower
        )
 SELECT  
    sum(
        CASE
            WHEN qe_name = 'healthelink'::text THEN qe_total_submissions
            ELSE 0::bigint
        END) AS healthelink_total_submissions,
    sum(
        CASE
            WHEN qe_name = 'healtheconn'::text THEN qe_total_submissions
            ELSE 0::bigint
        END) AS healtheconnections_total_submissions,
    sum(
        CASE
            WHEN qe_name = 'healthix'::text THEN qe_total_submissions
            ELSE 0::bigint
        END) AS healthix_total_submissions,
    sum(
        CASE
            WHEN qe_name = 'grrhio'::text THEN qe_total_submissions
            ELSE 0::bigint
        END) AS grrhio_total_submissions,
    sum(
        CASE
            WHEN qe_name = 'hixny'::text THEN qe_total_submissions
            ELSE 0::bigint
        END) AS hixny_total_submissions,
    sum(
        CASE
            WHEN qe_name = 'healthelink'::text THEN shinny_datalake_submissions
            ELSE 0::bigint
        END) AS healthelink_shinny_datalake_submissions,
    sum(
        CASE
            WHEN qe_name = 'healtheconn'::text THEN shinny_datalake_submissions
            ELSE 0::bigint
        END) AS healtheconnections_shinny_datalake_submissions,
    sum(
        CASE
            WHEN qe_name = 'healthix'::text THEN shinny_datalake_submissions
            ELSE 0::bigint
        END) AS healthix_shinny_datalake_submissions,
    sum(
        CASE
            WHEN qe_name = 'grrhio'::text THEN shinny_datalake_submissions
            ELSE 0::bigint
        END) AS grrhio_shinny_datalake_submissions,
    sum(
        CASE
            WHEN qe_name = 'hixny'::text THEN shinny_datalake_submissions
            ELSE 0::bigint
        END) AS hixny_shinny_datalake_submissions
   FROM combined_counts
  WHERE qe_name = ANY (ARRAY['healthelink'::text, 'healtheconn'::text, 'healthix'::text, 'grrhio'::text, 'hixny'::text]);

 
-- techbd_udi_ingress.interaction_fhir_request_failed_needs_attention source
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_request_failed_needs_attention CASCADE;
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_fhir_request_needs_attention CASCADE; 


/**
 * View to summarize HTTP request interactions with client IP and user agent filtering.
 * 
 * This view aggregates and summarizes recent HTTP request interactions within the system,
 * focusing on the past 7 days. It extracts key details such as tenant ID, client IP address, 
 * user agent, and the total count of requests per combination of these elements. 
 * This summary is particularly useful for identifying patterns of interaction across 
 * different tenants, IP addresses, and user agents, allowing for efficient monitoring and analysis.
 * 
 * Key components:
 * - tenant_id: Identifies the tenant responsible for each HTTP request.
 * - client_ip_address: Extracted from the 'x-forwarded-for' header within the request's payload,
 *   representing the IP address from which the request originated.
 * - user_agent: Captures the user agent string from the request headers, identifying the 
 *   client software or device making the request.
 * - request_count: The total number of requests for each unique combination of tenant ID, 
 *   client IP address, and user agent, providing insight into interaction volume.
 * 
 * CTE (Common Table Expression):
 * - The CTE (`cte`) is used to extract the client IP address from the 'x-forwarded-for' header 
 *   if available, falling back to NULL if not. It also filters out requests with a user agent of 
 *   'httpyac' to ensure that only relevant requests are included in the summary.
 * 
 * Filtering:
 * - URI: The view includes only interactions with the URIs '/Bundle' or '/Bundle/'.
 * - Nature: It specifically targets interactions categorized as 'org.techbd.service.http.Interactions$RequestResponseEncountered'.
 * - User Agent: Requests with a user agent of 'httpyac' are excluded to focus on interactions from other sources.
 * - Time Frame: The view is restricted to interactions that occurred within the last 7 days, ensuring the summary is recent and relevant.
 * 
 * Grouping and Ordering:
 * - The results are grouped by tenant_id, client_ip_address, and user_agent to provide a breakdown 
 *   of request counts for each combination.
 * - The final output is ordered by tenant_id, client_ip_address, and user_agent to facilitate 
 *   easy identification of patterns across tenants and clients.
 * 
 * Utility:
 * - This view is useful for system administrators and security analysts who need to monitor and 
 *   analyze HTTP request patterns. By summarizing interaction data based on key factors like 
 *   client IP and user agent, it helps in identifying trends, potential issues, or unauthorized access attempts.
 * 
 * @return VIEW - A summarized view of HTTP request interactions with counts of requests per tenant ID, client IP address, and user agent.
 */


DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_request_summary CASCADE; 
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_request_summary
AS 
WITH cte AS (
    SELECT tenant_id_lower,
           client_ip_address,
           user_agent
    FROM techbd_udi_ingress.sat_interaction_fhir_request
    WHERE nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered'
      AND uri != '/api/expect/fhir/bundle'
      AND user_agent <> 'httpyac'
      AND created_at >= CURRENT_DATE - INTERVAL '7 days' 
)
SELECT tenant_id_lower,
       client_ip_address,
       user_agent,
       COUNT(*) AS request_count
FROM cte
GROUP BY tenant_id_lower, client_ip_address, user_agent
ORDER BY tenant_id_lower, client_ip_address, user_agent;
  

/**
 * View to summarize detailed HTTP request interactions including tenant, client IP, and user agent.
 *
 * This view provides a detailed summary of HTTP request interactions over the past 7 days,
 * capturing essential information such as tenant ID, client IP address, user agent, 
 * hub interaction ID, and the request creation timestamp. This detailed view is valuable 
 * for tracking individual requests and their origins, which can be used for troubleshooting, 
 * auditing, and monitoring purposes.
 * 
 * Key components:
 * - tenant_id: Identifies the tenant responsible for each HTTP request.
 * - client_ip_address: Extracted from the 'x-forwarded-for' header within the request's payload,
 *   representing the IP address from which the request originated. If the header is not present, 
 *   this field will be NULL.
 * - user_agent: Captures the user agent string from the request headers, identifying the 
 *   client software or device making the request.
 * - hub_interaction_id: A unique identifier for each hub interaction, allowing for precise 
 *   tracking and correlation of requests.
 * - request_created_at: The timestamp of when the request was created, providing chronological 
 *   context for the interactions.
 *
 * CTE (Common Table Expression):
 * - The CTE (`cte`) is used to extract and filter the relevant data from the 
 *   `interaction_http_request_mat` table. It includes logic to extract the client IP 
 *   address from the 'x-forwarded-for' header, filter out requests with a user agent 
 *   of 'httpyac', and limit the data to interactions that occurred in the past 7 days.
 * 
 * Filtering:
 * - URI: The view includes only interactions with the URIs '/Bundle' or '/Bundle/'.
 * - Nature: It specifically targets interactions categorized as 
 *   'org.techbd.service.http.Interactions$RequestResponseEncountered'.
 * - User Agent: Requests with a user agent of 'httpyac' are excluded to focus on interactions 
 *   from other sources.
 * - Time Frame: The view is restricted to interactions that occurred within the last 7 days, 
 *   ensuring the summary is recent and relevant.
 * 
 * Ordering:
 * - The results are ordered by the `request_created_at` field in descending order, 
 *   ensuring that the most recent interactions are displayed first.
 *
 * Utility:
 * - This view is particularly useful for administrators and security analysts who need to 
 *   monitor detailed HTTP request interactions. By capturing and organizing data based on 
 *   key factors like tenant ID, client IP, and user agent, it helps in identifying patterns, 
 *   diagnosing issues, and ensuring compliance with security and operational standards.
 *
 * @return VIEW - A detailed summary of HTTP request interactions including tenant, client IP, user agent, hub interaction ID, and request timestamp.
 */


DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_request_summary_details CASCADE; 
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_request_summary_details
AS 
WITH cte AS (
    SELECT tenant_id_lower,
           client_ip_address,
           user_agent,
          hub_interaction_id,  
          created_at         
    FROM techbd_udi_ingress.sat_interaction_fhir_request
    WHERE nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered'
      AND uri != '/api/expect/fhir/bundle'
      AND user_agent <> 'httpyac'
      AND created_at >= CURRENT_DATE - INTERVAL '7 days'  
)
SELECT tenant_id_lower,
       client_ip_address,
       user_agent,
       hub_interaction_id,
       created_at as request_created_at
FROM cte
ORDER BY request_created_at DESC;



/*******************************************************************************************************************************
 * Function to upsert user details related to an HTTP interaction, ensuring the associated hub interaction record exists and 
 * handling exceptions by logging them when necessary.
 *
 * @param hub_interaction_id TEXT - The unique ID for the associated hub interaction.
 * @param hub_interaction_key TEXT - A key to identify the associated hub interaction.
 * @param user_id TEXT - The ID of the user involved in the interaction.
 * @param user_name TEXT - The name of the user involved in the interaction.
 * @param user_session TEXT - The session identifier of the user involved in the interaction.
 * @param user_role TEXT - The role of the user involved in the interaction.
 * @param tenant_id TEXT (nullable) - The tenant ID associated with the interaction. Default is NULL.
 * @param elaboration JSONB (nullable) - Additional JSON data elaborating the user interaction. Default is NULL.
 * @param created_at TIMESTAMPTZ (nullable) - The creation timestamp of the record. Defaults to the current timestamp if NULL.
 * @param created_by TEXT (nullable) - The user who created the record. Defaults to the current user if NULL.
 * @param provenance TEXT (nullable) - The provenance of the record. Defaults to 'unknown' if NULL.
 * 
 * @returns TEXT - Returns the unique ID of the newly inserted or upserted user interaction record.
 *
 * The function performs the following actions:
 * 1. Verifies the existence of the hub interaction record associated with the provided `hub_interaction_id` and `hub_interaction_key`.
 *    If the record does not exist, the function returns NULL.
 * 2. Inserts a new record into the `sat_interaction_user` table, capturing user details along with the associated tenant and
 *    elaboration information.
 * 3. Handles any exceptions that occur during the process by logging the details of the error using the `register_issue` function.
 *    In the event of an error, the function returns NULL.
 *******************************************************************************************************************************/

DROP FUNCTION IF EXISTS techbd_udi_ingress.sat_interaction_user_upserted(text, text, text, jsonb, text, text, text, text, text, jsonb, timestamptz, text, text);
CREATE OR REPLACE FUNCTION techbd_udi_ingress.sat_interaction_user_upserted(hub_interaction_id text, hub_interaction_key text, nature text, payload jsonb, user_id text, user_name text, user_session text, user_role text, tenant_id text DEFAULT NULL::text, elaboration jsonb DEFAULT NULL::jsonb, created_at timestamp with time zone DEFAULT NULL::timestamp with time zone, created_by text DEFAULT NULL::text, provenance text DEFAULT NULL::text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_at 					TIMESTAMPTZ := COALESCE(created_at, CURRENT_TIMESTAMP);
    v_created_by 					TEXT := COALESCE(created_by, current_user);
    v_provenance 					TEXT := COALESCE(provenance, 'unknown');
    v_exception_id 					TEXT;
   	v_hub_interaction_key 			TEXT;
   	v_return						TEXT;
   	v_client_ip_address				TEXT;
   	v_client_ip_address_forwarded	TEXT;
   	v_user_agent		    		TEXT;
   	v_intr_start_time 				TIMESTAMPTZ := NULL;
   	v_intr_finish_time 				TIMESTAMPTZ := NULL;

BEGIN
    -- Verify hub_interaction details
   	SELECT t."key" INTO v_hub_interaction_key
  	FROM techbd_udi_ingress.hub_interaction t
  	WHERE t.hub_interaction_id = sat_interaction_user_upserted.hub_interaction_id 
  	AND t."key" = sat_interaction_user_upserted.hub_interaction_key;

  	IF(v_hub_interaction_key IS NULL) THEN
  		RETURN NULL;	
  	END IF;
  	
  	-- Extract Observability Metrics Start and Finish Time
	SELECT
	MAX(CASE WHEN header->>'name' = 'X-Observability-Metric-Interaction-Start-Time' THEN header->>'value' ELSE NULL END),
	MAX(CASE WHEN header->>'name' = 'X-Observability-Metric-Interaction-Finish-Time' THEN header->>'value' ELSE NULL END) 
	INTO v_intr_start_time,v_intr_finish_time
	FROM jsonb_array_elements(sat_interaction_user_upserted.payload->'response'->'headers') AS header
	;

	-- Extract Client IP Address
   	v_client_ip_address := sat_interaction_user_upserted.payload -> 'request'->>'clientIpAddress';

	-- Extract Client IP Address Forwarded
    SELECT h.value ->> 'value'::text INTO v_client_ip_address_forwarded
    FROM jsonb_array_elements((sat_interaction_user_upserted.payload -> 'request'::text) -> 'headers'::text) h(value)
    WHERE (h.value ->> 'name'::text) = 'x-forwarded-for'::text;   
   
   -- Extract User Agent
   	v_user_agent := sat_interaction_user_upserted.payload -> 'request'->>'userAgent';

    INSERT INTO techbd_udi_ingress.sat_interaction_user (
	sat_interaction_user_id
	,hub_interaction_id
	,uri
	,nature
	,tenant_id
	,user_id
	,user_name
	,user_session
	,user_role
	,client_ip_address
	,user_agent
	,elaboration
	,created_at
	,created_by
	,provenance
	,interaction_start_time
	,interaction_end_time
    )
    VALUES (
    gen_random_uuid()::text, 
    sat_interaction_user_upserted.hub_interaction_id,
    v_hub_interaction_key,
    sat_interaction_user_upserted.nature,
    sat_interaction_user_upserted.tenant_id,
    sat_interaction_user_upserted.user_id,
    sat_interaction_user_upserted.user_name,
    sat_interaction_user_upserted.user_session,
    sat_interaction_user_upserted.user_role,        
    COALESCE(v_client_ip_address_forwarded,v_client_ip_address),        
    v_user_agent,      
    sat_interaction_user_upserted.elaboration, 
    v_created_at, 
    v_created_by, 
    v_provenance,
    v_intr_start_time,
    v_intr_finish_time
    ) RETURNING sat_interaction_user_id INTO v_return;

	RETURN v_return;
EXCEPTION
	WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
		    
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		v_hub_interaction_key,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
	RETURN NULL;
END;
$function$
;

DROP VIEW IF EXISTS techbd_udi_ingress.interaction_user_details CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_user_details
AS SELECT sai.created_at,
    sai.hub_interaction_id,
    sai.uri,
    sai.sat_interaction_user_id,
    sai.user_id,
    sai.user_name,
    sai.user_session,
    sai.user_role,
    sai.client_ip_address,
    sai.user_agent
   FROM techbd_udi_ingress.sat_interaction_user sai
  ORDER BY sai.created_at DESC;


DROP VIEW IF EXISTS techbd_udi_ingress.interaction_user_list CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_user_list
AS SELECT min(created_at) AS created_at,
    min(user_id) AS user_id,
    min(user_name) AS user_name,
    min(user_role) AS user_role,
    user_session
   FROM techbd_udi_ingress.interaction_user_details
  WHERE user_session IS NOT NULL
  GROUP BY user_session
  ORDER BY (min(created_at)) DESC;  

/*******************************************************************************************************************************
Procedure to handle the insertion or update of FHIR interaction data, managing default values and error handling.

@param hub_interaction_id TEXT - The unique identifier for the interaction in the hub.
@param tenant_id TEXT - The identifier for the tenant or client.
@param uri TEXT - The URI associated with the FHIR request.
@param nature TEXT - The nature or type of the HTTP interaction.
@param from_state TEXT - The state before the interaction occurred.
@param to_state TEXT - The state after the interaction.
@param payload JSONB - The JSON payload containing the details of the interaction.
@param state_transition_reason TEXT (nullable) - The reason for the state transition. Default is NULL.
@param created_at TIMESTAMP WITH TIME ZONE (nullable) - The timestamp of record creation. Defaults to the current timestamp if NULL.
@param created_by TEXT (nullable) - The user who created the record. Defaults to the current user if NULL.
@param provenance TEXT (nullable) - The provenance or source of the record. Defaults to 'unknown' if NULL.
@param elaboration JSONB (nullable) - Additional elaborative JSON data related to the interaction. Default is NULL.
@returns TEXT - A textual representation of the result of the operation, typically used to convey success or error messages. 
 *******************************************************************************************************************************/
DROP FUNCTION IF EXISTS techbd_udi_ingress.sat_interaction_fhir_request_upserted(text, text, text, text, text, text, jsonb, text, timestamptz, text, text, jsonb);
DROP FUNCTION IF EXISTS techbd_udi_ingress.sat_interaction_fhir_request_upserted(text, text, text, text, text, text, jsonb, text, timestamptz, text, text, jsonb, text, text);


CREATE OR REPLACE FUNCTION techbd_udi_ingress.sat_interaction_fhir_request_upserted(hub_interaction_id text, tenant_id text, uri text, nature text, from_state text, to_state text, payload jsonb, state_transition_reason text DEFAULT NULL::text, created_at timestamp with time zone DEFAULT NULL::timestamp with time zone, created_by text DEFAULT NULL::text, provenance text DEFAULT NULL::text, elaboration jsonb DEFAULT NULL::jsonb, source_type text DEFAULT NULL::text, source_hub_interaction_id text DEFAULT NULL::text, group_hub_interaction_id text DEFAULT NULL::text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
	--source_type : fhir/hl7/ccda/csv
	--source_hub_interaction_id : first interaction_id for the registration process, 'zip_file_hub_interaction_id' in case of csv.

    -- Declare variables to hold error and extracted data
	v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_at 					TIMESTAMPTZ := COALESCE(created_at, CURRENT_TIMESTAMP);  -- Ensure created_at is not null
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  -- Set default provenance
    v_exception_id 					TEXT;
    
    -- Additional variables for extracting and holding data from the payload JSONB
    v_client_ip_address 			TEXT 	:= NULL;
   	v_client_ip_address_forwarded	TEXT 	:= NULL;
    v_user_agent 					TEXT 	:= NULL;
    v_outbound_http_message 		TEXT 	:= NULL;
    v_error_message 				TEXT 	:= NULL;
    v_issues_count 					INTEGER	:= 0;
   	v_passed 						BOOLEAN	:= NULL;
    v_bundle_id 					TEXT 	:= NULL;
    v_bundle_session_id 			TEXT 	:= NULL;
    v_bundle_last_updated 			TEXT 	:= NULL;
    v_organization_id 				TEXT 	:= NULL;
    v_organization_name 			TEXT 	:= NULL;
    v_patient_id 					TEXT 	:= NULL;
    v_patient_mrn 					TEXT 	:= NULL;
    v_patient_mrn_source_system 	TEXT 	:= NULL;
   	v_medicaid_cin 					TEXT 	:= NULL;
   	v_ssn 							TEXT 	:= NULL;
    v_resource_type_set 			TEXT 	:= NULL;   
   	v_validation_initiated_at 		TEXT 	:= NULL;
    v_validation_completed_at 		TEXT 	:= NULL;   
    v_validation_engine 			TEXT 	:= NULL;
   	v_ig_version 					TEXT 	:= NULL;
   	v_profile_url 					TEXT 	:= NULL;
   	v_interaction_start_time 		TEXT 	:= NULL;
   	v_interaction_end_time 			TEXT 	:= NULL;
   	v_duration_millisecs 			TEXT 	:= NULL;
   	v_response_status				TEXT 	:= NULL;
   	v_return 						TEXT 	:= NULL;
    v_techbd_disposition_action		TEXT 	:= NULL;
    v_elaboration 					JSONB 	:= NULL;
    v_diagnostic_id 				TEXT  	:= gen_random_uuid()::text;
   	v_is_bundle_valid				BOOLEAN	:= NULL;

BEGIN

   	/*---register diagnostic log---*/
  	v_elaboration := jsonb_build_object(
 						'interaction_id', sat_interaction_fhir_request_upserted.hub_interaction_id,
 						'interaction_key', sat_interaction_fhir_request_upserted.uri,
 						'nature', sat_interaction_fhir_request_upserted.nature,
 						'from_state', sat_interaction_fhir_request_upserted.from_state,
 						'to_state', sat_interaction_fhir_request_upserted.to_state,
 						'step', '- In sat_interaction_fhir_request_upserted function'
 						);
 	CALL techbd_udi_ingress.register_diagnostic_log(v_diagnostic_id, sat_interaction_fhir_request_upserted.uri, sat_interaction_fhir_request_upserted.created_by, sat_interaction_fhir_request_upserted.provenance, 'info'::text, 
															'Insert into sat_interaction_fhir_request'::text, current_user, 'success'::text, NULL::text, 0, v_elaboration);
  	/*------------------------------*/
	IF NOT EXISTS(SELECT 1 FROM techbd_udi_ingress.hub_interaction t
  		WHERE t.hub_interaction_id = sat_interaction_fhir_request_upserted.hub_interaction_id 
  		AND t."key" = sat_interaction_fhir_request_upserted.uri) THEN
  		RETURN NULL;	
  	END IF;
    /*---register diagnostic log---*/
  	v_elaboration := jsonb_build_object(
 						'interaction_id', sat_interaction_fhir_request_upserted.hub_interaction_id,
 						'interaction_key', sat_interaction_fhir_request_upserted.uri,
 						'nature', sat_interaction_fhir_request_upserted.nature,
 						'from_state', sat_interaction_fhir_request_upserted.from_state,
 						'to_state', sat_interaction_fhir_request_upserted.to_state,
 						'step', '- Insert into sat_interaction_fhir_request'
 						);
 	CALL techbd_udi_ingress.register_diagnostic_log(v_diagnostic_id, sat_interaction_fhir_request_upserted.uri, sat_interaction_fhir_request_upserted.created_by, sat_interaction_fhir_request_upserted.provenance, 'info'::text, 
															'Insert into sat_interaction_fhir_request'::text, current_user, 'success'::text, NULL::text, 0, v_elaboration);
  	/*------------------------------*/
  
  	IF(LOWER(sat_interaction_fhir_request_upserted.nature) <> LOWER('org.techbd.service.http.Interactions$RequestResponseEncountered')) THEN
		SELECT 
		fhir_req.client_ip_address,			fhir_req.user_agent, 				fhir_req.bundle_id, 
		fhir_req.bundle_last_updated,		fhir_req.organization_id,			fhir_req.organization_name, 
		fhir_req.patient_id, 				fhir_req.patient_mrn,				fhir_req.resource_type_set, 
		fhir_req.validation_initiated_at, 	fhir_req.validation_completed_at,	fhir_req.validation_engine,
		fhir_req.ig_version,				fhir_req.profile_url,				fhir_req.medicaid_cin,
		fhir_req.interaction_start_time,	fhir_req.interaction_end_time,		fhir_req.bundle_session_id,
        fhir_req.patient_mrn_source_system, fhir_req.is_bundle_valid
		INTO 		
		v_client_ip_address,				v_user_agent,						v_bundle_id,
		v_bundle_last_updated,				v_organization_id,					v_organization_name,
		v_patient_id,						v_patient_mrn,						v_resource_type_set,
		v_validation_initiated_at,			v_validation_completed_at,			v_validation_engine,
		v_ig_version,						v_profile_url,						v_medicaid_cin,
		v_interaction_start_time,			v_interaction_end_time,				v_bundle_session_id,
        v_patient_mrn_source_system,        v_is_bundle_valid 	
		FROM
		techbd_udi_ingress.sat_interaction_fhir_request fhir_req
		WHERE 1 = 1
		AND fhir_req.hub_interaction_id = sat_interaction_fhir_request_upserted.hub_interaction_id
		AND fhir_req.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered';	
  	END IF;  	

	IF(LOWER(sat_interaction_fhir_request_upserted.nature) = LOWER('org.techbd.service.http.Interactions$RequestResponseEncountered')) THEN				   
    	
		v_user_agent 				:= sat_interaction_fhir_request_upserted.payload->'request'->>'userAgent';    
    	v_client_ip_address 		:= sat_interaction_fhir_request_upserted.payload->'request'->>'clientIpAddress';    
    	v_issues_count 				:= jsonb_array_length((((((sat_interaction_fhir_request_upserted.payload -> 'response'::text) -> 'responseBody'::text) -> 'OperationOutcome'::text) -> 'validationResults'::text) -> 0) -> 'issues'::text);			
    	v_outbound_http_message 	:= "substring"((((sat_interaction_fhir_request_upserted.payload -> 'response'::text) -> 'responseBody'::text) -> 'OperationOutcome'::text) ->> 'outboundHttpMessage'::text, 'POST[^\n]+'::text);   	
		v_bundle_session_id 		:= sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->>'bundleSessionId';	 				  
    	v_validation_engine 		:= (sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->'validationResults'->0->'observability'->>'name');    
    	v_ig_version				:= (sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->'validationResults'->0->>'igVersion');        
    	v_profile_url				:= (sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->'validationResults'->0->>'profileUrl');      
    	v_is_bundle_valid				:= (sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->'validationResults'->0->>'valid');      
    	v_validation_initiated_at 	:= to_timestamp((sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->'validationResults'->0->>'initiatedAt')::NUMERIC);
    	v_validation_completed_at 	:= to_timestamp((sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->'validationResults'->0->>'completedAt')::NUMERIC);
    	
    	SELECT hdrs->>'value'
		INTO v_client_ip_address_forwarded
    	FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'request'->'headers') AS hdrs
    	WHERE hdrs->>'name' = 'x-forwarded-for'
    	;
    
    	-- Extract the value of X-Observability-Metric-Interaction-Start-Time
		SELECT header->>'value' 
		INTO v_interaction_start_time
		FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'response'->'headers') AS header
		WHERE header->>'name' = 'X-Observability-Metric-Interaction-Start-Time';			
	
		-- Extract the value of X-Observability-Metric-Interaction-Finish-Time
		SELECT header->>'value' 
		INTO v_interaction_end_time
		FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'response'->'headers') AS header
		WHERE header->>'name' = 'X-Observability-Metric-Interaction-Finish-Time';

	    SELECT entry->'resource'->>'id'
	    INTO v_patient_id
	    FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->'entry') AS entry
	    WHERE entry->'resource'->>'resourceType' = 'Patient'
	    LIMIT 1;
	   	   		   
	    SELECT 
	    identifier_element->>'value', 
	    regexp_replace(identifier_element->'assigner'->>'reference','^Organization/', ''),
        identifier_element->>'system'
	    INTO v_patient_mrn, v_organization_id, v_patient_mrn_source_system
	    FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->'entry') AS entry,
	    jsonb_array_elements(entry->'resource'->'identifier') AS identifier_element
	    WHERE entry->'resource'->>'resourceType' = 'Patient'
	    AND identifier_element #>> '{type, coding, 0, code}' = 'MR'
	    LIMIT 1;	  	   
	  
	  	SELECT entry.value->'resource'->>'name' 
	  	INTO v_organization_name
    	FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->'entry') AS entry(value)
   	 	WHERE 
        entry.value->'resource'->>'resourceType' = 'Organization' 
        AND entry.value->'resource'->>'id' = v_organization_id;
   	          
	    SELECT identifier_element->>'value'
	    INTO v_medicaid_cin
	   	FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->'entry') AS entry,
		jsonb_array_elements(entry->'resource'->'identifier') AS identifier_element
		WHERE entry->'resource'->>'resourceType' = 'Patient'
		AND identifier_element #>> '{type, coding, 0, code}' = 'MA'
		LIMIT 1;	   	   			   	
	   	
	   	SELECT
        sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->>'id',
        sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->'meta'->>'lastUpdated'
        INTO v_bundle_id, v_bundle_last_updated
   	 	WHERE
        sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->>'resourceType' = 'Bundle'
       	LIMIT 1;		
	
		SELECT STRING_AGG(DISTINCT entry->'resource'->>'resourceType', ', ') 
		INTO v_resource_type_set
		FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->'entry') AS entry
		WHERE entry ? 'resource';		
	
	END IF; /*End of : org.techbd.service.http.Interactions$RequestResponseEncountered*/
	
	-- Save the action from the OperationOutcome->techByDesignDisposition
	IF LOWER(sat_interaction_fhir_request_upserted.nature) = LOWER('techByDesignDisposition') THEN 
		v_techbd_disposition_action	:= sat_interaction_fhir_request_upserted.payload->'OperationOutcome'->'techByDesignDisposition'->0->>'action';
	END IF;

	IF(LOWER(sat_interaction_fhir_request_upserted.nature) IN(lower('Forwarded HTTP Response Error'), LOWER('Forwarded HTTP Response'), LOWER('Forward HTTP Request'))) THEN
		
		IF(LOWER(sat_interaction_fhir_request_upserted.nature) = lower('Forwarded HTTP Response Error')) THEN
			v_passed := FALSE;
			v_error_message := SUBSTRING(payload ->> 'error'::text FROM POSITION((':'::text) IN (sat_interaction_fhir_request_upserted.payload ->> 'error'::text)) + 2);				
		END IF;
			
		IF(LOWER(sat_interaction_fhir_request_upserted.nature) = lower('Forwarded HTTP Response')) THEN	
			v_response_status := substring(sat_interaction_fhir_request_upserted.payload->> 'scoredcardResponse' FROM 'TestResult:\s*(\w+)');					
			IF v_response_status IS NOT NULL AND v_response_status = 'PASS' THEN
			    v_passed := TRUE;
			ELSE
				IF v_error_message IS NULL THEN 
					v_error_message := sat_interaction_fhir_request_upserted.payload->> 'insertScreeningsResponse';
					SELECT INTO v_issues_count (regexp_matches(v_error_message, 'An unexpected error occurred: (\d+)'))[1]::INTEGER;
				ELSE					
					v_error_message := substring(sat_interaction_fhir_request_upserted.payload->> 'scoredcardResponse' FROM 'Exception:\s*(.*)$');
					SELECT INTO v_issues_count (regexp_matches(v_error_message, 'An unexpected validation error occurred parsing FHIR: (\d+)'))[1]::INTEGER;
				END IF;				
			    v_passed := FALSE;
			END IF;
		END IF;		
			
	END IF; /*End of: Forwarded HTTP Response Error. Forwarded HTTP Response*/
	
	BEGIN
		v_bundle_last_updated := v_bundle_last_updated::TIMESTAMPTZ;
	EXCEPTION
	    WHEN others THEN v_bundle_last_updated := NULL;  -- Set to NULL if it's an invalid timestamp
	END;

    -- The INSERT statement inserts a new record into the sat_interaction_fhir_request table, generating a UUID for the primary key.
    -- Extracted and transformed values from the payload JSONB are inserted into corresponding columns.
    -- If the operation succeeds, the generated UUID is returned.
    INSERT INTO techbd_udi_ingress.sat_interaction_fhir_request (
        sat_interaction_fhir_request_id,
        hub_interaction_id,
        tenant_id,
        tenant_id_lower,
        uri,
        nature,
        payload,
        client_ip_address,
        user_agent,
        from_state,
        to_state,
        state_transition_reason,
        outbound_http_message,
        error_message,
        issues_count,
        bundle_id,
        bundle_session_id,
        bundle_last_updated,
        organization_id,
        organization_name,
        patient_id,
        patient_mrn,
        resource_type_set,
        validation_initiated_at,
        validation_completed_at,
        validation_engine,
        elaboration,
        created_by,
        provenance,
        ig_version,
        profile_url,
        passed,
        medicaid_cin,
        interaction_start_time,
        interaction_end_time,
        techbd_disposition_action,
        patient_mrn_source_system,
        source_type,
        source_hub_interaction_id,
        group_hub_interaction_id,
        is_bundle_valid
    )
    VALUES (
        gen_random_uuid()::TEXT,  -- Generate a unique UUID for the primary key
        hub_interaction_id,
        tenant_id,
        LOWER(tenant_id),  -- Store the tenant ID in lowercase for consistency
        uri,
        nature,
        payload,
        COALESCE(v_client_ip_address_forwarded,v_client_ip_address),
        COALESCE(v_user_agent,''),
        from_state,
        to_state,
        state_transition_reason,
        v_outbound_http_message,
        v_error_message,
        COALESCE(v_issues_count,0),
        v_bundle_id,
        v_bundle_session_id,
        COALESCE(NULLIF(v_bundle_last_updated, '')::TIMESTAMPTZ, NULL),
        v_organization_id,
        v_organization_name,
        v_patient_id,
        v_patient_mrn,
        v_resource_type_set,
        COALESCE(v_validation_initiated_at::TIMESTAMPTZ,NULL),
        COALESCE(v_validation_completed_at::TIMESTAMPTZ,NULL),
        v_validation_engine,
        sat_interaction_fhir_request_upserted.elaboration,
        created_by,
        provenance,
        v_ig_version,
        v_profile_url,
        v_passed,
        v_medicaid_cin,
        COALESCE(v_interaction_start_time::TIMESTAMPTZ,NULL),
        COALESCE(v_interaction_end_time::TIMESTAMPTZ,NULL),
        v_techbd_disposition_action,
        v_patient_mrn_source_system,
        source_type,
        source_hub_interaction_id,
        group_hub_interaction_id,
        v_is_bundle_valid
    ) RETURNING sat_interaction_fhir_request_id INTO v_return;  -- Return the generated UUID

    IF (v_return IS NOT NULL) THEN
        IF(uri='/Bundle' OR uri='/Bundle/' OR uri='/flatfile/csv/Bundle' OR uri='/flatfile/csv/Bundle/') THEN
            CALL techbd_udi_ingress.insert_fhir_session_diagnostic(
                hub_interaction_id, 
                tenant_id, 
                uri, 
                v_bundle_session_id, 
                payload, 
                created_by, 
                provenance,
                sat_interaction_fhir_request_upserted.elaboration
            );
            IF(LOWER(sat_interaction_fhir_request_upserted.nature) = LOWER('techByDesignDisposition')) THEN
                CALL techbd_udi_ingress.insert_validation_issues(
                    hub_interaction_id, 
                    uri, 
                    payload, 
                    created_by, 
                    provenance,
                    sat_interaction_fhir_request_upserted.elaboration
                );
            END IF;              
            IF(LOWER(sat_interaction_fhir_request_upserted.nature) = LOWER('Original FHIR Payload')) THEN
                CALL techbd_udi_ingress.insert_fhir_screening_info(
                    hub_interaction_id, 
                    tenant_id, 
                    uri, 
                    v_created_at, 
                    payload,
                    created_by, 
                    provenance,
                    sat_interaction_fhir_request_upserted.elaboration
                );
                CALL techbd_udi_ingress.insert_fhir_screening_patient(
                    hub_interaction_id, 
                    tenant_id, 
                    uri, 
                    v_created_at, 
                    payload,
                    created_by, 
                    provenance,
                    sat_interaction_fhir_request_upserted.elaboration,
                    v_organization_id
                );
                CALL techbd_udi_ingress.insert_fhir_screening_organization(
                    hub_interaction_id, 
                    tenant_id, 
                    uri, 
                    v_created_at, 
                    payload,
                    created_by, 
                    provenance,
                    sat_interaction_fhir_request_upserted.elaboration 
                );
            END IF;                  
        END IF;         
    END IF;        

    RETURN v_return;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    --RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		sat_interaction_fhir_request_upserted.uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
		RETURN NULL;
END;
$function$
;
/*******************************************************************************************
  This view provides a consolidated view of failed HTTP requests and associated interactions.
******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_request_forward_failure;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_request_forward_failure
AS SELECT sat_interaction_fhir_request_id,
    hub_interaction_id AS interaction_id,
    tenant_id,
    uri,
    bundle_id,
    nature,
    created_at AS interaction_created_at,
    created_by AS interaction_created_by,
    provenance AS interaction_provenance,
    client_ip_address,
    user_agent,
    from_state,
    to_state,
    outbound_http_message,
    error_message AS error,
    issues_count,
    resource_type_set AS resource_types,
    patient_id,
    payload,
    patient_mrn,
    concat_ws('-'::text, tenant_id, organization_id, patient_mrn) AS source_mrn,
    (SELECT string_agg(concat_ws(': ', key, COALESCE(value, 'NULL')), ', ') FROM jsonb_each_text((payload->>'responseBody')::jsonb) AS json_data(key, value)) AS response_body_details,
    case 
    	when (source_type = 'CSV') then 'CSV'
    	when (source_type = 'fhir') then 'FHIR'
    	when (source_type = 'FHIR') then 'FHIR'
    	else 'FHIR'
    end as source_type,   
    source_hub_interaction_id
   FROM techbd_udi_ingress.sat_interaction_fhir_request intr_hreq
WHERE to_state = 'FAIL'::text;

/*******************************************************************************************************************************
Function to process a set of JSON action rules on a given JSON input.

Parameters:
input_json    - The JSONB input on which the rules will be applied (JSONB)
rule_namespace- The namespace for selecting action rules (TEXT)
key           - A unique key to validate the process (TEXT)
created_by    - The user who triggered the function (optional, default is NULL) (TEXT)
provenance    - The origin of the data or process (optional, default is NULL) (TEXT)

Returns:
Modified JSONB after applying the action rules.
*******************************************************************************************************************************/
DROP FUNCTION IF EXISTS techbd_udi_ingress.process_json_action_rules(jsonb,text,text,text,text);
CREATE OR REPLACE FUNCTION techbd_udi_ingress.process_json_action_rules(input_json jsonb, rule_namespace text, key text, created_by text DEFAULT NULL::text, provenance text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_current_rule 		RECORD;
    v_temp_json 		JSONB := process_json_action_rules.input_json;
    v_json_value 		JSONB;
   	v_json_path 		TEXT;
   	v_found_flag   		BOOLEAN;
   	v_new_action    	JSONB;
   	v_error_msg 		TEXT;
    v_error_type 		TEXT;
    v_sqlstate 			TEXT;
    v_pg_detail 		TEXT;
    v_pg_hint 			TEXT;
    v_pg_context 		TEXT;
   	v_issue_message		TEXT;
   	v_message_path		TEXT;
   	v_action_payload	JSONB;
    v_is_accept_flag	NUMERIC := 1;
BEGIN	
    v_temp_json := process_json_action_rules.input_json;

	IF(process_json_action_rules.key IS NULL) THEN
		RETURN NULL;	
	END IF;
    -- Loop through each row of json_action_rule within the given namespace
    FOR v_current_rule IN 
        SELECT json_path, action, reject_json, modify_json, condition, priority, "namespace" 
        FROM techbd_udi_ingress.json_action_rule 
        WHERE (namespace = process_json_action_rules.rule_namespace OR process_json_action_rules.rule_namespace IS NULL)
        ORDER BY priority DESC -- Apply rules in order of priority
    LOOP
		 -- Check if the json_path starts with '$.'
        IF LEFT(v_current_rule.json_path, 2) = '$.' THEN
            v_json_path := v_current_rule.json_path;
        ELSE
            v_json_path := '$.' || v_current_rule.json_path;
        END IF;
		
	     -- Check if the json_path content exists in v_temp_json
        v_found_flag := jsonb_path_exists( v_temp_json, v_json_path::jsonpath); -- Casting to jsonpath;   

		IF v_found_flag = false THEN
			CONTINUE;
		END IF; 
	
		IF v_current_rule.action = 'reject' OR v_current_rule.action = 'discard' THEN  					                                    	         
		
			-- Dynamically build the path to extract the "message" based on v_json_path
            v_message_path := v_json_path || '.message';          

            -- Retrieve the corresponding "message" value dynamically using v_message_path
            SELECT jsonb_path_query(v_temp_json, v_message_path::jsonpath) 
            INTO v_issue_message;   
           
            IF v_issue_message IS NULL THEN
           		SELECT jsonb_path_query(v_temp_json, v_json_path::jsonpath) 
            	INTO v_issue_message;   
            END IF;
           
            v_action_payload := jsonb_build_object('description', v_current_rule."namespace", 'message', v_issue_message);
		
            v_new_action := jsonb_build_object(
                'action', v_current_rule.action, --'reject',
                'actionPayload', COALESCE(v_current_rule.reject_json, v_action_payload) -- Including reject_json as JSONB
            );           
           	
            -- Check if 'techByDesignDisposition' exists in response->responseBody->OperationOutcome
            IF v_temp_json->'response'->'responseBody'->'OperationOutcome' ? 'techByDesignDisposition' THEN
                -- Append to existing array
                v_temp_json := jsonb_set(
                    v_temp_json,
                    '{response,responseBody,OperationOutcome,techByDesignDisposition}',
                    (v_temp_json->'response'->'responseBody'->'OperationOutcome'->'techByDesignDisposition') || v_new_action
                );
            ELSE
                -- Create the array and add the new action
                v_temp_json := jsonb_set(
                    v_temp_json,
                    '{response,responseBody,OperationOutcome,techByDesignDisposition}', 
                    jsonb_build_array(v_new_action)
                );
            END IF;
           
            -- If any 'reject' rule is found, then set the v_is_accept_flag to 0, means it is not fully accepted
            v_is_accept_flag := 0;
		END IF;           
	
		-- Update the last_applied_at for the rule
		UPDATE techbd_udi_ingress.json_action_rule
			SET last_applied_at = current_timestamp
				WHERE json_path = v_current_rule.json_path 
					AND namespace = process_json_action_rules.rule_namespace;
				
		-- If the action is discard then, no need to continue with other rules, just return.
		IF v_current_rule.action = 'discard' THEN 
			RETURN v_temp_json;
		END IF; 
	
		-- Initialize the varible with default values; 
		v_found_flag 		:= FALSE;
		v_json_path			:= NULL;
		v_new_action		:= NULL;
		v_message_path		:= NULL;
		v_action_payload	:= NULL;
    END LOOP;

    /*If all the selected rules are accepted, then add techByDesignDisposition tag with 'accepted'*/
    IF v_is_accept_flag = 1 THEN 
    	v_new_action := jsonb_build_object(
                'action', 'accept'
            );
   
	   IF v_temp_json->'response'->'responseBody'->'OperationOutcome' ? 'techByDesignDisposition' THEN
	        -- Append to existing array
	        v_temp_json := jsonb_set(
	            v_temp_json,
	            '{response,responseBody,OperationOutcome,techByDesignDisposition}',
	            (v_temp_json->'response'->'responseBody'->'OperationOutcome'->'techByDesignDisposition') || v_new_action
	        );
	    ELSE
	        -- Create the array and add the new action
	        v_temp_json := jsonb_set(
	            v_temp_json,
	            '{response,responseBody,OperationOutcome,techByDesignDisposition}', 
	            jsonb_build_array(v_new_action)
	        );
	    END IF;
    END IF;                      
   
    -- Return the modified JSON
    RETURN v_temp_json;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    --RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		PERFORM techbd_udi_ingress.register_issue(
        NULL,
		process_json_action_rules.interaction_key,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		process_json_action_rules.created_by,
		process_json_action_rules.provenance);
		RETURN NULL;
END;
$function$
;

/*******************************************************************************************************************************
Procedure for inserting FHIR session diagnostic data extracted from a JSONB payload.

Parameters:
hub_interaction_id  - Unique identifier of the hub interaction (UUID)
tenant_id           - Unique identifier of the tenant (UUID)
uri                 - URI associated with the FHIR session (TEXT)
v_bundle_session_id - Unique identifier of the bundle session (UUID)
payload             - JSONB object containing the FHIR response and validation results (JSONB)
created_by          - Identifier of the user or system creating the record (TEXT)
provenance          - Metadata providing the provenance or origin of the interaction (TEXT)

Returns:
No return value. Inserts diagnostic records into the 'sat_interaction_fhir_session_diagnostic' table for each issue found in the payload.
*******************************************************************************************************************************/
DROP PROCEDURE IF EXISTS techbd_udi_ingress.insert_fhir_session_diagnostic(text,text,text,text,jsonb,text,text);
CREATE OR REPLACE PROCEDURE techbd_udi_ingress.insert_fhir_session_diagnostic(
    IN hub_interaction_id TEXT,
    IN tenant_id TEXT,
    IN uri TEXT,
    IN bundle_session_id TEXT,
    IN payload JSONB,
    IN created_by TEXT,
    IN provenance TEXT,
    IN elaboration JSONB
)
LANGUAGE plpgsql
AS $$
DECLARE
    session_diagnostic_set          RECORD;
    v_exception_id 	                TEXT;
    v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  
BEGIN
    -- Extract values from the JSONB payload variable
    FOR session_diagnostic_set IN
        SELECT
            issue.value ->> 'severity'::text AS severity,
            issue.value ->> 'message'::text AS message,
            (issue.value -> 'location'::text) ->> 'line'::text AS line,
            (issue.value -> 'location'::text) ->> 'column'::text AS "column",
            (issue.value -> 'location'::text) ->> 'diagnostics'::text AS diagnostics,
            (insert_fhir_session_diagnostic.payload -> 'response'::text) ->> 'encounteredAt'::text AS encounteredAt,
            insert_fhir_session_diagnostic.elaboration
        FROM LATERAL jsonb_array_elements(
            (((insert_fhir_session_diagnostic.payload -> 'response'::text) -> 'responseBody'::text) -> 'OperationOutcome'::text) -> 'validationResults'::text
        ) validationresult(value),
        LATERAL jsonb_array_elements(validationresult.value -> 'issues'::text) issue(value)
    LOOP
        -- Insert extracted data into the target table
        INSERT INTO techbd_udi_ingress.sat_interaction_fhir_session_diagnostic (
            sat_interaction_fhir_session_diagnostic_id,
            hub_interaction_id,
            tenant_id,
            uri,
            session_id,
            severity,
            message,
            "line",
            "column",
            diagnostics,
            encountered_at,
            elaboration,
            created_by,
            provenance
        )
        VALUES (
            gen_random_uuid()::TEXT, 
            insert_fhir_session_diagnostic.hub_interaction_id,
            insert_fhir_session_diagnostic.tenant_id,
            insert_fhir_session_diagnostic.uri,
            insert_fhir_session_diagnostic.bundle_session_id,
            session_diagnostic_set.severity,
            session_diagnostic_set.message,
            session_diagnostic_set.line,
            session_diagnostic_set.column,
            session_diagnostic_set.diagnostics,
            session_diagnostic_set.encounteredAt,
            session_diagnostic_set.elaboration,
            insert_fhir_session_diagnostic.created_by,
            insert_fhir_session_diagnostic.provenance
        );
    END LOOP;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    -- RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		insert_fhir_session_diagnostic.uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
END;
$$;

DROP PROCEDURE IF EXISTS techbd_udi_ingress.insert_fhir_screening_info(text,text,text,TIMESTAMPTZ,jsonb,text,text,jsonb);
CREATE OR REPLACE PROCEDURE techbd_udi_ingress.insert_fhir_screening_info (
    IN hub_interaction_id TEXT,
    IN tenant_id TEXT,
    IN uri TEXT,
    IN created_at TIMESTAMPTZ,
    IN payload JSONB,
    IN created_by TEXT,
    IN provenance TEXT,
    IN elaboration JSONB
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_exception_id 	                TEXT;
    v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  
BEGIN
    INSERT INTO techbd_udi_ingress.sat_interaction_fhir_screening_info (
        sat_interaction_fhir_screening_info_id,
        hub_interaction_id,
        qe_name,
        submitted_date_time,
        survey_date_time,
        patient_mrn,
        full_name,
        last_name,
        first_name,
        org_id,
        org_name,
        areas_of_interest,
        total_safety_score,
        elaboration,
        created_by,
        provenance
    )
    SELECT 
        gen_random_uuid()::TEXT,
        insert_fhir_screening_info.hub_interaction_id,
        insert_fhir_screening_info.tenant_id,
        insert_fhir_screening_info.created_at,
        CASE
            WHEN (insert_fhir_screening_info.payload ->> 'resourceType' = 'Bundle') THEN (insert_fhir_screening_info.payload -> 'meta' ->> 'lastUpdated')
            ELSE NULL
        END AS survey_date_time,
        (SELECT (((entry.value -> 'resource') -> 'identifier') -> 0) ->> 'value'
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Patient'
         LIMIT 1) AS patient_mrn,
        (SELECT (((entry.value -> 'resource') -> 'name') -> 0) ->> 'text'
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Patient'
         LIMIT 1) AS full_name,
        (SELECT (((entry.value -> 'resource') -> 'name') -> 0) ->> 'family'
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Patient'
         LIMIT 1) AS last_name,
        (SELECT array_to_string(ARRAY(SELECT jsonb_array_elements_text((((entry.value -> 'resource') -> 'name') -> 0) -> 'given')), ' ')
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Patient'
         LIMIT 1) AS first_name,
        (SELECT string_agg((entry.value -> 'resource') ->> 'id', ', ')
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Organization'
         LIMIT 1) AS org_id,
        (SELECT string_agg((entry.value -> 'resource') ->> 'name', ', ')
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Organization'
         LIMIT 1) AS org_name,
        (SELECT string_agg(DISTINCT coding.value ->> 'display', ', ')
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
             JOIN LATERAL jsonb_array_elements((entry.value -> 'resource') -> 'category') category(value) ON true
             JOIN LATERAL jsonb_array_elements(category.value -> 'coding') coding(value) ON true
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Observation' AND (coding.value ->> 'system') = 'http://hl7.org/fhir/us/sdoh-clinicalcare/CodeSystem/SDOHCC-CodeSystemTemporaryCodes'
         LIMIT 1) AS areas_of_interest,
        (SELECT value_coding.value ->> 'display'
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
             JOIN LATERAL jsonb_array_elements(((entry.value -> 'resource') -> 'code') -> 'coding') code_coding(value) ON true
             JOIN LATERAL jsonb_array_elements(((entry.value -> 'resource') -> 'valueCodeableConcept') -> 'coding') value_coding(value) ON true
          WHERE (code_coding.value ->> 'display') = 'Total Safety Score' AND (value_coding.value ->> 'code') = '{score}'
         LIMIT 1) AS total_safety_score,
        insert_fhir_screening_info.elaboration,
        insert_fhir_screening_info.created_by,
        insert_fhir_screening_info.provenance
    WHERE (SELECT (((entry.value -> 'resource') -> 'identifier') -> 0) ->> 'value'
           FROM jsonb_array_elements(payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Patient'
         LIMIT 1) IS NOT NULL;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    -- RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		insert_fhir_screening_info.uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
END;         
$$;

DROP PROCEDURE IF EXISTS techbd_udi_ingress.insert_validation_issues(text,text,jsonb,text,text,jsonb);
CREATE OR REPLACE PROCEDURE techbd_udi_ingress.insert_validation_issues (
    IN hub_interaction_id TEXT,
    IN uri TEXT,
    IN payload JSONB,
    IN created_by TEXT,
    IN provenance TEXT,
    IN elaboration JSONB
)
LANGUAGE plpgsql
AS $$
DECLARE
    issue_set                       RECORD;
    v_exception_id 	                TEXT;
    v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  
BEGIN
    -- Extract values from the JSONB payload variable
    FOR issue_set IN
        SELECT
            jsonb_array_elements(validation_result -> 'issues'::text) AS issue,
            to_timestamp(((validation_result ->> 'completedAt'::text)::numeric)::double precision) AS date_time,
            validation_result ->> 'igVersion'::text AS ig_version,
            TRIM(BOTH FROM regexp_replace(
                (validation_result -> 'observability'::text) ->> 'name'::text, 
                '\(TODO:get from API instead of hard coding\) \(FHIR version 4.0.1\)\s*$'::text, ''::text)) AS validation_engine
        FROM LATERAL jsonb_array_elements(insert_validation_issues.payload -> 'OperationOutcome'-> 'validationResults'::text) validation_result
    LOOP
        -- Insert the extracted data into the target table
       INSERT INTO techbd_udi_ingress.sat_interaction_fhir_validation_issue (
            sat_interaction_fhir_validation_issue_id,
            hub_interaction_id,
            issue,
            date_time,
            validation_engine,
            ig_version,
            elaboration,
            created_by,
            provenance,
            severity
        )
        VALUES (
            gen_random_uuid()::TEXT, 
            insert_validation_issues.hub_interaction_id,
            issue_set.issue ->> 'message'::text, 
            issue_set.date_time,
            issue_set.validation_engine,
            issue_set.ig_version,
            insert_validation_issues.elaboration,
            v_created_by,
            insert_validation_issues.provenance,
            issue_set.issue ->> 'severity'::text
        );
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        -- Capture exception details
        GET STACKED DIAGNOSTICS
            v_error_msg = MESSAGE_TEXT,
            v_sqlstate = RETURNED_SQLSTATE,
            v_pg_detail = PG_EXCEPTION_DETAIL,
            v_pg_hint = PG_EXCEPTION_HINT,
            v_pg_context = PG_EXCEPTION_CONTEXT;
            v_error_type = 'SQL';
        
        -- Log the exception, reusing the previous exception ID if it exists
        v_exception_id := techbd_udi_ingress.register_issue(
            COALESCE(v_exception_id, NULL),
            insert_validation_issues.uri,
            v_error_msg,
            v_error_type,
            v_sqlstate,
            v_pg_detail,
            v_pg_hint,
            v_pg_context,
            v_created_by,
            v_provenance
        );
END;       
$$;

/**
* The function techbd_udi_ingress.json_action_rule_upserted is designed to either insert a new record or 
* update an existing record in the json_action_rule table, depending on whether the action_rule_id is provided. 
* If the action_rule_id is not NULL, the function attempts to update the existing record. If action_rule_id is NULL, 
* a new record is inserted with a randomly generated UUID as the primary key.

* The function also handles exception logging. In the event of an error during the execution of an insert or 
* update operation, the exception details are captured, and the issue is logged in a diagnostic table using the * register_issue function.
*/
DROP FUNCTION IF EXISTS techbd_udi_ingress.json_action_rule_upserted(text, text, text, text, jsonb, jsonb, jsonb, int4, text, text, text);
DROP FUNCTION IF EXISTS techbd_udi_ingress.json_action_rule_upserted(text, text, text, text, jsonb, jsonb, jsonb, int4, text, text, text, text);
CREATE OR REPLACE FUNCTION techbd_udi_ingress.json_action_rule_upserted(action_rule_id text, namespace text, json_path text, action text, condition jsonb, reject_json jsonb, modify_json jsonb, priority integer, description text, updated_by text, created_by text, provenance text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    -- Declare variables to hold error and extracted data
    v_error_msg                 TEXT;
    v_error_type                TEXT;
    v_sqlstate                  TEXT;
    v_pg_detail                 TEXT;
    v_pg_hint                   TEXT;
    v_pg_context                TEXT;
    v_exception_id              TEXT;
    v_created_by                TEXT        := COALESCE(json_action_rule_upserted.created_by, current_user);  -- Default created_by to the current user if not provided    
    v_updated_by                TEXT        := COALESCE(json_action_rule_upserted.updated_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance                TEXT        := COALESCE(provenance, 'unknown');  -- Set default provenance
    v_return                    TEXT;
    
BEGIN
	/**
	* The function techbd_udi_ingress.json_action_rule_upserted is designed to either insert a new record or 
	* update an existing record in the json_action_rule table, depending on whether the action_rule_id is provided. 
	* If the action_rule_id is not NULL, the function attempts to update the existing record. If action_rule_id is NULL, 
	* a new record is inserted with a randomly generated UUID as the primary key.
	
	* The function also handles exception logging. In the event of an error during the execution of an insert or 
	* update operation, the exception details are captured, and the issue is logged in a diagnostic table using the * register_issue function.
	*/
	
	-- Check whether the json rule specified in 'json_path' is a valid path or not. If not then, raise exception
	IF techbd_udi_ingress.is_valid_jsonpath(json_action_rule_upserted.json_path) = FALSE THEN 
		RAISE EXCEPTION 'Invalid json_path.';
	END IF;
	
    -- First, attempt to update the record if it exists
	IF(json_action_rule_upserted.action_rule_id IS NOT null) THEN

		UPDATE techbd_udi_ingress.json_action_rule
		SET
			"namespace"         = json_action_rule_upserted.namespace,
			json_path           = json_action_rule_upserted.json_path,
			"action"            = json_action_rule_upserted.action,
			"condition"         = json_action_rule_upserted.condition,
			reject_json         = json_action_rule_upserted.reject_json,
			modify_json         = json_action_rule_upserted.modify_json,
			priority            = json_action_rule_upserted.priority,
			updated_at          = CURRENT_TIMESTAMP,
			updated_by          = v_updated_by,
			last_applied_at     = CURRENT_TIMESTAMP,
			provenance          = json_action_rule_upserted.provenance,
			description 		= json_action_rule_upserted.description
			WHERE techbd_udi_ingress.json_action_rule.action_rule_id = json_action_rule_upserted.action_rule_id
			RETURNING techbd_udi_ingress.json_action_rule.action_rule_id INTO v_return 
		;	

		RETURN v_return;
	END IF;

   	INSERT INTO techbd_udi_ingress.json_action_rule (
        action_rule_id,
        "namespace",
        json_path,
        "action",
        "condition",
        reject_json,
        modify_json,
        priority,
        description,
        updated_at,
        updated_by,
        last_applied_at,
        created_at,
        created_by,
        provenance
    ) VALUES (
        gen_random_uuid()::TEXT,
        json_action_rule_upserted.namespace,
        json_action_rule_upserted.json_path,
        json_action_rule_upserted.action,
        json_action_rule_upserted.condition,
        json_action_rule_upserted.reject_json,
        json_action_rule_upserted.modify_json,
        json_action_rule_upserted.priority,
        json_action_rule_upserted.description,
        CURRENT_TIMESTAMP,
        v_updated_by,
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP,
        json_action_rule_upserted.created_by,
        json_action_rule_upserted.provenance
    ) RETURNING json_action_rule.action_rule_id INTO v_return;

    -- Return a success message
    RETURN v_return;
EXCEPTION
   WHEN OTHERS THEN
        -- Capture exception details
        GET STACKED DIAGNOSTICS
            v_error_msg = MESSAGE_TEXT,
            v_sqlstate = RETURNED_SQLSTATE,
            v_pg_detail = PG_EXCEPTION_DETAIL,
            v_pg_hint = PG_EXCEPTION_HINT,
            v_pg_context = PG_EXCEPTION_CONTEXT;
        	v_error_type = 'SQL';

        RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
       
        -- Log the exception, reusing the previous exception ID if it exists
        PERFORM techbd_udi_ingress.register_issue(
            COALESCE(v_exception_id,NULL),
            'action_rule',
            v_error_msg,
            v_error_type,
            v_sqlstate,
            v_pg_detail,
            v_pg_hint,
            v_pg_context,
            v_created_by,
            v_provenance);

        RETURN NULL;
END;
$function$
;

/*====================================================================================================*/
 
DROP FUNCTION IF EXISTS techbd_udi_ingress.is_valid_jsonpath(TEXT);

CREATE OR REPLACE FUNCTION techbd_udi_ingress.is_valid_jsonpath(json_path TEXT)
RETURNS BOOLEAN AS $$
DECLARE 
	is_exists boolean := false;
BEGIN
    -- Attempt to apply the JSONPath to the dummy JSON
    is_exists := jsonb_path_exists('{}'::jsonb, json_path::jsonpath);
    RETURN TRUE;  -- If no error, the JSONPath is valid
EXCEPTION
    WHEN others THEN
    	RETURN FALSE;  -- If an error occurs, the JSONPath is invalid
END;
$$ LANGUAGE plpgsql;
/*====================================================================================================*/


DROP PROCEDURE IF EXISTS techbd_udi_ingress.insert_fhir_screening_patient(text,text,text,TIMESTAMPTZ,jsonb,text,text,jsonb);
DROP PROCEDURE IF EXISTS techbd_udi_ingress.insert_fhir_screening_patient(text,text,text,TIMESTAMPTZ,jsonb,text,text,jsonb,text);
CREATE OR REPLACE PROCEDURE techbd_udi_ingress.insert_fhir_screening_patient (
    IN hub_interaction_id TEXT,
    IN tenant_id TEXT,
    IN uri TEXT,
    IN created_at TIMESTAMPTZ,
    IN payload JSONB,
    IN created_by TEXT,
    IN provenance TEXT,
    IN elaboration JSONB,
    IN primary_org_id TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_exception_id 	                TEXT;
    v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  
BEGIN
    WITH filtered_data AS (
        SELECT 
                insert_fhir_screening_patient.hub_interaction_id AS hub_interaction_id,
                insert_fhir_screening_patient.tenant_id AS tenant_id,
                v_created_by,
                v_provenance,
                insert_fhir_screening_patient.elaboration AS elaboration,
                insert_fhir_screening_patient.payload ->> 'created_at' AS created_at,
                (entry.value -> 'resource') ->> 'id' AS patient_id,
                (entry.value -> 'resource') ->> 'resourceType' AS patient_resource_type,
                (((entry.value -> 'resource') -> 'name') -> 0) ->> 'text' AS full_name,
                (((entry.value -> 'resource') -> 'name') -> 0) ->> 'family' AS last_name,
                array_to_string(ARRAY(
                    SELECT jsonb_array_elements_text((((entry.value -> 'resource') -> 'name') -> 0) -> 'given'))
                , ' ') AS first_name,
                (entry.value -> 'resource') ->> 'gender' AS gender,
                (entry.value -> 'resource') ->> 'birthDate' AS birth_date,
                (((entry.value -> 'resource') -> 'address') -> 0) ->> 'text' AS address,
                (((entry.value -> 'resource') -> 'address') -> 0) ->> 'city' AS city,
                (((entry.value -> 'resource') -> 'address') -> 0) ->> 'state' AS state,
                (((entry.value -> 'resource') -> 'address') -> 0) ->> 'postalCode' AS postal_code,
                ((((((entry.value -> 'resource') -> 'communication') -> 0) -> 'language') -> 'coding') -> 0) ->> 'code' AS language,
                (((entry.value -> 'resource') -> 'identifier') -> 0) ->> 'value' AS medical_record_number,
                (((entry.value -> 'resource') -> 'identifier') -> 3) ->> 'value' AS social_security_number,
                array_to_string(
                    ARRAY(
                        SELECT (org_entry.value -> 'resource') ->> 'id'
                        FROM jsonb_array_elements(insert_fhir_screening_patient.payload -> 'entry') AS org_entry
                        WHERE (org_entry.value -> 'resource' ->> 'resourceType') = 'Organization'
                    ), ', '
                ) AS organization_ids 
        FROM LATERAL jsonb_array_elements(insert_fhir_screening_patient.payload -> 'entry') entry
        WHERE (entry.value -> 'resource') ->> 'resourceType' = 'Patient'
    )
    INSERT INTO techbd_udi_ingress.sat_interaction_fhir_screening_patient (
        sat_interaction_fhir_screening_patient_id,
        hub_interaction_id,
        qe_name,
        patient_mrn,
        patient_id,
        patient_type,
        patient_full_name,
        patient_first_name,
        patient_last_name,
        patient_gender,
        patient_birth_date,
        patient_address,
        patient_city,
        patient_state,
        patient_postal_code,
        patient_language,
        patient_ssn,
        org_id,
        elaboration,
        created_by,
        provenance,
        primary_org_id
    )
    SELECT gen_random_uuid()::TEXT,
        filtered_data.hub_interaction_id,
        filtered_data.tenant_id,
        filtered_data.medical_record_number,
        filtered_data.patient_id,
        filtered_data.patient_resource_type,
        filtered_data.full_name,
        filtered_data.first_name,
        filtered_data.last_name,
        filtered_data.gender,
        filtered_data.birth_date,
        filtered_data.address,
        filtered_data.city,
        filtered_data.state,
        filtered_data.postal_code,
        filtered_data.language,
        filtered_data.social_security_number,
        filtered_data.organization_ids,
        filtered_data.elaboration,
        filtered_data.v_created_by,
        filtered_data.v_provenance,
        primary_org_id
    FROM filtered_data;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    -- RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		insert_fhir_screening_patient.uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
END;         
$$;

DROP PROCEDURE IF EXISTS techbd_udi_ingress.insert_fhir_screening_organization(text,text,text,TIMESTAMPTZ,jsonb,text,text,jsonb);
DROP PROCEDURE IF EXISTS techbd_udi_ingress.insert_fhir_screening_organization(text,text,text,TIMESTAMPTZ,jsonb,text,text,jsonb,text);
CREATE OR REPLACE PROCEDURE techbd_udi_ingress.insert_fhir_screening_organization (
    IN hub_interaction_id TEXT,
    IN tenant_id TEXT,
    IN uri TEXT,
    IN created_at TIMESTAMPTZ,
    IN payload JSONB,
    IN created_by TEXT,
    IN provenance TEXT,
    IN elaboration JSONB
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_exception_id 	                TEXT;
    v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  
BEGIN
    WITH filtered_data AS (
        SELECT 
                insert_fhir_screening_organization.hub_interaction_id AS hub_interaction_id,
                insert_fhir_screening_organization.tenant_id AS tenant_id,
                v_created_by,
                v_provenance,
                insert_fhir_screening_organization.elaboration AS elaboration,
                insert_fhir_screening_organization.payload ->> 'created_at' AS created_at,
                (entry.value -> 'resource'::text) ->> 'id'::text AS org_id,
                (entry.value -> 'resource'::text) ->> 'resourceType'::text AS org_resource_type,
                (entry.value -> 'resource'::text) ->> 'name'::text AS org_name,
                (entry.value -> 'resource'::text) ->> 'active'::text AS org_active,
                (((entry.value -> 'resource'::text) -> 'address'::text) -> 0) ->> 'text'::text AS org_address,
                (((entry.value -> 'resource'::text) -> 'address'::text) -> 0) ->> 'city'::text AS org_city,
                (((entry.value -> 'resource'::text) -> 'address'::text) -> 0) ->> 'state'::text AS org_state,
                (((entry.value -> 'resource'::text) -> 'address'::text) -> 0) ->> 'postalCode'::text AS org_postal_code 
        FROM LATERAL jsonb_array_elements(insert_fhir_screening_organization.payload -> 'entry') entry
        WHERE (entry.value -> 'resource') ->> 'resourceType' = 'Organization'
    )
    INSERT INTO techbd_udi_ingress.sat_interaction_fhir_screening_organization (
        sat_interaction_fhir_screening_organization_id,
        hub_interaction_id,
        qe_name,
        org_id,
        org_type,
        org_name,
        org_active,
        org_address,
        org_city,
        org_state,
        org_postal_code,
        elaboration,
        created_by,
        provenance 
    )
    SELECT gen_random_uuid()::TEXT,
        filtered_data.hub_interaction_id,
        filtered_data.tenant_id,
        filtered_data.org_id,
        filtered_data.org_resource_type,
        filtered_data.org_name,
        filtered_data.org_active,
        filtered_data.org_address,
        filtered_data.org_city,
        filtered_data.org_state,
        filtered_data.org_postal_code,
        filtered_data.elaboration,
        filtered_data.v_created_by,
        filtered_data.v_provenance 
    FROM filtered_data;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    -- RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		insert_fhir_screening_organization.uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
END;         
$$;

/*******************************************************************************************************************************
Function for upserting HL7 interaction request data from a JSONB payload.

Parameters:
hub_interaction_id   - Unique identifier of the hub interaction (TEXT)
tenant_id            - Unique identifier of the tenant (TEXT)
uri                  - URI associated with the HL7 request (TEXT)
nature               - Nature of the interaction request (TEXT)
from_state           - The initial state of the interaction (TEXT)
to_state             - The final state of the interaction after processing (TEXT)
payload              - JSONB object containing the HL7 request data (JSONB), default is NULL
state_transition_reason - Reason for transitioning between states (TEXT), default is NULL
created_at           - Timestamp of when the record was created (TIMESTAMPTZ), defaults to CURRENT_TIMESTAMP if not provided
created_by           - Identifier of the user or system creating the record (TEXT), defaults to the current user if not provided
provenance           - Metadata providing the provenance or origin of the interaction (TEXT), defaults to 'unknown'
elaboration          - JSONB object containing additional details about the interaction (JSONB), default is NULL

Returns:
The function returns the generated UUID of the newly inserted record in the 'sat_interaction_hl7_request' table or NULL if the 
interaction is not valid or the payload is null.

Description:
This function inserts HL7 interaction request data into the 'sat_interaction_hl7_request' table. It ensures that the hub interaction 
exists in the 'hub_interaction' table and that the payload is not null. If both conditions are met, a new record is inserted, 
generating a UUID for the 'sat_interaction_hl7_request_id'. The function also handles exceptions, logging errors with the 
'register_issue' procedure if any SQL or runtime errors occur during the insert operation.
*******************************************************************************************************************************/
DROP FUNCTION IF EXISTS techbd_udi_ingress.sat_interaction_hl7_request_upserted(text, text, text, text, text, text, jsonb, text, timestamp with time zone, text, text, jsonb);
DROP FUNCTION IF EXISTS techbd_udi_ingress.sat_interaction_hl7_request_upserted(text, text, text, text, text, text, jsonb, text, timestamptz, text, text, jsonb, text, text, text);


CREATE OR REPLACE FUNCTION techbd_udi_ingress.sat_interaction_hl7_request_upserted(hub_interaction_id text, tenant_id text, uri text, nature text, from_state text, to_state text, payload jsonb DEFAULT NULL::jsonb, state_transition_reason text DEFAULT NULL::text, created_at timestamp with time zone DEFAULT NULL::timestamp with time zone, created_by text DEFAULT NULL::text, provenance text DEFAULT NULL::text, elaboration jsonb DEFAULT NULL::jsonb, client_ip_address text DEFAULT NULL::text, user_agent text DEFAULT NULL::TEXT, origin text DEFAULT NULL::TEXT)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    -- Declare variables to hold error and extracted data
	v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;   
    v_created_at 					TIMESTAMPTZ := COALESCE(created_at, CURRENT_TIMESTAMP);  -- Ensure created_at is not null
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  -- Set default provenance
    v_exception_id 					TEXT;
    
    -- Additional variables for extracting and holding data from the payload JSONB
    v_return 						TEXT 	:= NULL;

BEGIN	
	/* This function is designed to insert a new record into the sat_interaction_hl7_request table if it does not already exist. 
	 * It takes in various details about an HL7 interaction (such as hub_interaction_id, tenant_id, uri, payload, and others), 
	 * ensures that certain fields like created_at, created_by, and provenance have defaults, and inserts the data. The function 
	 * generates a unique UUID for the new record's primary key and returns it.
	 * If an error occurs during the insertion, the function captures detailed diagnostic information about the exception and 
	 * logs it using the register_issue function. It returns NULL if no new record is inserted or if an error occurs. 
	 * 'origin' can be 'http', 'sftp' etc.
	 */
	IF NOT EXISTS(SELECT 1 FROM techbd_udi_ingress.hub_interaction t
  		WHERE t.hub_interaction_id = sat_interaction_hl7_request_upserted.hub_interaction_id 
  		AND t."key" = sat_interaction_hl7_request_upserted.uri) THEN
  		RETURN NULL;	
  	END IF;
  
  	IF sat_interaction_hl7_request_upserted.payload IS NULL THEN
  		RETURN NULL;	
  	END IF;
  
  	-- The INSERT statement inserts a new record into the sat_interaction_hl7_request table, generating a UUID for the primary key.
    -- If the operation succeeds, the generated UUID is returned.
    INSERT INTO techbd_udi_ingress.sat_interaction_hl7_request (
        sat_interaction_hl7_request_id,
        hub_interaction_id,
        tenant_id,
        tenant_id_lower,
        uri,
        nature,
        payload,
        client_ip_address,
        user_agent,
        from_state,
        to_state,
        state_transition_reason,
        created_by,
        provenance,
        elaboration,
        origin
    )
    VALUES (
        gen_random_uuid()::TEXT,  -- Generate a unique UUID for the primary key
        hub_interaction_id,
        tenant_id,
        LOWER(tenant_id),  -- Store the tenant ID in lowercase for consistency
        uri,
        nature,
        payload,
        client_ip_address,
        user_agent,
        from_state,
        to_state,
        state_transition_reason,
        created_by,
        provenance,
        elaboration, 
        origin
    ) RETURNING sat_interaction_hl7_request_id INTO v_return;  -- Return the generated UUID

    RETURN v_return;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		sat_interaction_hl7_request_upserted.uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
		RETURN NULL;
END;
$function$
;

DROP VIEW IF EXISTS techbd_udi_ingress.fhir_tenant_stats_view  CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.fhir_tenant_stats_view  AS  
    SELECT 
        sihr.tenant_id_lower::text AS qe_name,  
        sihr.created_at::date,
        COUNT(CASE 
                  WHEN sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered' THEN 1 
                  ELSE NULL 
              END) AS qe_fhir_submission_count,        
        COUNT(CASE 
                  WHEN sihr.nature = 'Forwarded HTTP Response' THEN 1 
                  ELSE NULL 
              END) AS qe_fhir_pass_count,
        COUNT(CASE 
                  WHEN sihr.nature = 'Forwarded HTTP Response Error' THEN 1 
                  ELSE NULL 
              END) AS qe_fhir_fail_count
    FROM 
        techbd_udi_ingress.hub_interaction hintr
    JOIN 
        techbd_udi_ingress.sat_interaction_fhir_request sihr 
    ON 
        hintr.hub_interaction_id = sihr.hub_interaction_id
    WHERE 
        sihr.uri = ANY (ARRAY['/Bundle'::text, '/Bundle/'::text]) 
        AND sihr.tenant_id_lower::text IN ('healthelink', 'healtheconn', 'healthix', 'grrhio', 'hixny')
    AND sihr.created_at::date >= (CURRENT_DATE - INTERVAL '1 day')  -- Filter for last 1 day
GROUP BY 
    sihr.tenant_id_lower::text, sihr.created_at::date
ORDER BY 
    sihr.created_at::date DESC;



/****************************************************************************************
 * View for tracking recent FHIR submission statuses by organization, capturing success and failure rates.
 *
 * Purpose:
 * - Provides a summary of FHIR interactions for each organization within the past 7 days.
 * - Distinguishes successful submissions from failed ones to highlight potential issues in data processing.
 *
 * Columns:
 * - **organization_id**: Unique identifier of the organization.
 * - **tenant_id_lower**: Lowercase tenant ID for consistency and grouping.
 * - **qe_total_submissions**: Total count of interactions of type 'RequestResponseEncountered'.
 * - **success_submissions**: Number of successful 'Forwarded HTTP Response' submissions.
 * - **faield_submissions**: Number of failed 'Forwarded HTTP Response Error' submissions.
 * - **recently_created_at**: Timestamp of the most recent interaction for each organization.
 *
 * Filters:
 * - Includes only interactions with specific '/Bundle/' URIs.
 * - Considers data from the last 7 days, excluding interactions from unspecified ('N/A') tenants.
 *
 * Ordering:
 * - Results are ordered by **recently_created_at** in descending order, emphasizing the most recent submissions.
 ****************************************************************************************/


drop view if exists techbd_udi_ingress.fhir_scn_submission cascade;
create or replace view techbd_udi_ingress.fhir_scn_submission as  
 WITH submission_counts AS (
         SELECT sihr.organization_id AS organization_id,
            count(
                CASE
                    WHEN sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered'::text THEN 1
                    ELSE NULL::integer
                END) AS qe_total_submissions,
            count(
                CASE
                    WHEN sihr.nature = 'Forwarded HTTP Response'::text THEN 1
                    ELSE NULL::integer
                END) AS success_submissions,
            count(
                CASE
                    WHEN sihr.nature = 'Forwarded HTTP Response Error'::text THEN 1
                    ELSE NULL::integer
                END) AS faield_submissions,
            max(sihr.created_at) AS recently_created_at
           FROM techbd_udi_ingress.sat_interaction_fhir_request sihr
          WHERE (sihr.uri = ANY (ARRAY['/Bundle/'::text, '/Bundle'::text])) AND sihr.created_at >= (CURRENT_DATE - '7 days'::interval) AND sihr.tenant_id <> 'N/A'::text
          AND sihr.organization_id != ''
         GROUP BY sihr.organization_id
        )
 SELECT organization_id, 
    qe_total_submissions,
    success_submissions,
    faield_submissions,
    recently_created_at
   FROM submission_counts sc
  ORDER BY recently_created_at DESC;  


/****************************************************************************************
 * View for detailed tracking of recent FHIR submissions by organization and tenant.
 *
 * Purpose:
 * - Summarizes FHIR interaction data for each organization and tenant over the last 7 days.
 * - Distinguishes between total, successful, and failed submissions to identify issues in data processing.
 *
 * Columns:
 * - **organization_id**: Unique identifier of the organization.
 * - **qe_name**: Lowercased tenant ID, representing the tenant associated with the organization.
 * - **qe_total_submissions**: Count of all interactions marked as 'RequestResponseEncountered' for the tenant.
 * - **success_submissions**: Count of successfully forwarded submissions ('Forwarded HTTP Response').
 * - **faield_submissions**: Count of failed submissions ('Forwarded HTTP Response Error').
 * - **recently_created_at**: The timestamp of the latest interaction for the tenant within the last 7 days.
 *
 * Filters:
 * - Filters interactions that use specific '/Bundle/' URIs.
 * - Considers records from the past 7 days and excludes tenants marked as 'N/A'.
 *
 * Ordering:
 * - Results are ordered by **recently_created_at** in descending order, showing the most recent activities first.
 ****************************************************************************************/

drop view if exists techbd_udi_ingress.fhir_scn_submission_details cascade;
create or replace view techbd_udi_ingress.fhir_scn_submission_details as  
  with submission_counts as (
select
	sihr.organization_id as organization_id,
	sihr.tenant_id_lower as qe_name,
	count(
                case
                    when sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered'::text then 1
                    else null::integer
                end) as qe_total_submissions,
	count(
                case
                    when sihr.nature = 'Forwarded HTTP Response'::text then 1
                    else null::integer
                end) as success_submissions,
	count(
                case
                    when sihr.nature = 'Forwarded HTTP Response Error'::text then 1
                    else null::integer
                end) as faield_submissions,
	max(sihr.created_at) as recently_created_at
from
	techbd_udi_ingress.sat_interaction_fhir_request sihr
where
	(sihr.uri = any (array['/Bundle/'::text,
	'/Bundle'::text]))
	and sihr.created_at >= (CURRENT_DATE - '7 days'::interval)
	and sihr.tenant_id <> 'N/A'::text
    and sihr.organization_id != ''
group by
	sihr.organization_id,
	sihr.tenant_id_lower
        )
 select
	organization_id,
	qe_name,
	qe_total_submissions,
	success_submissions,
	faield_submissions,
	recently_created_at
from
	submission_counts sc
order by
	recently_created_at desc;
 

/****************************************************************************************
 * View: techbd_udi_ingress.missing_datalake_submission_details
 *
 * Purpose:
 * - Identifies FHIR submissions with interactions of type 'RequestResponseEncountered' 
 *   that are missing subsequent forwarding responses, specifically lacking entries in 
 *   'Forwarded HTTP Response' or 'Forwarded HTTP Response Error'.
 * - Intended to highlight submissions that may not have reached the datalake within 
 *   the last 7 days, potentially indicating processing or forwarding issues.
 *
 * Columns:
 * - **hub_interaction_id**: Unique identifier for each interaction, providing traceability 
 *   for each FHIR submission attempt.
 * - **sat_interaction_http_request_id**: Unique identifier specifically for the HTTP request 
 *   associated with the interaction, aiding in request-specific tracking.
 * - **qe_name**: Tenant name identifier, representing the organization or entity that submitted 
 *   the interaction, enabling tenant-level analysis.
 * - **created_at**: Timestamp of the interaction's creation, indicating when the initial 
 *   submission attempt occurred.
 *
 * Filters:
 * - Filters records to include only those interactions where the `nature` is 
 *   'RequestResponseEncountered'.
 * - Restricts to interactions involving URIs of type `/Bundle/` or `/Bundle` in the 
 *   past 7 days, excluding tenants labeled as 'N/A'.
 * - Uses `NOT EXISTS` to exclude any interaction that has subsequent entries in 
 *   'Forwarded HTTP Response' or 'Forwarded HTTP Response Error', thereby capturing 
 *   only those interactions without a successful or error response.
 *
 * Ordering:
 * - Results are ordered by `created_at` in descending order, prioritizing recent 
 *   interactions for quicker identification and action on current issues.
 ****************************************************************************************/



drop view if exists techbd_udi_ingress.missing_datalake_submission_details cascade;
create or replace view techbd_udi_ingress.missing_datalake_submission_details as
 select
	sihr.hub_interaction_id,
	sihr.sat_interaction_fhir_request_id as sat_interaction_http_request_id,
	sihr.tenant_id_lower as qe_name,
	sihr.created_at
from
	techbd_udi_ingress.sat_interaction_fhir_request sihr
where
	sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered'::text
	and (sihr.uri = any (array['/Bundle/',
	'/Bundle']))
	and sihr.created_at >= (CURRENT_DATE - '7 days'::interval)
	and not exists (
	select
		1
	from
		techbd_udi_ingress.sat_interaction_fhir_request sihr2
	where
		sihr2.hub_interaction_id = sihr.hub_interaction_id
		and sihr2.nature in ('Forwarded HTTP Response', 'Forwarded HTTP Response Error')
    )
order by
	sihr.created_at desc;



/****************************************************************************************
 * This view, `organization_interaction_summary`, provides a consolidated count of FHIR 
 * interactions for each organization, focusing on specific types of interactions:
 * 
 * - **count_screenings**: Aggregates the count of interactions categorized as "Screening." 
 *   This count includes records where `resource_type_set` contains "Consent."
 * 
 * - **count_referrals**: Aggregates the count of interactions categorized as "Referral." 
 *   This count includes records where `resource_type_set` contains either "ServiceRequest" 
 *   or "Task."
 * 
 * - **count_assessments**: Aggregates the count of interactions categorized as "Assessment." 
 *   Similar to screenings, this count includes records where `resource_type_set` contains "Consent."
 * 
 * The view is filtered to include only specific URIs (`/Bundle` or `/Bundle/`) and excludes records 
 * where `organization_id` is empty. Grouped by `organization_id` and `organization_name`, this view 
 * facilitates quick access to interaction summaries by organization, enabling efficient tracking and 
 * analysis of FHIR resources across different organizations.
 ****************************************************************************************/

DROP VIEW IF EXISTS techbd_udi_ingress.organization_interaction_summary CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.organization_interaction_summary AS 
SELECT 
    organization_id,
    organization_name,
    COUNT(CASE 
            WHEN resource_type_set LIKE '%Consent%' THEN 1 
         END) AS count_screenings,
    COUNT(CASE 
            WHEN resource_type_set LIKE '%ServiceRequest%' OR resource_type_set LIKE '%Task%' THEN 1 
         END) AS count_referrals,
    COUNT(CASE 
            WHEN resource_type_set LIKE '%Condition%' THEN 1 
         END) AS count_assessments
FROM techbd_udi_ingress.sat_interaction_fhir_request htt_req
WHERE  
  uri IN ('/Bundle', '/Bundle/')
and organization_id != ''
 and created_at  >= (CURRENT_DATE - '7 days'::interval)
GROUP BY 
    organization_id,
    organization_name;  


DROP FUNCTION IF EXISTS techbd_udi_ingress.sat_interaction_csv_request_upserted(text, text, text, text, text, bytea, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, jsonb, text, text, text, timestamptz, text, text, jsonb);
DROP FUNCTION IF EXISTS techbd_udi_ingress.sat_interaction_csv_request_upserted(text, text, text, text, text, bytea, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, text, jsonb, text, text, text, timestamptz, text, text, jsonb, text);
DROP FUNCTION IF EXISTS techbd_udi_ingress.sat_interaction_csv_request_upserted(text, text, text, text, text, bytea, text, text, text, text, text, text, text, text, text, text, jsonb, text, text, text, timestamptz, text, text, jsonb, text, text, text, text);


CREATE OR REPLACE FUNCTION techbd_udi_ingress.sat_interaction_csv_request_upserted(interaction_id text, uri text, nature text, tenant_id text DEFAULT NULL::text, csv_zip_file_name text DEFAULT NULL::text, csv_zip_file_content bytea DEFAULT NULL::bytea, group_id text DEFAULT NULL::text, status text DEFAULT NULL::text, csv_screening_observation_data_payload_text text DEFAULT NULL::text, csv_screening_profile_data_payload_text text DEFAULT NULL::text, csv_demographic_data_payload_text text DEFAULT NULL::text, csv_qe_admin_data_payload_text text DEFAULT NULL::text, csv_screening_observation_data_file_name text DEFAULT NULL::text, csv_screening_profile_data_file_name text DEFAULT NULL::text, csv_demographic_data_file_name text DEFAULT NULL::text, csv_qe_admin_data_file_name text DEFAULT NULL::text, validation_result_payload jsonb DEFAULT NULL::jsonb, from_state text DEFAULT NULL::text, to_state text DEFAULT NULL::text, state_transition_reason text DEFAULT NULL::text, created_at timestamp with time zone DEFAULT NULL::timestamp with time zone, created_by text DEFAULT NULL::text, provenance text DEFAULT NULL::text, elaboration jsonb DEFAULT NULL::jsonb, zip_file_hub_interaction_id text DEFAULT NULL::text, client_ip_address text DEFAULT NULL::text, user_agent text DEFAULT NULL::text, origin text DEFAULT NULL::text)

 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    -- Declare variables to hold error and extracted data
	v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;   
    v_created_at 					TIMESTAMPTZ := COALESCE(created_at, CURRENT_TIMESTAMP);  -- Ensure created_at is not null
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  -- Set default provenance
    v_exception_id 					TEXT;
    
    -- Additional variables for extracting and holding data from the payload JSONB
   	v_return 						TEXT 	:= NULL;
    v_elaboration 					JSONB 	:= NULL;
    v_diagnostic_id 				TEXT  	:= gen_random_uuid()::text;
    --lo_id 							OID;

BEGIN	
	IF NOT EXISTS(SELECT 1 FROM techbd_udi_ingress.hub_interaction t
  		WHERE t.hub_interaction_id = sat_interaction_csv_request_upserted.interaction_id 
  		AND t."key" = sat_interaction_csv_request_upserted.uri) THEN
  		RETURN NULL;	
  	END IF;

    IF nature = 'Update Zip File Payload' THEN /*Update the full payload*/
    	UPDATE techbd_udi_ingress.sat_interaction_zip_file_request
    		SET validation_result_payload = sat_interaction_csv_request_upserted.validation_result_payload
    		WHERE hub_interaction_id = sat_interaction_csv_request_upserted.interaction_id;
    	v_return := sat_interaction_csv_request_upserted.interaction_id;
    
    ELSIF nature = 'Original CSV Zip Archive' THEN 
    	/*lo_id := lo_create(0); -- Create a new large OBJECT
    	PERFORM lo_open(lo_id, 131072); -- Open the large object in write MODE
    	PERFORM lo_import('/path/to/example.zip', lo_id); -- Write file contents to the large OBJECT*/
    
    	-- The INSERT statement inserts a new record (insert the csv zip file) into the sat_interaction_zip_file_request table, generating a UUID for the primary key.
	    INSERT INTO techbd_udi_ingress.sat_interaction_zip_file_request (
	        sat_interaction_zip_file_request_id, hub_interaction_id, tenant_id, tenant_id_lower, uri, nature,
	        group_id, status, csv_zip_file_name, csv_zip_file_content,
			client_ip_address, user_agent,
			elaboration, created_at, created_by, provenance, validation_result_payload, origin
	    )
	    VALUES (
	        gen_random_uuid()::TEXT,  -- Generate a unique UUID for the primary key
	        interaction_id,
	        tenant_id, 
	        LOWER(tenant_id), 
	        uri, 
	        nature,
	        group_id, 
	        status, 
	        csv_zip_file_name,
	        csv_zip_file_content, 
	        --lo_id, -- Insert the reference (OID) into the table
			client_ip_address, user_agent,
			NULL, v_created_at, v_created_by, v_provenance, 
			sat_interaction_csv_request_upserted.validation_result_payload, 
			sat_interaction_csv_request_upserted.origin
	    ) RETURNING sat_interaction_zip_file_request_id INTO v_return;  -- Return the generated UUID
	    
	    /*---register diagnostic log---*/
	  	v_elaboration := jsonb_build_object(
	 						'interaction_id', interaction_id,
	 						'interaction_key', uri,
	 						'nature', nature,
	 						'zip_file_name', csv_zip_file_name,
	 						'from_state', from_state,
	 						'to_state', to_state,
	 						'step', '- Insert into sat_interaction_zip_file_request'
	 						);
	 	CALL techbd_udi_ingress.register_diagnostic_log(v_diagnostic_id, uri, created_by, provenance, 'info'::text, 
																'Insert into sat_interaction_zip_file_request'::text, current_user, 'success'::text, NULL::text, 0, v_elaboration);
	  	/*------------------------------*/
    ELSE 
  	    -- The INSERT statement inserts a new record into the sat_interaction_flat_file_csv_request table, generating a UUID for the primary key.
	    INSERT INTO techbd_udi_ingress.sat_interaction_flat_file_csv_request (
	        sat_interaction_flat_file_csv_request_id, hub_interaction_id, tenant_id, tenant_id_lower, uri, nature,
	        group_id, status, validation_result_payload, 
			screening_observation_data_payload_text, screening_profile_data_payload_text, demographic_data_payload_text, qe_admin_data_payload_text, 
			screening_observation_data_file_name, screening_profile_data_file_name, demographic_data_file_name, qe_admin_data_file_name,
			client_ip_address, user_agent,
			from_state, to_state, state_transition_reason,
			elaboration, created_at, created_by, provenance,
			zip_file_hub_interaction_id
	    )
	    VALUES (
	        gen_random_uuid()::TEXT,  -- Generate a unique UUID for the primary key
	        interaction_id,
	        tenant_id, 
	        LOWER(tenant_id), 
	        uri, 
	        nature,
	        group_id, 
	        status, 
	        validation_result_payload,
	        csv_screening_observation_data_payload_text, csv_screening_profile_data_payload_text, csv_demographic_data_payload_text, csv_qe_admin_data_payload_text, 
			csv_screening_observation_data_file_name, csv_screening_profile_data_file_name, csv_demographic_data_file_name, csv_qe_admin_data_file_name,
			client_ip_address, user_agent,
			from_state, 
			to_state, 
			state_transition_reason,
			NULL, v_created_at, v_created_by, v_provenance,
			zip_file_hub_interaction_id
	    ) RETURNING sat_interaction_flat_file_csv_request_id INTO v_return;  -- Return the generated UUID
	    
	    /*---register diagnostic log---*/
	  	v_elaboration := jsonb_build_object(
	 						'interaction_id', interaction_id,
	 						'interaction_key', uri,
	 						'nature', nature,
	 						'group_id', group_id,
	 						'from_state', from_state,
	 						'to_state', to_state,
	 						'step', '- Insert into sat_interaction_flat_file_csv_request'
	 						);
	 	CALL techbd_udi_ingress.register_diagnostic_log(v_diagnostic_id, uri, created_by, provenance, 'info'::text, 
																'Insert into sat_interaction_flat_file_csv_request'::text, current_user, 'success'::text, NULL::text, 0, v_elaboration);
	  	/*------------------------------*/
    END IF;
    
    RETURN v_return;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
		v_elaboration := jsonb_build_object(
         						'interaction_id', interaction_id,
         						'interaction_key', uri,
         						'validation_result_payload', validation_result_payload,
         						'group_id', group_id,
         						'nature', nature,
         						'from_state', from_state,
         						'to_state', to_state,
         						'file_name', csv_zip_file_name
         						);       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance, v_elaboration);
		RETURN NULL;
END;
$function$
;


DROP FUNCTION IF EXISTS techbd_udi_ingress.get_fhir_scn_submission(DATE, DATE);
CREATE OR REPLACE FUNCTION techbd_udi_ingress.get_fhir_scn_submission(
    start_date DATE,
    end_date DATE
)
RETURNS TABLE (
    organization_id TEXT,
    qe_total_submissions INTEGER,
    success_submissions INTEGER,
    failed_submissions INTEGER,
    recently_created_at TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    WITH submission_counts AS (
        SELECT 
            sihr.organization_id,
            count(
                CASE 
                    WHEN sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered' THEN 1 
                    ELSE NULL 
                END
            )::INTEGER AS qe_total_submissions,
            count(
                CASE 
                    WHEN sihr.nature = 'Forwarded HTTP Response' THEN 1 
                    ELSE NULL 
                END
            )::INTEGER AS success_submissions,
            count(
                CASE 
                    WHEN sihr.nature = 'Forwarded HTTP Response Error' THEN 1 
                    ELSE NULL 
                END
            )::INTEGER AS failed_submissions,
            max(sihr.created_at)::TIMESTAMP AS recently_created_at
        FROM techbd_udi_ingress.sat_interaction_fhir_request sihr
        WHERE 
            sihr.uri = ANY (ARRAY['/Bundle/', '/Bundle']) 
            AND sihr.created_at BETWEEN start_date AND end_date
            AND sihr.tenant_id <> 'N/A' 
            AND sihr.organization_id <> ''
        GROUP BY sihr.organization_id
    )
    SELECT 
        submission_counts.organization_id,
        submission_counts.qe_total_submissions,
        submission_counts.success_submissions,
        submission_counts.failed_submissions,
        submission_counts.recently_created_at
    FROM submission_counts
    ORDER BY submission_counts.recently_created_at DESC;
END;
$$ LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS techbd_udi_ingress.get_fhir_needs_attention(date, date);
CREATE OR REPLACE FUNCTION techbd_udi_ingress.get_fhir_needs_attention(start_date DATE, end_date DATE)
RETURNS TABLE (
    qe_name TEXT,
    qe_total_submissions BIGINT,
    shinny_datalake_submissions BIGINT,
    shinny_datalake_submissions_failed BIGINT,
    recently_created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    WITH submission_counts AS (
        SELECT 
            sihr.tenant_id_lower AS qe_name,
            count(
                CASE
                    WHEN sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered' THEN 1
                END) AS qe_total_submissions,
            count(
                CASE
                    WHEN sihr.nature = 'Forwarded HTTP Response' THEN 1
                END) AS shinny_datalake_submissions,
            count(
                CASE
                    WHEN sihr.nature = 'Forwarded HTTP Response Error' THEN 1
                END) AS shinny_datalake_submissions_failed,
            max(sihr.created_at) AS recently_created_at
        FROM techbd_udi_ingress.sat_interaction_fhir_request sihr
        WHERE 
            sihr.uri = ANY (ARRAY['/Bundle/', '/Bundle'])
            AND sihr.created_at >= TO_TIMESTAMP(start_date::text, 'YYYY-MM-DD') 
            AND sihr.created_at < TO_TIMESTAMP(end_date::text, 'YYYY-MM-DD') + INTERVAL '1 day'
            AND sihr.tenant_id <> 'N/A'
        GROUP BY sihr.tenant_id_lower
    )
    SELECT 
        submission_counts.qe_name,
        submission_counts.qe_total_submissions,
        submission_counts.shinny_datalake_submissions,
        submission_counts.shinny_datalake_submissions_failed,
        submission_counts.recently_created_at
    FROM submission_counts
    ORDER BY submission_counts.recently_created_at DESC;
END;
$$ LANGUAGE plpgsql;

DROP FUNCTION if exists techbd_udi_ingress.get_interaction_http_request();
CREATE OR REPLACE FUNCTION techbd_udi_ingress.get_interaction_http_request()
RETURNS TABLE (
    interaction_id UUID,
    uri TEXT,
    interaction_created_at TIMESTAMPTZ,
    interaction_created_by TEXT,
    interaction_provenance TEXT,
    sat_interaction_http_request_id UUID,
    nature TEXT,
    tenant_id TEXT,
    user_agent TEXT,
    client_ip_address TEXT,
    content_type TEXT,
    payload JSONB,
    elaboration TEXT,
    from_state TEXT,
    to_state TEXT,
    state_transition_reason TEXT,
    request_created_at TIMESTAMPTZ,
    request_created_by TEXT,
    request_provenance TEXT,
    issues_count INTEGER,
    resource_types TEXT,
    start_time TIMESTAMPTZ,
    finish_time TIMESTAMPTZ,
    duration_millisecs NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        combined_query.interaction_id::UUID,
        combined_query.uri::TEXT,
        combined_query.interaction_created_at::TIMESTAMPTZ,
        combined_query.interaction_created_by::TEXT,
        combined_query.interaction_provenance::TEXT,
        combined_query.sat_interaction_http_request_id::UUID,
        combined_query.nature::TEXT,
        combined_query.tenant_id::TEXT,
        combined_query.user_agent::TEXT,
        combined_query.client_ip_address::TEXT,
        combined_query.content_type::TEXT,
        combined_query.payload::JSONB,
        combined_query.elaboration::TEXT,
        combined_query.from_state::TEXT,
        combined_query.to_state::TEXT,
        combined_query.state_transition_reason::TEXT,
        combined_query.request_created_at::TIMESTAMPTZ,
        combined_query.request_created_by::TEXT,
        combined_query.request_provenance::TEXT,
        combined_query.issues_count::INTEGER,
        combined_query.resource_types::TEXT,
        combined_query.start_time::TIMESTAMPTZ,
        combined_query.finish_time::TIMESTAMPTZ,
        combined_query.duration_millisecs::NUMERIC
    FROM (
        SELECT 
            htt_req.hub_interaction_id AS interaction_id,
            htt_req.uri,
            htt_req.created_at AS interaction_created_at,
            htt_req.created_by AS interaction_created_by,
            htt_req.provenance AS interaction_provenance,
            htt_req.sat_interaction_fhir_request_id AS sat_interaction_http_request_id,
            htt_req.nature,
            htt_req.tenant_id,
            htt_req.user_agent,
            htt_req.client_ip_address,
            'application/json'::text AS content_type,
            htt_req.payload,
            htt_req.elaboration,
            htt_req.from_state,
            htt_req.to_state,
            htt_req.state_transition_reason,
            htt_req.created_at AS request_created_at,
            htt_req.created_by AS request_created_by,
            htt_req.provenance AS request_provenance,
            htt_req.issues_count,
            htt_req.resource_type_set AS resource_types,
            htt_req.interaction_start_time AS start_time,
            htt_req.interaction_end_time AS finish_time,
            EXTRACT(epoch FROM htt_req.interaction_end_time::timestamp without time zone - htt_req.interaction_start_time::timestamp without time zone) * 1000::numeric AS duration_millisecs
        FROM techbd_udi_ingress.sat_interaction_fhir_request htt_req
        
        UNION ALL
        
        SELECT 
            user_req.hub_interaction_id AS interaction_id,
            user_req.uri,
            user_req.created_at AS interaction_created_at,
            user_req.created_by AS interaction_created_by,
            user_req.provenance AS interaction_provenance,
            user_req.sat_interaction_user_id AS sat_interaction_http_request_id,
            user_req.nature,
            user_req.tenant_id,
            user_req.user_agent,
            user_req.client_ip_address,
            'application/json'::text AS content_type,
            NULL::jsonb AS payload,
            user_req.elaboration,
            NULL::text AS from_state,
            NULL::text AS to_state,
            NULL::text AS state_transition_reason,
            user_req.created_at AS request_created_at,
            user_req.created_by AS request_created_by,
            user_req.provenance AS request_provenance,
            NULL::integer AS issues_count,
            NULL::text AS resource_types,
            user_req.interaction_start_time AS start_time,
            user_req.interaction_end_time AS finish_time,
            EXTRACT(epoch FROM user_req.interaction_end_time::timestamp without time zone - user_req.interaction_start_time::timestamp without time zone) * 1000::numeric AS duration_millisecs
        FROM techbd_udi_ingress.sat_interaction_user user_req
        WHERE user_req.uri !~~* '%/Bundle%'::text AND user_req.uri !~~* '%/Hl7/v2%'::text
    ) combined_query
    ORDER BY combined_query.interaction_created_at DESC;
END;
$$ LANGUAGE plpgsql;

DROP FUNCTION if exists techbd_udi_ingress.get_fhir_needs_attention_details(text, date, date);
CREATE OR REPLACE FUNCTION techbd_udi_ingress.get_fhir_needs_attention_details(
    tenant_id TEXT,
    start_date DATE,
    end_date DATE
)
RETURNS TABLE (
    hub_interaction_id TEXT,
    sat_interaction_http_request_id TEXT,
    qe_name TEXT,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY EXECUTE format(
        'SELECT 
            sihr.hub_interaction_id,
            sihr.sat_interaction_fhir_request_id AS sat_interaction_http_request_id,
            sihr.tenant_id_lower AS qe_name,
            sihr.created_at
         FROM 
            techbd_udi_ingress.sat_interaction_fhir_request sihr
         WHERE 
            sihr.nature = ''Forwarded HTTP Response Error''
            AND sihr.uri = ANY (ARRAY[''/Bundle/'', ''/Bundle''])
            AND sihr.created_at >= TO_TIMESTAMP($1::text, ''YYYY-MM-DD'') 
	        AND sihr.created_at < TO_TIMESTAMP($2::text, ''YYYY-MM-DD'') + INTERVAL ''1 day''
            AND sihr.tenant_id_lower = $3
         ORDER BY sihr.created_at DESC'
    )
    USING start_date, end_date, tenant_id;
END;
$$ LANGUAGE plpgsql;

DROP FUNCTION if exists techbd_udi_ingress.get_missing_datalake_submission_details(text,date, date);
CREATE OR REPLACE FUNCTION techbd_udi_ingress.get_missing_datalake_submission_details(
    tenant_id_param TEXT,
    start_date_param DATE,
    end_date_param DATE
)
RETURNS TABLE (
    hub_interaction_id text,
    sat_interaction_http_request_id text,
    qe_name TEXT,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sihr.hub_interaction_id,
        sihr.sat_interaction_fhir_request_id AS sat_interaction_http_request_id,
        sihr.tenant_id_lower AS qe_name,
        sihr.created_at
    FROM techbd_udi_ingress.sat_interaction_fhir_request sihr
    WHERE 
        sihr.tenant_id_lower = tenant_id_param
        AND sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered'
        AND sihr.uri = ANY (ARRAY['/Bundle/', '/Bundle'])
        AND sihr.created_at >= TO_TIMESTAMP(start_date_param::text, 'YYYY-MM-DD') 
        AND sihr.created_at < TO_TIMESTAMP(end_date_param::text, 'YYYY-MM-DD') + INTERVAL '1 day'
        AND NOT EXISTS (
            SELECT 1
            FROM techbd_udi_ingress.sat_interaction_fhir_request sihr2
            WHERE sihr2.hub_interaction_id = sihr.hub_interaction_id
              AND sihr2.nature = ANY (ARRAY['Forwarded HTTP Response', 'Forwarded HTTP Response Error'])
        )
    ORDER BY sihr.created_at DESC;
END;
$$ LANGUAGE plpgsql;

DROP FUNCTION if exists techbd_udi_ingress.get_fhir_scn_submission_details(text, date, date);
CREATE OR REPLACE FUNCTION techbd_udi_ingress.get_fhir_scn_submission_details(
    organization_id_param TEXT,
    start_date DATE,
    end_date DATE
)
RETURNS TABLE (
    organization_id TEXT,
    qe_name TEXT,
    qe_total_submissions BIGINT,
    success_submissions BIGINT,
    faield_submissions BIGINT,
    recently_created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY EXECUTE format(
        'WITH submission_counts AS (
             SELECT 
                sihr.organization_id,
                sihr.tenant_id_lower AS qe_name,
                count(CASE WHEN sihr.nature = ''org.techbd.service.http.Interactions$RequestResponseEncountered'' THEN 1 ELSE NULL END) AS qe_total_submissions,
                count(CASE WHEN sihr.nature = ''Forwarded HTTP Response'' THEN 1 ELSE NULL END) AS success_submissions,
                count(CASE WHEN sihr.nature = ''Forwarded HTTP Response Error'' THEN 1 ELSE NULL END) AS faield_submissions,
                max(sihr.created_at) AS recently_created_at
             FROM 
                techbd_udi_ingress.sat_interaction_fhir_request sihr
             WHERE 
                sihr.uri = ANY (ARRAY[''/Bundle/'', ''/Bundle''])
                AND sihr.created_at BETWEEN $2 AND $3  -- Parameters shifted by one
                AND sihr.tenant_id <> ''N/A''
                AND sihr.organization_id = $1  -- Organization ID filter
             GROUP BY 
                sihr.organization_id, sihr.tenant_id_lower
        )
        SELECT 
            organization_id,
            qe_name,
            qe_total_submissions,
            success_submissions,
            faield_submissions,
            recently_created_at
        FROM 
            submission_counts sc
        ORDER BY 
            recently_created_at DESC'
    ) USING organization_id_param, start_date, end_date;  -- Pass all parameters
END;
$$ LANGUAGE plpgsql;

DROP VIEW IF EXISTS techbd_udi_ingress.interaction_csv_http_stat CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_csv_http_stat AS
WITH fhir_summary AS (
    SELECT
        source_hub_interaction_id,
        SUM(CASE WHEN nature = 'Forwarded HTTP Response' AND source_type = 'CSV' THEN 1 ELSE 0 END) AS fhir_count_success,
        SUM(CASE WHEN nature = 'Forwarded HTTP Response Error' AND source_type = 'CSV' THEN 1 ELSE 0 END) AS fhir_count_failed,
        COUNT(hub_interaction_id) AS fhir_count
    FROM techbd_udi_ingress.sat_interaction_fhir_request
    WHERE nature IN ('Forwarded HTTP Response', 'Forwarded HTTP Response Error')
      AND source_type = 'CSV'
    GROUP BY source_hub_interaction_id
)

SELECT 
    sizfr.tenant_id_lower,
    sizfr.tenant_id,
    sizfr.hub_interaction_id,
    sizfr.created_at,
    sizfr.uri,
    SUM(CASE WHEN siffcr.demographic_data_file_name IS NOT NULL THEN 1 ELSE 0 END) +
    SUM(CASE WHEN siffcr.qe_admin_data_file_name IS NOT NULL THEN 1 ELSE 0 END) +
    SUM(CASE WHEN siffcr.screening_observation_data_file_name IS NOT NULL THEN 1 ELSE 0 END) +
    SUM(CASE WHEN siffcr.screening_profile_data_file_name IS NOT NULL THEN 1 ELSE 0 END) AS file_count,
    COALESCE(fhir_summary.fhir_count, 0) AS fhir_count,
    COALESCE(fhir_summary.fhir_count_success, 0) AS fhir_count_success,
    COALESCE(fhir_summary.fhir_count_failed, 0) AS fhir_count_failed
FROM
    techbd_udi_ingress.sat_interaction_zip_file_request sizfr
JOIN
    techbd_udi_ingress.sat_interaction_flat_file_csv_request siffcr
    ON sizfr.hub_interaction_id = siffcr.zip_file_hub_interaction_id 
    AND siffcr.nature = 'Original Flat File CSV'
LEFT JOIN
    fhir_summary
    ON sizfr.hub_interaction_id = fhir_summary.source_hub_interaction_id
GROUP BY 
    sizfr.hub_interaction_id,
    sizfr.created_at,
    sizfr.uri,
    sizfr.tenant_id_lower,
    sizfr.tenant_id,
    fhir_summary.fhir_count,
    fhir_summary.fhir_count_success,
    fhir_summary.fhir_count_failed
ORDER BY 
    sizfr.created_at DESC;


/*******************************************************************************************
This view takes data from sat_interaction_fhir_request table to 
provide a consolidated view of HTTP FHIR requests via CSV, including resource types, 
interaction details, request attributes, and validation issues.
******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_csv_http_fhir_request CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_csv_http_fhir_request
AS SELECT hub_interaction_id AS interaction_id,
    uri,
    bundle_id,
    created_at AS interaction_created_at,
    created_by AS interaction_created_by,
    provenance AS interaction_provenance,
    sat_interaction_fhir_request_id AS sat_interaction_http_request_id,
    nature,
    tenant_id,
    user_agent,
    client_ip_address,
    'application/json'::text AS content_type,
    payload,
    elaboration,
    from_state,
    to_state,
    state_transition_reason,
    created_at AS request_created_at,
    created_by AS request_created_by,
    provenance AS request_provenance,
    issues_count,
    resource_type_set AS resource_types,
    interaction_start_time::text AS start_time,
    interaction_end_time::text AS finish_time,
    EXTRACT(epoch FROM interaction_end_time::timestamp without time zone - interaction_start_time::timestamp without time zone) * 1000::numeric AS duration_millisecs,
    patient_id,
    patient_mrn,
    patient_mrn_source_system,
    organization_id,
    organization_name,
    concat_ws('-'::text, tenant_id, organization_id, patient_mrn) AS source_mrn,
    CASE
        WHEN 'ServiceRequest' = ANY(string_to_array(resource_type_set, ', ')) OR 'Task' = ANY(string_to_array(resource_type_set, ', '))
            THEN 'Referral'
        WHEN 'Consent' = ANY(string_to_array(resource_type_set, ', '))
            THEN 'Screening'
        WHEN 'Condition' = ANY(string_to_array(resource_type_set, ', '))
            THEN 'Assessment'
        ELSE NULL
    END AS bundle_resource_type,   
    source_hub_interaction_id    
   FROM techbd_udi_ingress.sat_interaction_fhir_request htt_req
   WHERE source_type='CSV'; 


/*******************************************************************************************
  This view provides a consolidated view of failed CSV HTTP requests and associated interactions.
******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_csv_http_request_forward_failure;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_csv_http_request_forward_failure
AS SELECT sat_interaction_fhir_request_id,
    hub_interaction_id AS interaction_id,
    tenant_id,
    uri,
    bundle_id,
    nature,
    created_at AS interaction_created_at,
    created_by AS interaction_created_by,
    provenance AS interaction_provenance,
    client_ip_address,
    user_agent,
    from_state,
    to_state,
    outbound_http_message,
    error_message AS error,
    issues_count,
    resource_type_set AS resource_types,
    patient_id,
    payload,
    patient_mrn,
    concat_ws('-'::text, tenant_id, organization_id, patient_mrn) AS source_mrn,
    (SELECT string_agg(concat_ws(': ', key, COALESCE(value, 'NULL')), ', ') FROM jsonb_each_text((payload->>'responseBody')::jsonb) AS json_data(key, value)) AS response_body_details,  
    source_hub_interaction_id
   FROM techbd_udi_ingress.sat_interaction_fhir_request intr_hreq
WHERE to_state = 'FAIL'::text AND source_type = 'CSV';