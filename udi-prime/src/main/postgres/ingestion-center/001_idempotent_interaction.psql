 
/****************************************************************************************
 * Comprehensive view of HTTP interactions and their associated requests.
 * 
 * This view joins the hub_interaction table with the sat_interaction_http_request table
 * to provide a detailed record of each interaction and its related HTTP requests.
 * 
 * Purpose:
 * - To offer a business-level overview of HTTP interactions processed by the system.
 * - Each request is typically represented by a single row. However, in scenarios where 
 *   completing a request involves multiple asynchronous HTTP requests, multiple rows 
 *   might be associated with a single interaction.
 * - This is particularly useful for understanding complex interactions that involve 
 *   several steps or dependent requests to fulfill a single client request.
 ****************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_request CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_request
AS 
SELECT interaction_id,
    uri,
    interaction_created_at,
    interaction_created_by,
    interaction_provenance,
    sat_interaction_http_request_id,
    nature,
    tenant_id,
    user_agent,
    client_ip_address,
    content_type,
    payload,
    elaboration,
    from_state,
    to_state,
    state_transition_reason,
    request_created_at,
    request_created_by,
    request_provenance,
    issues_count,
    resource_types,
    start_time,
    finish_time,
    duration_millisecs
   FROM ( SELECT htt_req.hub_interaction_id AS interaction_id,
            htt_req.uri,
            htt_req.created_at AS interaction_created_at,
            htt_req.created_by AS interaction_created_by,
            htt_req.provenance AS interaction_provenance,
            htt_req.sat_interaction_fhir_request_id AS sat_interaction_http_request_id,
            htt_req.nature,
            htt_req.tenant_id,
            htt_req.user_agent,
            htt_req.client_ip_address,
            'application/json'::text AS content_type,
            htt_req.payload,
            htt_req.elaboration,
            htt_req.from_state,
            htt_req.to_state,
            htt_req.state_transition_reason,
            htt_req.created_at AS request_created_at,
            htt_req.created_by AS request_created_by,
            htt_req.provenance AS request_provenance,
            htt_req.issues_count,
            htt_req.resource_type_set AS resource_types,
            htt_req.interaction_start_time AS start_time,
            htt_req.interaction_end_time AS finish_time,
            EXTRACT(epoch FROM htt_req.interaction_end_time::timestamp without time zone - htt_req.interaction_start_time::timestamp without time zone) * 1000::numeric AS duration_millisecs
           FROM techbd_udi_ingress.sat_interaction_fhir_request htt_req
        UNION ALL
         SELECT user_req.hub_interaction_id AS interaction_id,
            user_req.uri,
            user_req.created_at AS interaction_created_at,
            user_req.created_by AS interaction_created_by,
            user_req.provenance AS interaction_provenance,
            user_req.sat_interaction_user_id AS sat_interaction_http_request_id,
            user_req.nature,
            user_req.tenant_id,
            user_req.user_agent,
            user_req.client_ip_address,
            'application/json'::text AS content_type,
            NULL::unknown AS payload,
            user_req.elaboration,
            NULL::unknown AS from_state,
            NULL::unknown AS to_state,
            NULL::unknown AS state_transition_reason,
            user_req.created_at AS request_created_at,
            user_req.created_by AS request_created_by,
            user_req.provenance AS request_provenance,
            NULL::unknown AS issue_count,
            NULL::unknown AS resource_types,
            user_req.interaction_start_time AS start_time,
            user_req.interaction_end_time AS finish_time,
            EXTRACT(epoch FROM user_req.interaction_end_time::timestamp without time zone - user_req.interaction_start_time::timestamp without time zone) * 1000::numeric AS duration_millisecs
           FROM techbd_udi_ingress.sat_interaction_user user_req where user_req.uri not ilike '%/Bundle%' and user_req.uri not ilike '%/Hl7/v2%') combined_query
  ORDER BY interaction_created_at DESC;

/*******************************************************************************************
This view combines data from hub_interaction and sat_interaction_http_request tables to 
provide a consolidated view of HTTP FHIR requests, including resource types, 
interaction details, request attributes, and validation issues.
******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_fhir_request CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_fhir_request
AS SELECT hub_interaction_id AS interaction_id,
    uri,
    created_at AS interaction_created_at,
    created_by AS interaction_created_by,
    provenance AS interaction_provenance,
    sat_interaction_fhir_request_id AS sat_interaction_http_request_id,
    nature,
    tenant_id,
    user_agent,
    client_ip_address,
    'application/json'::text AS content_type,
    payload,
    elaboration,
    from_state,
    to_state,
    state_transition_reason,
    created_at AS request_created_at,
    created_by AS request_created_by,
    provenance AS request_provenance,
    issues_count,
    resource_type_set AS resource_types,
    interaction_start_time::text AS start_time,
    interaction_end_time::text AS finish_time,
    EXTRACT(epoch FROM interaction_end_time::timestamp without time zone - interaction_start_time::timestamp without time zone) * 1000::numeric AS duration_millisecs,
    patient_id,
    patient_mrn,
    organization_id,
    organization_name,
    concat_ws('-'::text, tenant_id, organization_id, patient_mrn) AS source_mrn
   FROM techbd_udi_ingress.sat_interaction_fhir_request htt_req
   WHERE uri != '/api/expect/fhir/bundle'; 


-- techbd_udi_ingress.interaction_http_request_payload source
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_request_payload;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_request_payload
AS SELECT sat_interaction_http_request_id,
    hub_interaction_id as interaction_id,
    payload
   FROM techbd_udi_ingress.sat_interaction_http_request sihr;   

/*******************************************************************************************
This materialized view is to extract observability metrics from interaction_http_request
******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_observe CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_observe
AS 
SELECT 	intr_observe.interaction_id,
		intr_observe.uri,
		intr_observe.start_time,
		intr_observe.finish_time,   
		EXTRACT(epoch FROM intr_observe.finish_time::timestamp without time zone - intr_observe.start_time::timestamp without time zone) * 1000::numeric AS duration_millisecs,
		intr_observe.sat_interaction_http_request_id AS interaction_http_request_id
FROM techbd_udi_ingress.interaction_http_request intr_observe
WHERE intr_observe.start_time IS NOT NULL AND intr_observe.finish_time IS NOT null
 ORDER BY duration_millisecs DESC;

/*****************************************
This view extracts diagnostic information from JSON payloads of HTTP requests stored in 
'sat_interaction_http_request'. It transforms and presents fields such as 'tenant_id', 'uri', 
'session_id', 'severity', 'message', 'line', 'column', 'diagnostics', 'encounteredAt', 
and 'elaboration' for further analysis or reporting.
******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.fhir_session_diagnostics CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.fhir_session_diagnostics
AS SELECT tenant_id,
    uri,
    session_id,
    severity,
    message,
    line,
    "column",
    diagnostics,
    to_timestamp(intr_diagno.encountered_at::double precision) AS encounteredat, 
    elaboration
   FROM techbd_udi_ingress.sat_interaction_fhir_session_diagnostic intr_diagno;

/*******************************************************************************************************************************
 * Function to register an HTTP interaction request, handling potential unique constraint violations
 * and logging exceptions when necessary.
 *
 * Parameters:
 * @param interaction_id TEXT - The unique identifier of the interaction.
 * @param interaction_key TEXT - The key to identify the interaction.
 * @param payload JSONB (nullable) - The JSON payload associated with the interaction. Default is NULL.
 * @param payload_text TEXT (nullable) - The text version of the payload. Default is NULL.
 * @param rule_namespace TEXT (nullable) - The namespace for JSON action rules. Default is NULL.
 * @param elaboration JSONB (nullable) - Additional JSON data to elaborate on the interaction. Default is NULL.
 * @param nature JSONB (nullable) - Describes the nature of the HTTP interaction, including tenant details. Default is NULL.
 * @param content_type TEXT (nullable) - The content type of the HTTP interaction. Default is NULL.
 * @param from_state TEXT (nullable) - The state before the HTTP interaction. Default is NULL.
 * @param to_state TEXT (nullable) - The state after the HTTP interaction. Default is NULL.
 * @param state_transition_reason TEXT (nullable) - The reason for the state transition. Default is NULL.
 * @param user_id TEXT (nullable) - The ID of the user involved in the interaction. Default is NULL.
 * @param user_name TEXT (nullable) - The name of the user involved in the interaction. Default is NULL.
 * @param user_session TEXT (nullable) - The session ID of the user involved in the interaction. Default is NULL.
 * @param user_role TEXT (nullable) - The role of the user involved in the interaction. Default is NULL.
 * @param created_at TIMESTAMPTZ (nullable) - The timestamp of when the interaction was created. Defaults to the current timestamp.
 * @param created_by TEXT (nullable) - The user who created the interaction. Defaults to the current user.
 * @param provenance TEXT (nullable) - Metadata providing the provenance or origin of the interaction. Defaults to 'unknown'.
 * @param hub_upsert_behavior BOOLEAN - Controls whether unique constraint violations should be treated as an error (FALSE) or ignored (TRUE). Defaults to TRUE.
 *
 * Returns:
 * @return JSONB - The JSON result of the operation or NULL if the interaction registration fails.
 *
 * Description:
 * This function handles the upserting (inserting or updating) of an HTTP interaction request into the system. It first attempts to insert
 * the interaction into the 'hub_interaction' table and handles any unique constraint violations based on the `hub_upsert_behavior`.
 * It then proceeds to insert the interaction into the 'sat_interaction_http_request' table, extracting relevant details from the `nature` parameter.
 * Depending on the `interaction_key` and `nature`, the function conditionally upserts additional data into satellite tables for FHIR and HL7 requests.
 * Recursive function calls are used to further process FHIR bundles and perform additional validation. 
 * If an error occurs during any step, the function logs the error using the `register_issue` procedure and returns NULL.
 *******************************************************************************************************************************/

DROP FUNCTION IF EXISTS techbd_udi_ingress.register_interaction_http_request(text, text, jsonb, text, jsonb, jsonb, text, text, text, text, text, text, text, text, timestamptz, text, text, bool);
DROP FUNCTION IF EXISTS techbd_udi_ingress.register_interaction_http_request(text, text, jsonb, text, text, jsonb, jsonb, text, text, text, text, text, text, text, text, timestamp with time zone, text, text, boolean);

CREATE OR REPLACE FUNCTION techbd_udi_ingress.register_interaction_http_request(interaction_id text, interaction_key text, payload jsonb DEFAULT NULL::jsonb, payload_text TEXT DEFAULT NULL::text, rule_namespace text DEFAULT NULL::text, elaboration jsonb DEFAULT NULL::jsonb, nature jsonb DEFAULT NULL::jsonb, content_type text DEFAULT NULL::text, from_state text DEFAULT NULL::text, to_state text DEFAULT NULL::text, state_transition_reason text DEFAULT NULL::text, user_id text DEFAULT NULL::text, user_name text DEFAULT NULL::text, user_session text DEFAULT NULL::text, user_role text DEFAULT NULL::text, created_at timestamp with time zone DEFAULT NULL::timestamp with time zone, created_by text DEFAULT NULL::text, provenance text DEFAULT NULL::text, hub_upsert_behavior boolean DEFAULT true)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_error_msg 		TEXT;
    v_error_type 		TEXT;
    v_sqlstate 			TEXT;
    v_pg_detail 		TEXT;
    v_pg_hint 			TEXT;
    v_pg_context 		TEXT;
    v_created_at 		TIMESTAMPTZ := COALESCE(created_at, CURRENT_TIMESTAMP);
    v_created_by 		TEXT 		:= COALESCE(created_by, current_user);
    v_provenance 		TEXT 		:= COALESCE(provenance, 'unknown');
    v_exception_id 		TEXT;
   	v_nature_denorm 	TEXT;
   	v_tenant_id_denorm 	TEXT;
   
   	v_from_state				TEXT;
   	v_to_state					TEXT;
   	v_state_transition_reason 	TEXT;
   	v_nature 					JSONB;   
   	v_return 					JSONB := NULL;
   	v_disposition_json			JSONB := NULL;
   	v_payload					JSONB := NULL;
   
BEGIN 
    -- Attempt to insert into hub_interaction
    BEGIN	   	    
        INSERT INTO techbd_udi_ingress.hub_interaction (hub_interaction_id, key, created_at, created_by, provenance)
        VALUES (register_interaction_http_request.interaction_id, interaction_key, v_created_at, v_created_by, v_provenance);
    EXCEPTION
        WHEN unique_violation THEN
            IF NOT hub_upsert_behavior THEN
                -- Capture exception details
                GET STACKED DIAGNOSTICS
                    v_error_msg = MESSAGE_TEXT,
                    v_sqlstate = RETURNED_SQLSTATE,
                    v_pg_detail = PG_EXCEPTION_DETAIL,
                    v_pg_hint = PG_EXCEPTION_HINT,
                    v_pg_context = PG_EXCEPTION_CONTEXT;
                    v_error_type = 'SQL';

                -- Call register_issue to log the exception and get the exception ID
                v_exception_id := techbd_udi_ingress.register_issue(
                    NULL, interaction_key, v_error_msg, v_error_type, v_sqlstate, v_pg_detail, v_pg_hint, v_pg_context, v_created_by, v_provenance
                );
            END IF;  
    END;
      
    -- Attempt to insert into sat_interaction_http_request
    BEGIN
  
	    v_nature_denorm = nature->>'nature';
	   	v_tenant_id_denorm = nature->>'tenant_id';
	   	/*INSERT INTO techbd_udi_assurance.pgtap_fixtures_json("name","jsonb")
	   	values(gen_random_uuid()::TEXT, register_interaction_http_request.payload);*/
	  
	    -- The insertion to sat_interaction_http_request table needs only once. Need to be corrected later.
        INSERT INTO techbd_udi_ingress.sat_interaction_http_request (
            sat_interaction_http_request_id, hub_interaction_id, nature, content_type, payload, payload_text, from_state, 
            to_state, state_transition_reason, elaboration, created_at, created_by, provenance, nature_denorm, tenant_id_denorm
        )
        VALUES (
            gen_random_uuid()::text, register_interaction_http_request.interaction_id, nature, content_type, payload, payload_text, from_state, to_state, 
            state_transition_reason, elaboration, v_created_at, v_created_by, v_provenance, v_nature_denorm, v_tenant_id_denorm
        );
       
       
       	--1) Call the function with the defined parameters to upsert user info
       	IF((v_nature_denorm = 'org.techbd.service.http.Interactions$RequestResponseEncountered' AND register_interaction_http_request.interaction_key NOT IN ('/Hl7/v2')) /*fhir bundle*/
       	   OR (v_nature_denorm = 'Original HL7 Payload'	AND register_interaction_http_request.interaction_key = '/Hl7/v2')   /*hl7*/	
       	  ) THEN     		       	
	    	PERFORM techbd_udi_ingress.sat_interaction_user_upserted(
	        register_interaction_http_request.interaction_id, 
	        register_interaction_http_request.interaction_key, 
            v_nature_denorm,
	        register_interaction_http_request.payload, 
	        register_interaction_http_request.user_id, 
	        register_interaction_http_request.user_name, 
	        register_interaction_http_request.user_session, 
	        register_interaction_http_request.user_role,
	        v_tenant_id_denorm,
	        register_interaction_http_request.elaboration,
	        v_created_at, 
	        v_created_by, 
	        v_provenance
	       );  
	      
	    END IF;
	   
	    --2) Call the function with the defined parameters to upsert interaction FHIR request info.
	   	IF register_interaction_http_request.interaction_key IN ('/Bundle', '/Bundle/', '/Bundle/$validate', '/api/expect/fhir/bundle', '/Hl7/v2')
	   		AND v_nature_denorm != 'Original HL7 Payload' THEN
	   		
	   		PERFORM techbd_udi_ingress.sat_interaction_fhir_request_upserted(
	        register_interaction_http_request.interaction_id,
	        v_tenant_id_denorm,
	        register_interaction_http_request.interaction_key,
	        v_nature_denorm,
	        register_interaction_http_request.from_state,
	        register_interaction_http_request.to_state,
	        register_interaction_http_request.payload,
	        register_interaction_http_request.state_transition_reason,
	        v_created_at,
	        v_created_by,
	        v_provenance,
	      	register_interaction_http_request.elaboration
	       );	
	      --2) Call the function with the defined parameters to upsert interaction HL7 request info.
	    ELSIF register_interaction_http_request.interaction_key = '/Hl7/v2' AND v_nature_denorm = 'Original HL7 Payload' THEN
	   		PERFORM techbd_udi_ingress.sat_interaction_hl7_request_upserted(
	        register_interaction_http_request.interaction_id,
	        v_tenant_id_denorm,
	        register_interaction_http_request.interaction_key,
	        v_nature_denorm,
	        register_interaction_http_request.from_state,
	        register_interaction_http_request.to_state,
	        register_interaction_http_request.payload,
	        register_interaction_http_request.state_transition_reason,
	        v_created_at,
	        v_created_by,
	        v_provenance,
	        register_interaction_http_request.elaboration
	       );	
	    END IF;	
	   
		/*==============================================================================================================================*/
		--RECURSIVE FUNCTION CALL
	   	/*----------------------------- FHIR Bundle inserts into sat_interaction_http_request ----------------------*/
		IF register_interaction_http_request.interaction_key IN ('/Bundle', '/Bundle/', '/Hl7/v2') THEN  
			IF (v_nature_denorm = 'org.techbd.service.http.Interactions$RequestResponseEncountered') THEN	--Check previous nature				
				v_from_state 	:= 'NONE';
				v_to_state 		:= 'ACCEPT_FHIR_BUNDLE';
				v_nature 		:= jsonb_build_object('nature', 'Original FHIR Payload', 'tenant_id', v_tenant_id_denorm);
				v_payload 		:= COALESCE(register_interaction_http_request.payload->'request'->'requestBody', 'null'::jsonb);
				   
				-- Recursive call with adjusted parameters
				v_return := techbd_udi_ingress.register_interaction_http_request(
					register_interaction_http_request.interaction_id, 
					register_interaction_http_request.interaction_key,  
					v_payload,--register_interaction_http_request.payload,  -- Adjust this if needed
					register_interaction_http_request.payload_text, -- payload_text IS NULL FOR FHIR
					register_interaction_http_request.rule_namespace,
					register_interaction_http_request.elaboration, 
					v_nature,   -- Adjust this if needed
					register_interaction_http_request.content_type, 
					v_from_state, 
					v_to_state, 
					state_transition_reason, 
					register_interaction_http_request.user_id, 
					register_interaction_http_request.user_name, 
					register_interaction_http_request.user_session, 
					register_interaction_http_request.user_role, 
					register_interaction_http_request.created_at, 
					register_interaction_http_request.created_by, 
					register_interaction_http_request.provenance, 
					register_interaction_http_request.hub_upsert_behavior
			    );
			ELSEIF (v_nature_denorm = 'Original FHIR Payload') THEN	
				v_from_state 	:= 'ACCEPT_FHIR_BUNDLE';
				v_to_state		:= 'DISPOSITION';
				v_nature 		:= jsonb_build_object('nature', 'techByDesignDisposition', 'tenant_id', v_tenant_id_denorm);
				
				SELECT sat_intr_req.payload
				INTO v_payload
				FROM techbd_udi_ingress.sat_interaction_http_request sat_intr_req
				WHERE sat_intr_req.hub_interaction_id = register_interaction_http_request.interaction_id
				AND sat_intr_req.nature_denorm = 'org.techbd.service.http.Interactions$RequestResponseEncountered'
				AND sat_intr_req.tenant_id_denorm = v_tenant_id_denorm;
				
				--Function call to validate with Json Action Rule
				v_disposition_json := techbd_udi_ingress.process_json_action_rules(
					v_payload,
					register_interaction_http_request.rule_namespace,
					register_interaction_http_request.interaction_key
				);
			
				v_disposition_json := v_disposition_json-> 'response'->'responseBody';
			
					
				-- Recursive call with adjusted parameters
				v_return := techbd_udi_ingress.register_interaction_http_request(
					register_interaction_http_request.interaction_id, 
					register_interaction_http_request.interaction_key,  
					v_disposition_json, -- Adjust this if needed
					register_interaction_http_request.payload_text, -- payload_text IS NULL FOR FHIR
					register_interaction_http_request.rule_namespace,
					register_interaction_http_request.elaboration, 
					v_nature,   -- Adjust this if needed
				    register_interaction_http_request.content_type, 
				    v_from_state, 
				    v_to_state, 
				    state_transition_reason, 
				    register_interaction_http_request.user_id, 
				    register_interaction_http_request.user_name, 
				    register_interaction_http_request.user_session, 
				    register_interaction_http_request.user_role, 
				    register_interaction_http_request.created_at, 
				    register_interaction_http_request.created_by, 
				    register_interaction_http_request.provenance, 
				    register_interaction_http_request.hub_upsert_behavior
			    );
			   
			ELSEIF (v_nature_denorm = 'techByDesignDisposition') THEN
			
				--v_return := register_interaction_http_request.payload;
			
				SELECT sat_intr_req.payload
					INTO v_payload
					FROM techbd_udi_ingress.sat_interaction_http_request sat_intr_req
					WHERE sat_intr_req.hub_interaction_id = register_interaction_http_request.interaction_id
					AND sat_intr_req.nature_denorm = 'techByDesignDisposition'
					AND sat_intr_req.tenant_id_denorm = v_tenant_id_denorm;
	
				v_return := v_payload;
			
			END IF;			
		END IF;	
	/*==============================================================================================================================*/	 	
    EXCEPTION
        WHEN OTHERS THEN
            -- Capture exception details
            GET STACKED DIAGNOSTICS
                v_error_msg = MESSAGE_TEXT,
                v_sqlstate = RETURNED_SQLSTATE,
                v_pg_detail = PG_EXCEPTION_DETAIL,
                v_pg_hint = PG_EXCEPTION_HINT,
                v_pg_context = PG_EXCEPTION_CONTEXT;
                v_error_type = 'SQL';
               
         	--RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
               
            -- Log the exception, reusing the previous exception ID if it exists
            v_exception_id := techbd_udi_ingress.register_issue(
                COALESCE(v_exception_id, NULL), interaction_key, v_error_msg, v_error_type, v_sqlstate, v_pg_detail, v_pg_hint, v_pg_context, v_created_by, v_provenance
            );
           v_return := NULL;
    END;
   	RETURN v_return;
END;
$function$
;



/*******************************************************************************************
 * Comprehensive view of Orchctl issue classification. * 
 ******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.orch_session_issue_classification CASCADE;
CREATE OR REPLACE
VIEW techbd_udi_ingress.orch_session_issue_classification as
WITH cte_business_rule AS (
SELECT
	worksheet AS worksheet,
	field AS field,
	required AS required,
	"Resolved by QE/QCS" AS resolved_by_qe_qcs,
	CONCAT(
          case
		when UPPER("True Rejection") = 'YES' then 'REJECTION'
		else ''
	end,
	case
		when UPPER("Warning Layer") = 'YES' then 'WARNING'
		else ''
	end
      ) AS record_action
FROM
	techbd_orch_ctl.business_rules
GROUP BY
	worksheet,
	field,
	required,
	resolved_by_qe_qcs,
	record_action
)
SELECT
	DISTINCT ON
	(isi.orch_session_issue_id) 
  isi.*,
	CASE
		WHEN
        UPPER(isi.issue_type) = 'MISSING COLUMN'
      THEN
        'STRUCTURAL ISSUE'
		ELSE
        br.record_action
	END
  AS disposition,
	CASE
		WHEN UPPER(br.resolved_by_qe_qcs) = 'YES' THEN 'Resolved By QE/QCS'
		ELSE null
	END AS remediation2
FROM
	techbd_orch_ctl.orch_session_issue AS isi
LEFT JOIN cte_business_rule br ON
	br.field = isi.issue_column
WHERE
	isi.orch_session_issue_id is not null
;

/*******************************************************************************************
 * Comprehensive view of SFTP interactions and their associated requests. * 
 ******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_sftp CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_sftp AS 
WITH issue_count AS (
SELECT
	osi.session_id,
	count(osi.orch_session_issue_id) AS issue_count
FROM
	techbd_udi_ingress.orch_session_issue_classification osi
GROUP BY
	osi.session_id
),
rejection_count AS (
SELECT
	osi.session_id,
	count(osi.orch_session_issue_id) AS rejection_count
FROM
	techbd_udi_ingress.orch_session_issue_classification osi
WHERE 
		osi.disposition = 'REJECTION'
GROUP BY
	osi.session_id
),
warning_count AS (
SELECT
	osi.session_id,
	count(osi.orch_session_issue_id) AS warning_count
FROM
	techbd_udi_ingress.orch_session_issue_classification osi
WHERE 
		osi.disposition = 'WARNING'
GROUP BY
	osi.session_id
)
SELECT
	"substring"(ose.ingest_src::text,
	'/SFTP/([^/]+)/'::text) AS qe,
	os.orch_started_at::timestamptz AS request_time,
	ose.session_id,
	os."version",
	count(ose.ingest_src) AS ingress_count,
	count(ose.ingest_src) AS consumed_count,
	coalesce(ic.issue_count,
	0) AS issue_count,
	coalesce(rc.rejection_count,
	0) AS rejection_count,
	coalesce(wc.warning_count,
	0) AS warning_count
FROM
	techbd_orch_ctl.orch_session_entry ose
JOIN techbd_orch_ctl.orch_session os ON
	ose.session_id = os.orch_session_id
LEFT JOIN issue_count ic ON
	ose.session_id = ic.session_id
LEFT JOIN rejection_count rc ON
	ose.session_id = rc.session_id
LEFT JOIN warning_count wc ON
	ose.session_id = wc.session_id
WHERE
	"substring"(ose.ingest_src::text,
	'/SFTP/([^/]+)/'::text) is not null
GROUP BY
	ose.session_id,
	qe,
	os."version",
	os.orch_started_at::timestamptz,
	ic.issue_count,
	rc.rejection_count,
	wc.warning_count;


/*******************************************************************************************
 * Comprehensive view of Latest FHIR Interactions per Tenant IDs* 
 ******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_recent_fhir CASCADE;
 CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_recent_fhir AS
 WITH ranked_records AS (
    SELECT 
        sihr.sat_interaction_fhir_request_id,
        sihr.hub_interaction_id AS interaction_id,
        sihr.tenant_id AS tenant_id,
        sihr.created_at AS interaction_created_at,
        row_number() OVER (PARTITION BY (upper(sihr.tenant_id)) ORDER BY sihr.created_at DESC) AS rn,
        COUNT(*)
 OVER (PARTITION BY (upper(sihr.tenant_id))) AS interaction_count
    FROM 
        techbd_udi_ingress.sat_interaction_fhir_request sihr 
    WHERE sihr.uri = ANY (ARRAY['/Bundle'::text, '/Bundle/$validate'::text, '/Bundle/'::text, '/Bundle/$validate/'::text])
)
SELECT 
    sat_interaction_fhir_request_id as sat_interaction_http_request_id,
    interaction_id,
    tenant_id,
    interaction_created_at,
    interaction_count
FROM 
    ranked_records
WHERE rn = 1;


/**
 * View to summarize FHIR submission interactions from the database.
 * This view provides an aggregated overview of HTTP request interactions based on
 * different types of nature values recorded in the `sat_interaction_http_request` table.
 * The view calculates the following metrics over the past 7 days:
 *
 * 1. `total_submissions`: Counts submissions where the nature is 'Original FHIR Payload'.
 * 2. `accepted_submissions`: Counts submissions where the nature is 'Forwarded HTTP Response'.
 * 3. `rejected_submissions`: Counts submissions where the nature is 'Forwarded HTTP Response Error'.
 * 4. `pending_submissions`: Counts submissions where the nature is neither 'Forwarded HTTP Response',
 *    'Forwarded HTTP Response Error', nor 'org.techbd.service.http.Interactions$RequestResponseEncountered'.
 *
 * This view aggregates data for all interactions related to FHIR submissions based on the following:
 * - Interaction metadata including the nature of HTTP requests.
 * - Filtering interactions that occurred in the last 7 days.
 * - Using a specific key value (`/Bundle`) to filter interactions.
 *
 * The view helps in monitoring and analyzing FHIR interaction statuses, providing insight into:
 * - Total count of submissions made in the specified period.
 * - Number of submissions that were accepted or rejected.
 * - Submissions that are pending or still not categorized as accepted or rejected.
 *
 * Usage:
 * SELECT * FROM techbd_udi_ingress.fhir_submission_summary;
 *
 * @return TABLE - A table summarizing total, accepted, rejected, and pending FHIR submissions
 *         for interactions within the past 7 days.
 */

DROP VIEW IF EXISTS techbd_udi_ingress.fhir_submission_summary CASCADE;

CREATE OR REPLACE VIEW techbd_udi_ingress.fhir_submission_summary AS 
   WITH submission_counts AS (
    SELECT  
        --NONE    -> ACCEPT_FHIR_BUNDLE
        COUNT(CASE WHEN sihr.nature = 'Original FHIR Payload' THEN 1 END) AS total_submissions,
        --FORWARD-> COMPLETE
        COUNT(CASE WHEN sihr.nature = 'Forwarded HTTP Response' THEN 1 END) AS accepted_submissions,
        --FORWARD-> FAIL
        COUNT(CASE WHEN sihr.nature = 'Forwarded HTTP Response Error' THEN 1 END) AS rejected_submissions
    FROM 
        techbd_udi_ingress.sat_interaction_fhir_request AS sihr
    WHERE 
        sihr."uri" = '/Bundle'
        AND sihr.created_at >= CURRENT_DATE - INTERVAL '7 days'
)
SELECT  
    total_submissions,
    accepted_submissions,
    rejected_submissions,
    total_submissions - accepted_submissions - rejected_submissions AS pending_submissions
FROM 
    submission_counts;


/**
 * View to summarize FHIR submission interactions and categorize them for further analysis.
 * This view provides an aggregated overview of HTTP request interactions based on
 * different types of nature values recorded in the `sat_interaction_http_request` table.
 * The view calculates the following metrics over the past 7 days:
 *
 * 1. `qe_total_submissions`: Counts submissions where the nature is 'Original FHIR Payload'.
 * 2. `techbd_total_submissions`: Counts submissions where the nature is 'Forward HTTP Request'.
 * 3. `scoring_engine_submissions`: Counts submissions where the nature is 'Forwarded HTTP Response'.
 *
 * In addition to the calculated metrics, the view includes placeholders for custom fields:
 * - `cross_roads_scn`: Placeholder for additional contextual information or classification.
 * - `shinny`: Placeholder for additional contextual information or classification.
 * - `mdw`: Placeholder for additional contextual information or classification.
 *
 * This view aggregates data for all interactions related to FHIR submissions based on the following:
 * - Interaction metadata including the nature of HTTP requests.
 * - Filtering interactions that occurred in the last 7 days.
 * - Using a specific key value (`/Bundle`) to filter interactions.
 *
 * The view helps in monitoring and analyzing FHIR interaction statuses, providing insight into:
 * - Total number of submissions made in the specified period.
 * - Number of submissions that were forwarded for HTTP requests.
 * - Number of submissions that received a response from the scoring engine.
 * - Custom fields for additional classification or context.
 *
 * Usage:
 * SELECT * FROM techbd_udi_ingress.fhir_needs_attention;
 *
 * @return TABLE - A table summarizing total, forwarded, and scoring engine submissions
 *         for interactions within the past 7 days, including custom fields for additional classification.
 */


DROP VIEW IF EXISTS techbd_udi_ingress.fhir_needs_attention CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.fhir_needs_attention AS  
WITH submission_counts AS (
         SELECT sihr.tenant_id_lower AS qe_name,
            count(
                CASE
                    WHEN sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered'::text THEN 1
                    ELSE NULL::integer
                END) AS qe_total_submissions,
 
            count(
                CASE
                    WHEN sihr.nature = 'Forwarded HTTP Response'::text or sihr.nature = 'Forwarded HTTP Response Error' THEN 1
                    ELSE NULL::integer
                END) AS scoring_engine_submissions,
           
            max(sihr.created_at) AS recently_created_at
           FROM techbd_udi_ingress.sat_interaction_fhir_request sihr
          WHERE (sihr.uri = ANY (ARRAY['/Bundle/'::text, '/Bundle'::text])) AND sihr.created_at >= (CURRENT_DATE - '7 days'::interval) AND sihr.tenant_id <> 'N/A'::text
          GROUP BY sihr.tenant_id_lower
        )
  SELECT ( SELECT count(*) AS count
           FROM techbd_udi_ingress.sat_interaction_fhir_request sihr 
          WHERE sihr.tenant_id_lower = sc.qe_name AND sihr.uri = '/api/expect/fhir/bundle' AND sihr.created_at >= (CURRENT_DATE - '7 days'::interval)) AS cross_roads_scn,
    qe_name,
    qe_total_submissions,  
    scoring_engine_submissions,
    (qe_total_submissions - scoring_engine_submissions) AS missed_scoring_engine_submissions,
    recently_created_at,
    '??'::text AS shinny,
    '??'::text AS mdw
   FROM submission_counts sc
  ORDER BY recently_created_at DESC;


/*************************************
* The stored procedure register_expectation_http_request aims to insert expectation data into two tables: hub_expectation and sat_expectation_http_request. It performs the following steps:

* Input Parameters:

* expectation_id: Unique identifier for the expectation.
* expectation_key: Key associated with the expectation.
* payload: JSONB data containing the request payload.
* content_type (optional): Type of content being registered.
* created_at (optional): Timestamp when the record was created.
* created_by (optional): User who created the record.
* provenance (optional): Source of the record.
* hub_upsert_behavior (optional): Boolean flag to determine upsert behavior (default is true).
*
* Default Values:
*
* v_created_at: Defaults to the current timestamp if not provided.
* v_created_by: Defaults to the current user if not provided.
* v_provenance: Defaults to 'unknown' if not provided.
*
* Insert into hub_expectation:
*
* Attempts to insert the expectation data into the hub_expectation table.
* If a unique constraint violation occurs and hub_upsert_behavior is false, it logs the exception details by calling techbd_udi_ingress.register_issue.
* Insert into sat_expectation_http_request:

* Attempts to insert the HTTP request details into the sat_expectation_http_request table.
* If any exception occurs, it logs the exception details and associates it with a previously logged exception if available.
* Exception Handling:

* Captures various exception details such as error message, SQL state, and additional context.
* Logs the captured exception details using techbd_udi_ingress.register_issue. 
****************************************************************************/

DROP PROCEDURE IF EXISTS techbd_udi_ingress.register_expectation_http_request;
CREATE OR REPLACE PROCEDURE techbd_udi_ingress.register_expectation_http_request(IN expectation_id text, IN expectation_key text, IN payload jsonb, IN content_type text DEFAULT NULL::text, IN created_at timestamp with time zone DEFAULT NULL::timestamp with time zone, IN created_by text DEFAULT NULL::text, IN provenance text DEFAULT NULL::text, IN hub_upsert_behavior boolean DEFAULT true)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    v_error_msg TEXT;
    v_error_type TEXT;
    v_sqlstate TEXT;
    v_pg_detail TEXT;
    v_pg_hint TEXT;
    v_pg_context TEXT;
    v_created_at TIMESTAMPTZ := COALESCE(created_at, CURRENT_TIMESTAMP);
    v_created_by TEXT := COALESCE(created_by, current_user);
    v_provenance TEXT := COALESCE(provenance, 'unknown');
    v_exception_id TEXT;
BEGIN
    -- Attempt to insert into hub_expectation
    BEGIN
        INSERT INTO techbd_udi_ingress.hub_expectation (hub_expectation_id, key, created_at, created_by, provenance)
        VALUES (expectation_id, expectation_key, v_created_at, v_created_by, v_provenance);

    EXCEPTION
        WHEN unique_violation THEN
            IF NOT hub_upsert_behavior THEN
                -- Capture exception details
                GET STACKED DIAGNOSTICS
                    v_error_msg = MESSAGE_TEXT,
                    v_sqlstate = RETURNED_SQLSTATE,
                    v_pg_detail = PG_EXCEPTION_DETAIL,
                    v_pg_hint = PG_EXCEPTION_HINT,
                    v_pg_context = PG_EXCEPTION_CONTEXT;
                    v_error_type = 'SQL';

                -- Call register_issue to log the exception and get the exception ID
                v_exception_id := techbd_udi_ingress.register_issue(
                    NULL, expectation_key, v_error_msg, v_error_type, v_sqlstate, v_pg_detail, v_pg_hint, v_pg_context, v_created_by, v_provenance
                );
            END IF;
    END;

    -- Attempt to insert into sat_expectation_http_request
    BEGIN
        INSERT INTO techbd_udi_ingress.sat_expectation_http_request (
            sat_expectation_http_request_id, hub_expectation_id, content_type, payload, created_at, created_by, provenance
        )
        VALUES (
            gen_random_uuid()::text, expectation_id, content_type, payload, v_created_at, v_created_by, v_provenance);

    EXCEPTION
        WHEN OTHERS THEN
            -- Capture exception details
            GET STACKED DIAGNOSTICS
                v_error_msg = MESSAGE_TEXT,
                v_sqlstate = RETURNED_SQLSTATE,
                v_pg_detail = PG_EXCEPTION_DETAIL,
                v_pg_hint = PG_EXCEPTION_HINT,
                v_pg_context = PG_EXCEPTION_CONTEXT;
                v_error_type= 'SQL';

            -- Log the exception, reusing the previous exception ID if it exists
            v_exception_id := techbd_udi_ingress.register_issue(
                COALESCE(v_exception_id, NULL), expectation_key, v_error_msg, v_error_type, v_sqlstate, v_pg_detail, v_pg_hint, v_pg_context, v_created_by, v_provenance
            );
    END;
END;
$procedure$
;    

/**
 * View to identify and analyze FHIR-related HTTP request interactions that need attention,
 * specifically focusing on issues with Bundle submissions. This view captures detailed
 * information about each interaction, including patient data and error types, allowing
 * for better troubleshooting and resolution of data submission and validation errors.
 *
 * The view performs the following:
 * 1. Extracts relevant interaction data from the `sat_interaction_http_request` table, 
 *    including:
 *    - `hub_interaction_id`: The unique identifier for the interaction.
 *    - `sat_interaction_http_request_id`: The unique ID for the HTTP request.
 *    - `qe_name`: The tenant ID associated with the request.
 *    - `created_at`: The timestamp when the request was created.
 *    - `patient_mrn`: The Medical Record Number (MRN) of the patient involved.
 *    - `patient_full_name`: The full name of the patient as provided in the request.
 *    - `patient_last_name`: The last name of the patient.
 *    - `patient_first_name`: The first name of the patient.
 * 2. Uses a `CASE` statement to classify the type of error encountered:
 *    - `Data Submission Error`: Indicates an error due to a 'Forwarded HTTP Response Error'.
 *    - `Data Validation Error`: Indicates an error where the 'scoredcardResponse' is missing.
 *    - `no_error`: Indicates no recognized error was found.
 * 3. Filters the interactions to include only those that target the `/Bundle` endpoint and have 
 *    encountered either a 'Forwarded HTTP Response Error' or a 'Forwarded HTTP Response' 
 *    without a 'scoredcardResponse'.
 * 4. Limits the results to interactions that occurred within the last 7 days to focus on recent issues.
 *
 * The result set includes:
 * - Detailed metadata and patient information related to the interaction.
 * - A classification of the error type for each interaction.
 *
 * @return VIEW - A view named `fhir_needs_attention_details`, providing detailed insights 
 * into FHIR-related HTTP requests that failed or need attention, helping identify and resolve
 * issues with data submissions.
 */
 
DROP VIEW IF EXISTS techbd_udi_ingress.fhir_needs_attention_details CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.fhir_needs_attention_details
AS SELECT hub_interaction_id,
    sat_interaction_fhir_request_id AS sat_interaction_http_request_id,
    tenant_id_lower AS qe_name, 
    created_at 
   FROM techbd_udi_ingress.sat_interaction_fhir_request sihr
 WHERE 
 sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered' 
  AND NOT EXISTS (
      SELECT 1
      FROM techbd_udi_ingress.sat_interaction_fhir_request sihr_sub
      WHERE sihr_sub.hub_interaction_id = sihr.hub_interaction_id
        AND sihr_sub.nature IN ('Forwarded HTTP Response', 'Forwarded HTTP Response Error')
  )
  AND (uri = ANY (ARRAY['/Bundle/', '/Bundle'])) 
  AND created_at >= (CURRENT_DATE - '7 days'::interval)
ORDER BY created_at DESC;


/**
 * View to generate a dashboard overview of FHIR (Fast Healthcare Interoperability Resources)
 * interactions that need attention, focusing on key performance metrics across different tenants.
 * The dashboard aggregates counts of submissions and responses related to FHIR Bundle transactions,
 * specifically targeting organizations such as HealtheLink, HealtheConnections, Healthix, GRRHIO, 
 * and HIXNY. This view provides a summarized view of submissions, forwarding actions, and the 
 * success of scoring engine responses.
 *
 * The view performs the following steps:
 * 1. A Common Table Expression (CTE) named `combined_counts` is used to calculate the following 
 *    metrics for each tenant (qe_name):
 *    - `qe_total_submissions`: Count of total submissions from the tenants.
 *    - `techbd_total_submissions`: Count of total forward HTTP requests made to TechBD.
 *    - `total_scoring_engine_submissions`: Count of total forwarded HTTP responses that were processed
 *      by the scoring engine.
 *    - `scoring_engine_submission_passed`: Count of scoring engine responses that included a scorecard 
 *      response, indicating successful validation.
 *    - `cross_roads_scn`: Count of interactions involving the Cross Roads SCN API endpoint.
 * 2. The main SELECT query aggregates the counts across all tenants to generate the following metrics:
 *    - `total_cross_roads_scn`: Total count of Cross Roads SCN interactions across all tenants.
 *    - `total_techbd_total_submissions`: Total count of TechBD submissions across all tenants.
 *    - `total_total_scoring_engine_submissions`: Total count of scoring engine submissions across all tenants.
 *    - `total_scoring_engine_submission_passed`: Total count of successful scoring engine submissions 
 *      across all tenants.
 *    - Additionally, the query provides individual tenant metrics for HealtheLink, HealtheConnections, 
 *      Healthix, GRRHIO, and HIXNY, including total submissions and successful scoring engine submissions.
 *
 * The view is designed to be queried by the dashboard for a quick and comprehensive summary of the 
 * performance and issues related to FHIR Bundle submissions over the past 7 days.
 *
 * @return VIEW - A view named `fhir_needs_attention_dashbaord`, providing aggregated metrics 
 * for FHIR interactions that require attention, across specific tenants.
 */


DROP VIEW IF EXISTS techbd_udi_ingress.fhir_needs_attention_dashbaord CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.fhir_needs_attention_dashbaord AS     
WITH combined_counts AS (
    SELECT 
        sihr.tenant_id_lower AS qe_name,
        
        -- Calculate total submissions for the QE
        count(
            CASE 
                WHEN sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered'::text THEN 1
                ELSE NULL::integer 
            END
        ) AS qe_total_submissions,

        -- Scoring engine submissions (Forwarded HTTP Response and Forwarded HTTP Response Error)
        count(
            CASE 
                WHEN ((sihr.nature) = 'Forwarded HTTP Response' 
                     OR (sihr.nature) = 'Forwarded HTTP Response Error') THEN 1
                ELSE NULL::integer 
            END
        ) AS scoring_engine_submissions, 
        max(sihr.created_at) AS recently_created_at
    FROM 
         techbd_udi_ingress.sat_interaction_fhir_request sihr
    WHERE 
        sihr.created_at >= (CURRENT_DATE - '7 days'::interval) 
        AND (sihr.uri = ANY (ARRAY['/Bundle/'::text, '/Bundle'::text]))
        AND sihr.tenant_id_lower::text = ANY (
            ARRAY['healthelink'::text, 'healtheconn'::text, 'healthix'::text, 'grrhio'::text, 'hixny'::text  ]
        )
    GROUP BY 
        sihr.tenant_id_lower::text
)

SELECT 
( SELECT ( SELECT count(*) AS count
           FROM techbd_udi_ingress.sat_interaction_fhir_request sihr
          WHERE sihr.tenant_id_lower  = ANY (
            ARRAY['healthelink'::text, 'healtheconn'::text, 'healthix'::text, 'grrhio'::text, 'hixny'::text  ]
        )
          AND sihr.uri = '/api/expect/fhir/bundle' AND 
          sihr.created_at >= (CURRENT_DATE - '7 days'::interval))) AS total_cross_roads_scn,
  

    -- QE total submissions per tenant
    sum(
        CASE 
            WHEN qe_name = 'healthelink'::text THEN qe_total_submissions 
            ELSE 0::bigint 
        END
    ) AS healthelink_total_submissions,
    sum(
        CASE 
            WHEN qe_name = 'healtheconn'::text THEN qe_total_submissions 
            ELSE 0::bigint 
        END
    ) AS healtheconnections_total_submissions,
    sum(
        CASE 
            WHEN qe_name = 'healthix'::text THEN qe_total_submissions 
            ELSE 0::bigint 
        END
    ) AS healthix_total_submissions,
    sum(
        CASE 
            WHEN qe_name = 'grrhio'::text THEN qe_total_submissions 
            ELSE 0::bigint 
        END
    ) AS grrhio_total_submissions,
    sum(
        CASE 
            WHEN qe_name = 'hixny'::text THEN qe_total_submissions 
            ELSE 0::bigint 
        END
    ) AS hixny_total_submissions, 

    -- Missed scoring engine submissions for each tenant
    sum(
        CASE 
            WHEN qe_name = 'healthelink'::text THEN  scoring_engine_submissions 
            ELSE 0::bigint 
        END
    ) AS healthelink_scoring_engine_submissions,
    sum(
        CASE 
            WHEN qe_name = 'healtheconn'::text THEN scoring_engine_submissions
            ELSE 0::bigint 
        END
    ) AS healtheconnections_scoring_engine_submissions,
    sum(
        CASE 
            WHEN qe_name = 'healthix'::text THEN scoring_engine_submissions
            ELSE 0::bigint 
        END
    ) AS healthix_scoring_engine_submissions,
    sum(
        CASE 
            WHEN qe_name = 'grrhio'::text THEN  scoring_engine_submissions
            ELSE 0::bigint 
        END
    ) AS grrhio_scoring_engine_submissions,
    sum(
        CASE 
            WHEN qe_name = 'hixny'::text THEN scoring_engine_submissions
            ELSE 0::bigint 
        END
    ) AS hixny_scoring_engine_submissions 
 

FROM 
    combined_counts
WHERE 
    qe_name = ANY (
        ARRAY['healthelink'::text, 'healtheconn'::text, 'healthix'::text, 'grrhio'::text, 'hixny'::text ]
    );

/**
 * View to identify and analyze failed HTTP request interactions that need attention.
 * This view aggregates details of HTTP requests that transitioned to a 'FAIL' state,
 * providing insights into the nature of the errors encountered, the associated error
 * messages, and the potential reasons for failure.
 *
 * The view performs the following:
 * 1. Extracts core information from the `interaction_http_request_mat` table, 
 *    including the error type (`nature`), error message (`payload ->> 'error'`), 
 *    and the timestamp when the request was created (`request_created_at`).
 * 2. Joins with `interaction_http_request_resource_type_mat` to include resource 
 *    type data related to the failed request.
 * 3. Joins with `interaction_http_request_observe_mat` to incorporate observability 
 *    metrics if available.
 *
 * The result set includes:
 * - `error_type`: The nature of the failure.
 * - `error_message`: The specific error message extracted from the request payload.
 * - `date`: The timestamp when the HTTP request was created.
 * - `sat_interaction_http_request_id`: The unique identifier for the HTTP request.
 * - `failure_reason`: A predefined explanation for the failure, guiding troubleshooting.
 *
 * The view filters requests that have transitioned to the 'FAIL' state, indicating
 * that they failed during processing. The included `failure_reason` provides context
 * and potential solutions to address the error.
 *
 * @return VIEW - A view named `interaction_http_request_failed_needs_attention`, 
 * providing details of HTTP requests that failed and require attention.
 */
 
-- techbd_udi_ingress.interaction_fhir_request_failed_needs_attention source
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_request_failed_needs_attention CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_request_failed_needs_attention
AS SELECT nature AS error_type,
    payload ->> 'error'::text AS error_message,
    created_at AS date,
    sat_interaction_fhir_request_id as sat_interaction_http_request_id,
    'This error occurs when the server cannot process the request due to invalid syntax. Ensure the request format, headers, and endpoint are correct.'::text AS failure_reason,
    '<ol>
        <li><strong>Resolution Steps:</strong></li>
        <li><strong>1. Verify Request Format:</strong>
            <ol>
                <li>Ensure that the request payload (body) is correctly formatted according to the API documentation.</li>
                <li>Check that all required parameters are included and correctly formatted.</li>
            </ol>
        </li>
        <li><strong>2. Validate Data:</strong>
            <ol>
                <li>Double-check the data being sent in the request to ensure it adheres to the API''s expectations (e.g., data types, mandatory fields).</li>
            </ol>
        </li>
        <li><strong>3. Check Headers:</strong>
            <ol>
                <li>Ensure that the correct Content-Type header is set (e.g., <code>application/json</code> for JSON payloads).</li>
                <li>Confirm that any other required headers are present and correctly set.</li>
            </ol>
        </li>
        <li><strong>4. Review Endpoint:</strong>
            <ol>
                <li>Verify that the endpoint URL is correct and matches the API''s documentation.</li>
                <li>Check if there have been any updates or changes to the API that could affect the request.</li>
                <li>Use tools like Postman or cURL to manually test the endpoint and compare results.</li>
            </ol>
        </li> 
        <li>
         If these steps do not resolve the issue, consider reaching out to the support.
        </li>
    </ol>'::text AS resolution_steps
   FROM techbd_udi_ingress.sat_interaction_fhir_request htt_req
  WHERE upper(to_state) = 'FAIL'::text;

 
/**
 * View to identify and analyze failed FHIR-related HTTP request interactions that need attention.
 * This view focuses on HTTP requests that involve FHIR (Fast Healthcare Interoperability Resources)
 * interactions, specifically those targeting the `/Bundle` endpoint, which may have encountered issues 
 * related to invalid or incomplete data submissions.
 *
 * The view performs the following:
 * 1. Extracts key information from the `interaction_http_request_mat` table, including:
 *    - The nature of the error (`nature`).
 *    - The specific error message from the 'insertScreeningsResponse' field in the payload.
 *    - The timestamp of the request (`request_created_at`).
 *    - The unique identifier of the HTTP request (`sat_interaction_http_request_id`).
 * 2. Joins with `interaction_http_request_resource_type_mat` to include relevant resource 
 *    type information for the failed request.
 * 3. Joins with `interaction_http_request_observe_mat` to incorporate observability metrics if available.
 *
 * The result set includes:
 * - `error_type`: The nature or category of the error encountered.
 * - `error_message`: The specific error message extracted from the request's payload.
 * - `date`: The timestamp when the HTTP request was created.
 * - `sat_interaction_http_request_id`: The unique identifier for the HTTP request.
 * - `failure_reason`: A predefined explanation for the failure, guiding troubleshooting.
 *
 * The view filters for requests directed to the `/Bundle` endpoint, indicating interactions
 * related to FHIR Bundle submissions that need attention due to potential issues with data format or completeness.
 * 
 * The `failure_reason` provides context and recommendations, ensuring that the data aligns with 
 * the required format and includes all necessary fields to avoid such errors in future submissions.
 *
 * @return VIEW - A view named `interaction_http_fhir_request_needs_attention`, 
 * providing details of FHIR-related HTTP requests that failed and require attention.
 */

DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_fhir_request_needs_attention CASCADE; 
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_fhir_request_needs_attention
AS SELECT 
htt_req.nature as error_type,
CONCAT_WS(' , ', 
    htt_req.error_message, 
    (SELECT string_agg(concat_ws(': ', key, COALESCE(value, 'NULL')), ', ') 
     FROM jsonb_each_text((htt_req.payload->>'responseBody')::jsonb) AS json_data(key, value))
) AS error_message,
htt_req.created_at AS date,
htt_req.sat_interaction_fhir_request_id as sat_interaction_http_request_id,
'This error occurs when the server cannot process the request due to invalid syntax or data issues. Ensure that the request format, headers, endpoint, and data adhere to the API and IG specifications.'::text AS failure_reason,
'<ol>
    <li><strong>Resolution Steps:</strong></li>
    <li><strong>1. Verify Request Format:</strong>
        <ol>
            <li>Ensure that the request payload (body) is correctly formatted according to the API documentation and SHIN-NY IG specification (e.g., date formats, string lengths, numeric values).</li>
            <li>Check that all required parameters and fields are included and correctly formatted.</li>
        </ol>
    </li>
    <li><strong>2. Validate Data:</strong>
        <ol>
            <li>Double-check the data being sent in the request to ensure it matches the required data types and adheres to API expectations (e.g., integers, strings, booleans).</li>
            <li>Confirm that all mandatory fields are present in the FHIR payload to prevent submission errors.</li>
        </ol>
    </li>
    <li><strong>3. Check Headers:</strong>
        <ol>
            <li>Ensure the correct Content-Type header is set (e.g., <code>application/json</code> for JSON payloads).</li>
            <li>Confirm that any other required headers are present and correctly set.</li>
        </ol>
    </li>
    <li><strong>4. Review Endpoint and API Documentation:</strong>
        <ol>
            <li>Verify that the endpoint URL is correct and matches the APIs documentation.</li>
            <li>Cross-check the FHIR payload with the SHIN-NY IG specification to ensure compliance.</li>
            <li>Check for any updates or changes to the API that could affect the request.</li>
            <li>Use tools like Postman or cURL to manually test the endpoint and compare results.</li>
        </ol>
    </li>
    <li><strong>5. Use Validation Tools:</strong>
        <ol>
            <li>Consider using validation libraries or tools to catch data issues before sending the request.</li>
            <li>Test the request using tools like Postman to validate the payload against the API.</li>
        </ol>
    </li>
    <li>If these steps do not resolve the issue, consider reaching out to the support team.</li>
</ol>'::text AS resolution_steps
FROM
techbd_udi_ingress.sat_interaction_fhir_request htt_req;


/**
 * View to summarize HTTP request interactions with client IP and user agent filtering.
 * 
 * This view aggregates and summarizes recent HTTP request interactions within the system,
 * focusing on the past 7 days. It extracts key details such as tenant ID, client IP address, 
 * user agent, and the total count of requests per combination of these elements. 
 * This summary is particularly useful for identifying patterns of interaction across 
 * different tenants, IP addresses, and user agents, allowing for efficient monitoring and analysis.
 * 
 * Key components:
 * - tenant_id: Identifies the tenant responsible for each HTTP request.
 * - client_ip_address: Extracted from the 'x-forwarded-for' header within the request's payload,
 *   representing the IP address from which the request originated.
 * - user_agent: Captures the user agent string from the request headers, identifying the 
 *   client software or device making the request.
 * - request_count: The total number of requests for each unique combination of tenant ID, 
 *   client IP address, and user agent, providing insight into interaction volume.
 * 
 * CTE (Common Table Expression):
 * - The CTE (`cte`) is used to extract the client IP address from the 'x-forwarded-for' header 
 *   if available, falling back to NULL if not. It also filters out requests with a user agent of 
 *   'httpyac' to ensure that only relevant requests are included in the summary.
 * 
 * Filtering:
 * - URI: The view includes only interactions with the URIs '/Bundle' or '/Bundle/'.
 * - Nature: It specifically targets interactions categorized as 'org.techbd.service.http.Interactions$RequestResponseEncountered'.
 * - User Agent: Requests with a user agent of 'httpyac' are excluded to focus on interactions from other sources.
 * - Time Frame: The view is restricted to interactions that occurred within the last 7 days, ensuring the summary is recent and relevant.
 * 
 * Grouping and Ordering:
 * - The results are grouped by tenant_id, client_ip_address, and user_agent to provide a breakdown 
 *   of request counts for each combination.
 * - The final output is ordered by tenant_id, client_ip_address, and user_agent to facilitate 
 *   easy identification of patterns across tenants and clients.
 * 
 * Utility:
 * - This view is useful for system administrators and security analysts who need to monitor and 
 *   analyze HTTP request patterns. By summarizing interaction data based on key factors like 
 *   client IP and user agent, it helps in identifying trends, potential issues, or unauthorized access attempts.
 * 
 * @return VIEW - A summarized view of HTTP request interactions with counts of requests per tenant ID, client IP address, and user agent.
 */


DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_request_summary CASCADE; 
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_request_summary
AS 
WITH cte AS (
    SELECT tenant_id_lower,
           client_ip_address,
           user_agent
    FROM techbd_udi_ingress.sat_interaction_fhir_request
    WHERE nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered'
      AND uri != '/api/expect/fhir/bundle'
      AND user_agent <> 'httpyac'
      AND created_at >= CURRENT_DATE - INTERVAL '7 days' 
)
SELECT tenant_id_lower,
       client_ip_address,
       user_agent,
       COUNT(*) AS request_count
FROM cte
GROUP BY tenant_id_lower, client_ip_address, user_agent
ORDER BY tenant_id_lower, client_ip_address, user_agent;
  

/**
 * View to summarize detailed HTTP request interactions including tenant, client IP, and user agent.
 *
 * This view provides a detailed summary of HTTP request interactions over the past 7 days,
 * capturing essential information such as tenant ID, client IP address, user agent, 
 * hub interaction ID, and the request creation timestamp. This detailed view is valuable 
 * for tracking individual requests and their origins, which can be used for troubleshooting, 
 * auditing, and monitoring purposes.
 * 
 * Key components:
 * - tenant_id: Identifies the tenant responsible for each HTTP request.
 * - client_ip_address: Extracted from the 'x-forwarded-for' header within the request's payload,
 *   representing the IP address from which the request originated. If the header is not present, 
 *   this field will be NULL.
 * - user_agent: Captures the user agent string from the request headers, identifying the 
 *   client software or device making the request.
 * - hub_interaction_id: A unique identifier for each hub interaction, allowing for precise 
 *   tracking and correlation of requests.
 * - request_created_at: The timestamp of when the request was created, providing chronological 
 *   context for the interactions.
 *
 * CTE (Common Table Expression):
 * - The CTE (`cte`) is used to extract and filter the relevant data from the 
 *   `interaction_http_request_mat` table. It includes logic to extract the client IP 
 *   address from the 'x-forwarded-for' header, filter out requests with a user agent 
 *   of 'httpyac', and limit the data to interactions that occurred in the past 7 days.
 * 
 * Filtering:
 * - URI: The view includes only interactions with the URIs '/Bundle' or '/Bundle/'.
 * - Nature: It specifically targets interactions categorized as 
 *   'org.techbd.service.http.Interactions$RequestResponseEncountered'.
 * - User Agent: Requests with a user agent of 'httpyac' are excluded to focus on interactions 
 *   from other sources.
 * - Time Frame: The view is restricted to interactions that occurred within the last 7 days, 
 *   ensuring the summary is recent and relevant.
 * 
 * Ordering:
 * - The results are ordered by the `request_created_at` field in descending order, 
 *   ensuring that the most recent interactions are displayed first.
 *
 * Utility:
 * - This view is particularly useful for administrators and security analysts who need to 
 *   monitor detailed HTTP request interactions. By capturing and organizing data based on 
 *   key factors like tenant ID, client IP, and user agent, it helps in identifying patterns, 
 *   diagnosing issues, and ensuring compliance with security and operational standards.
 *
 * @return VIEW - A detailed summary of HTTP request interactions including tenant, client IP, user agent, hub interaction ID, and request timestamp.
 */


DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_request_summary_details CASCADE; 
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_request_summary_details
AS 
WITH cte AS (
    SELECT tenant_id_lower,
           client_ip_address,
           user_agent,
          hub_interaction_id,  
          created_at         
    FROM techbd_udi_ingress.sat_interaction_fhir_request
    WHERE nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered'
      AND uri != '/api/expect/fhir/bundle'
      AND user_agent <> 'httpyac'
      AND created_at >= CURRENT_DATE - INTERVAL '7 days'  
)
SELECT tenant_id_lower,
       client_ip_address,
       user_agent,
       hub_interaction_id,
       created_at as request_created_at
FROM cte
ORDER BY request_created_at DESC;



/*******************************************************************************************************************************
 * Function to upsert user details related to an HTTP interaction, ensuring the associated hub interaction record exists and 
 * handling exceptions by logging them when necessary.
 *
 * @param hub_interaction_id TEXT - The unique ID for the associated hub interaction.
 * @param hub_interaction_key TEXT - A key to identify the associated hub interaction.
 * @param user_id TEXT - The ID of the user involved in the interaction.
 * @param user_name TEXT - The name of the user involved in the interaction.
 * @param user_session TEXT - The session identifier of the user involved in the interaction.
 * @param user_role TEXT - The role of the user involved in the interaction.
 * @param tenant_id TEXT (nullable) - The tenant ID associated with the interaction. Default is NULL.
 * @param elaboration JSONB (nullable) - Additional JSON data elaborating the user interaction. Default is NULL.
 * @param created_at TIMESTAMPTZ (nullable) - The creation timestamp of the record. Defaults to the current timestamp if NULL.
 * @param created_by TEXT (nullable) - The user who created the record. Defaults to the current user if NULL.
 * @param provenance TEXT (nullable) - The provenance of the record. Defaults to 'unknown' if NULL.
 * 
 * @returns TEXT - Returns the unique ID of the newly inserted or upserted user interaction record.
 *
 * The function performs the following actions:
 * 1. Verifies the existence of the hub interaction record associated with the provided `hub_interaction_id` and `hub_interaction_key`.
 *    If the record does not exist, the function returns NULL.
 * 2. Inserts a new record into the `sat_interaction_user` table, capturing user details along with the associated tenant and
 *    elaboration information.
 * 3. Handles any exceptions that occur during the process by logging the details of the error using the `register_issue` function.
 *    In the event of an error, the function returns NULL.
 *******************************************************************************************************************************/

DROP FUNCTION IF EXISTS techbd_udi_ingress.sat_interaction_user_upserted(text, text, text, jsonb, text, text, text, text, text, jsonb, timestamptz, text, text);
CREATE OR REPLACE FUNCTION techbd_udi_ingress.sat_interaction_user_upserted(hub_interaction_id text, hub_interaction_key text, nature text, payload jsonb, user_id text, user_name text, user_session text, user_role text, tenant_id text DEFAULT NULL::text, elaboration jsonb DEFAULT NULL::jsonb, created_at timestamp with time zone DEFAULT NULL::timestamp with time zone, created_by text DEFAULT NULL::text, provenance text DEFAULT NULL::text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_at 					TIMESTAMPTZ := COALESCE(created_at, CURRENT_TIMESTAMP);
    v_created_by 					TEXT := COALESCE(created_by, current_user);
    v_provenance 					TEXT := COALESCE(provenance, 'unknown');
    v_exception_id 					TEXT;
   	v_hub_interaction_key 			TEXT;
   	v_return						TEXT;
   	v_client_ip_address				TEXT;
   	v_client_ip_address_forwarded	TEXT;
   	v_user_agent		    		TEXT;
   	v_intr_start_time 				TIMESTAMPTZ := NULL;
   	v_intr_finish_time 				TIMESTAMPTZ := NULL;

BEGIN
    -- Verify hub_interaction details
   	SELECT t."key" INTO v_hub_interaction_key
  	FROM techbd_udi_ingress.hub_interaction t
  	WHERE t.hub_interaction_id = sat_interaction_user_upserted.hub_interaction_id 
  	AND t."key" = sat_interaction_user_upserted.hub_interaction_key;

  	IF(v_hub_interaction_key IS NULL) THEN
  		RETURN NULL;	
  	END IF;
  	
  	-- Extract Observability Metrics Start and Finish Time
	SELECT
	MAX(CASE WHEN header->>'name' = 'X-Observability-Metric-Interaction-Start-Time' THEN header->>'value' ELSE NULL END),
	MAX(CASE WHEN header->>'name' = 'X-Observability-Metric-Interaction-Finish-Time' THEN header->>'value' ELSE NULL END) 
	INTO v_intr_start_time,v_intr_finish_time
	FROM jsonb_array_elements(sat_interaction_user_upserted.payload->'response'->'headers') AS header
	;

	-- Extract Client IP Address
   	v_client_ip_address := sat_interaction_user_upserted.payload -> 'request'->>'clientIpAddress';

	-- Extract Client IP Address Forwarded
    SELECT h.value ->> 'value'::text INTO v_client_ip_address_forwarded
    FROM jsonb_array_elements((sat_interaction_user_upserted.payload -> 'request'::text) -> 'headers'::text) h(value)
    WHERE (h.value ->> 'name'::text) = 'x-forwarded-for'::text;   
   
   -- Extract User Agent
   	v_user_agent := sat_interaction_user_upserted.payload -> 'request'->>'userAgent';

    INSERT INTO techbd_udi_ingress.sat_interaction_user (
	sat_interaction_user_id
	,hub_interaction_id
	,uri
	,nature
	,tenant_id
	,user_id
	,user_name
	,user_session
	,user_role
	,client_ip_address
	,user_agent
	,elaboration
	,created_at
	,created_by
	,provenance
	,interaction_start_time
	,interaction_end_time
    )
    VALUES (
    gen_random_uuid()::text, 
    sat_interaction_user_upserted.hub_interaction_id,
    v_hub_interaction_key,
    sat_interaction_user_upserted.nature,
    sat_interaction_user_upserted.tenant_id,
    sat_interaction_user_upserted.user_id,
    sat_interaction_user_upserted.user_name,
    sat_interaction_user_upserted.user_session,
    sat_interaction_user_upserted.user_role,        
    COALESCE(v_client_ip_address_forwarded,v_client_ip_address),        
    v_user_agent,      
    sat_interaction_user_upserted.elaboration, 
    v_created_at, 
    v_created_by, 
    v_provenance,
    v_intr_start_time,
    v_intr_finish_time
    ) RETURNING sat_interaction_user_id INTO v_return;

	RETURN v_return;
EXCEPTION
	WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
		    
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		v_hub_interaction_key,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
	RETURN NULL;
END;
$function$
;

DROP VIEW IF EXISTS techbd_udi_ingress.interaction_user_details CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_user_details
AS SELECT sai.created_at,
    sai.hub_interaction_id,
    sai.uri,
    sai.sat_interaction_user_id,
    sai.user_id,
    sai.user_name,
    sai.user_session,
    sai.user_role,
    sai.client_ip_address,
    sai.user_agent
   FROM techbd_udi_ingress.sat_interaction_user sai
  ORDER BY sai.created_at DESC;


DROP VIEW IF EXISTS techbd_udi_ingress.interaction_user_list CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_user_list
AS SELECT min(created_at) AS created_at,
    min(user_id) AS user_id,
    min(user_name) AS user_name,
    min(user_role) AS user_role,
    user_session
   FROM techbd_udi_ingress.interaction_user_details
  WHERE user_session IS NOT NULL
  GROUP BY user_session
  ORDER BY (min(created_at)) DESC;  

/*******************************************************************************************************************************
Procedure to handle the insertion or update of FHIR interaction data, managing default values and error handling.

@param hub_interaction_id TEXT - The unique identifier for the interaction in the hub.
@param tenant_id TEXT - The identifier for the tenant or client.
@param uri TEXT - The URI associated with the FHIR request.
@param nature TEXT - The nature or type of the HTTP interaction.
@param from_state TEXT - The state before the interaction occurred.
@param to_state TEXT - The state after the interaction.
@param payload JSONB - The JSON payload containing the details of the interaction.
@param state_transition_reason TEXT (nullable) - The reason for the state transition. Default is NULL.
@param created_at TIMESTAMP WITH TIME ZONE (nullable) - The timestamp of record creation. Defaults to the current timestamp if NULL.
@param created_by TEXT (nullable) - The user who created the record. Defaults to the current user if NULL.
@param provenance TEXT (nullable) - The provenance or source of the record. Defaults to 'unknown' if NULL.
@param elaboration JSONB (nullable) - Additional elaborative JSON data related to the interaction. Default is NULL.
@returns TEXT - A textual representation of the result of the operation, typically used to convey success or error messages. 
 *******************************************************************************************************************************/
DROP FUNCTION IF EXISTS techbd_udi_ingress.sat_interaction_fhir_request_upserted(text, text, text, text, text, text, jsonb, text, timestamptz, text, text, jsonb);
CREATE OR REPLACE FUNCTION techbd_udi_ingress.sat_interaction_fhir_request_upserted(hub_interaction_id text, tenant_id text, uri text, nature text, from_state text, to_state text, payload jsonb, state_transition_reason text DEFAULT NULL::text, created_at timestamp with time zone DEFAULT NULL::timestamp with time zone, created_by text DEFAULT NULL::text, provenance text DEFAULT NULL::text, elaboration jsonb DEFAULT NULL::jsonb)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    -- Declare variables to hold error and extracted data
	v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_at 					TIMESTAMPTZ := COALESCE(created_at, CURRENT_TIMESTAMP);  -- Ensure created_at is not null
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  -- Set default provenance
    v_exception_id 					TEXT;
    
    -- Additional variables for extracting and holding data from the payload JSONB
    v_client_ip_address 			TEXT 	:= NULL;
   	v_client_ip_address_forwarded	TEXT 	:= NULL;
    v_user_agent 					TEXT 	:= NULL;
    v_outbound_http_message 		TEXT 	:= NULL;
    v_error_message 				TEXT 	:= NULL;
    v_issues_count 					INTEGER	:= 0;
   	v_passed 						BOOLEAN	:= NULL;
    v_bundle_id 					TEXT 	:= NULL;
    v_bundle_session_id 			TEXT 	:= NULL;
    v_bundle_last_updated 			TEXT 	:= NULL;
    v_organization_id 				TEXT 	:= NULL;
    v_organization_name 			TEXT 	:= NULL;
    v_patient_id 					TEXT 	:= NULL;
    v_patient_mrn 					TEXT 	:= NULL;
   	v_medicaid_cin 					TEXT 	:= NULL;
   	v_ssn 							TEXT 	:= NULL;
    v_resource_type_set 			TEXT 	:= NULL;   
   	v_validation_initiated_at 		TEXT 	:= NULL;
    v_validation_completed_at 		TEXT 	:= NULL;   
    v_validation_engine 			TEXT 	:= NULL;
   	v_ig_version 					TEXT 	:= NULL;
   	v_profile_url 					TEXT 	:= NULL;
   	v_interaction_start_time 		TEXT 	:= NULL;
   	v_interaction_end_time 			TEXT 	:= NULL;
   	v_duration_millisecs 			TEXT 	:= NULL;
   	v_response_status				TEXT 	:= NULL;
   	v_return 						TEXT 	:= NULL;

BEGIN

   	IF NOT EXISTS(SELECT 1 FROM techbd_udi_ingress.hub_interaction t
  		WHERE t.hub_interaction_id = sat_interaction_fhir_request_upserted.hub_interaction_id 
  		AND t."key" = sat_interaction_fhir_request_upserted.uri) THEN
  		RETURN NULL;	
  	END IF;
  
  	IF(LOWER(sat_interaction_fhir_request_upserted.nature) <> LOWER('org.techbd.service.http.Interactions$RequestResponseEncountered')) THEN
		SELECT 
		fhir_req.client_ip_address,			fhir_req.user_agent, 				fhir_req.bundle_id, 
		fhir_req.bundle_last_updated,		fhir_req.organization_id,			fhir_req.organization_name, 
		fhir_req.patient_id, 				fhir_req.patient_mrn,				fhir_req.resource_type_set, 
		fhir_req.validation_initiated_at, 	fhir_req.validation_completed_at,	fhir_req.validation_engine,
		fhir_req.ig_version,				fhir_req.profile_url,				fhir_req.medicaid_cin,
		fhir_req.interaction_start_time,	fhir_req.interaction_end_time,		fhir_req.bundle_session_id
		INTO 		
		v_client_ip_address,				v_user_agent,						v_bundle_id,
		v_bundle_last_updated,				v_organization_id,					v_organization_name,
		v_patient_id,						v_patient_mrn,						v_resource_type_set,
		v_validation_initiated_at,			v_validation_completed_at,			v_validation_engine,
		v_ig_version,						v_profile_url,						v_medicaid_cin,
		v_interaction_start_time,			v_interaction_end_time,				v_bundle_session_id 	
		FROM
		techbd_udi_ingress.sat_interaction_fhir_request fhir_req
		WHERE 1 = 1
		AND fhir_req.hub_interaction_id = sat_interaction_fhir_request_upserted.hub_interaction_id
		AND fhir_req.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered';	
  	END IF;  	

	IF(LOWER(sat_interaction_fhir_request_upserted.nature) = LOWER('org.techbd.service.http.Interactions$RequestResponseEncountered')) THEN				   
    	
		v_user_agent 				:= sat_interaction_fhir_request_upserted.payload->'request'->>'userAgent';    
    	v_client_ip_address 		:= sat_interaction_fhir_request_upserted.payload->'request'->>'clientIpAddress';    
    	v_issues_count 				:= jsonb_array_length((((((sat_interaction_fhir_request_upserted.payload -> 'response'::text) -> 'responseBody'::text) -> 'OperationOutcome'::text) -> 'validationResults'::text) -> 0) -> 'issues'::text);			
    	v_outbound_http_message 	:= "substring"((((sat_interaction_fhir_request_upserted.payload -> 'response'::text) -> 'responseBody'::text) -> 'OperationOutcome'::text) ->> 'outboundHttpMessage'::text, 'POST[^\n]+'::text);   	
		v_bundle_session_id 		:= sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->>'bundleSessionId';	 				  
    	v_validation_engine 		:= (sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->'validationResults'->0->'observability'->>'name');    
    	v_ig_version				:= (sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->'validationResults'->0->>'igVersion');        
    	v_profile_url				:= (sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->'validationResults'->0->>'profileUrl');      
    	v_validation_initiated_at 	:= to_timestamp((sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->'validationResults'->0->>'initiatedAt')::NUMERIC);
    	v_validation_completed_at 	:= to_timestamp((sat_interaction_fhir_request_upserted.payload->'response'->'responseBody'->'OperationOutcome'->'validationResults'->0->>'completedAt')::NUMERIC);
    	
    	SELECT hdrs->>'value'
		INTO v_client_ip_address_forwarded
    	FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'request'->'headers') AS hdrs
    	WHERE hdrs->>'name' = 'x-forwarded-for'
    	;
    
    	-- Extract the value of X-Observability-Metric-Interaction-Start-Time
		SELECT header->>'value' 
		INTO v_interaction_start_time
		FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'response'->'headers') AS header
		WHERE header->>'name' = 'X-Observability-Metric-Interaction-Start-Time';			
	
		-- Extract the value of X-Observability-Metric-Interaction-Finish-Time
		SELECT header->>'value' 
		INTO v_interaction_end_time
		FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'response'->'headers') AS header
		WHERE header->>'name' = 'X-Observability-Metric-Interaction-Finish-Time';

	    SELECT entry->'resource'->>'id'
	    INTO v_patient_id
	    FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->'entry') AS entry
	    WHERE entry->'resource'->>'resourceType' = 'Patient'
	    LIMIT 1;
	   	   		   
	    SELECT 
	    identifier_element->>'value', 
	    regexp_replace(identifier_element->'assigner'->>'reference','^Organization/', '') 
	    INTO v_patient_mrn, v_organization_id
	    FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->'entry') AS entry,
	    jsonb_array_elements(entry->'resource'->'identifier') AS identifier_element
	    WHERE entry->'resource'->>'resourceType' = 'Patient'
	    AND identifier_element #>> '{type, coding, 0, code}' = 'MR'
	    LIMIT 1;	  	   
	  
	  	SELECT entry.value->'resource'->>'name' 
	  	INTO v_organization_name
    	FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->'entry') AS entry(value)
   	 	WHERE 
        entry.value->'resource'->>'resourceType' = 'Organization' 
        AND entry.value->'resource'->>'id' = v_organization_id;
   	          
	    SELECT identifier_element->>'value'
	    INTO v_medicaid_cin
	   	FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->'entry') AS entry,
		jsonb_array_elements(entry->'resource'->'identifier') AS identifier_element
		WHERE entry->'resource'->>'resourceType' = 'Patient'
		AND identifier_element #>> '{type, coding, 0, code}' = 'MA'
		LIMIT 1;	   	   			   	
	   	
	   	SELECT
        sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->>'id',
        sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->'meta'->>'lastUpdated'
        INTO v_bundle_id, v_bundle_last_updated
   	 	WHERE
        sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->>'resourceType' = 'Bundle'
       	LIMIT 1;		
	
		SELECT STRING_AGG(DISTINCT entry->'resource'->>'resourceType', ', ') 
		INTO v_resource_type_set
		FROM jsonb_array_elements(sat_interaction_fhir_request_upserted.payload->'request'->'requestBody'->'entry') AS entry
		WHERE entry ? 'resource';		
	
	END IF; /*End of : org.techbd.service.http.Interactions$RequestResponseEncountered*/

	IF(LOWER(sat_interaction_fhir_request_upserted.nature) IN(lower('Forwarded HTTP Response Error'), LOWER('Forwarded HTTP Response'), LOWER('Forward HTTP Request'))) THEN
		
		IF(LOWER(sat_interaction_fhir_request_upserted.nature) = lower('Forwarded HTTP Response Error')) THEN
			v_passed := FALSE;
			v_error_message := SUBSTRING(payload ->> 'error'::text FROM POSITION((':'::text) IN (sat_interaction_fhir_request_upserted.payload ->> 'error'::text)) + 2);				
		END IF;
			
		IF(LOWER(sat_interaction_fhir_request_upserted.nature) = lower('Forwarded HTTP Response')) THEN	
			v_response_status := substring(sat_interaction_fhir_request_upserted.payload->> 'scoredcardResponse' FROM 'TestResult:\s*(\w+)');					
			IF v_response_status IS NOT NULL AND v_response_status = 'PASS' THEN
			    v_passed := TRUE;
			ELSE
				IF v_error_message IS NULL THEN 
					v_error_message := sat_interaction_fhir_request_upserted.payload->> 'insertScreeningsResponse';
					SELECT INTO v_issues_count (regexp_matches(v_error_message, 'An unexpected error occurred: (\d+)'))[1]::INTEGER;
				ELSE					
					v_error_message := substring(sat_interaction_fhir_request_upserted.payload->> 'scoredcardResponse' FROM 'Exception:\s*(.*)$');
					SELECT INTO v_issues_count (regexp_matches(v_error_message, 'An unexpected validation error occurred parsing FHIR: (\d+)'))[1]::INTEGER;
				END IF;				
			    v_passed := FALSE;
			END IF;
		END IF;		
			
	END IF; /*End of: Forwarded HTTP Response Error. Forwarded HTTP Response*/
	
	BEGIN
		v_bundle_last_updated := v_bundle_last_updated::TIMESTAMPTZ;
	EXCEPTION
	    WHEN others THEN v_bundle_last_updated := NULL;  -- Set to NULL if it's an invalid timestamp
	END;

    -- The INSERT statement inserts a new record into the sat_interaction_fhir_request table, generating a UUID for the primary key.
    -- Extracted and transformed values from the payload JSONB are inserted into corresponding columns.
    -- If the operation succeeds, the generated UUID is returned.
    INSERT INTO techbd_udi_ingress.sat_interaction_fhir_request (
        sat_interaction_fhir_request_id,
        hub_interaction_id,
        tenant_id,
        tenant_id_lower,
        uri,
        nature,
        payload,
        client_ip_address,
        user_agent,
        from_state,
        to_state,
        state_transition_reason,
        outbound_http_message,
        error_message,
        issues_count,
        bundle_id,
        bundle_session_id,
        bundle_last_updated,
        organization_id,
        organization_name,
        patient_id,
        patient_mrn,
        resource_type_set,
        validation_initiated_at,
        validation_completed_at,
        validation_engine,
        elaboration,
        created_by,
        provenance,
        ig_version,
        profile_url,
        passed,
        medicaid_cin,
        interaction_start_time,
        interaction_end_time
    )
    VALUES (
        gen_random_uuid()::TEXT,  -- Generate a unique UUID for the primary key
        hub_interaction_id,
        tenant_id,
        LOWER(tenant_id),  -- Store the tenant ID in lowercase for consistency
        uri,
        nature,
        payload,
        COALESCE(v_client_ip_address_forwarded,v_client_ip_address),
        COALESCE(v_user_agent,''),
        from_state,
        to_state,
        state_transition_reason,
        v_outbound_http_message,
        v_error_message,
        COALESCE(v_issues_count,0),
        v_bundle_id,
        v_bundle_session_id,
        COALESCE(NULLIF(v_bundle_last_updated, '')::TIMESTAMPTZ, NULL),
        v_organization_id,
        v_organization_name,
        v_patient_id,
        v_patient_mrn,
        v_resource_type_set,
        COALESCE(v_validation_initiated_at::TIMESTAMPTZ,NULL),
        COALESCE(v_validation_completed_at::TIMESTAMPTZ,NULL),
        v_validation_engine,
        sat_interaction_fhir_request_upserted.elaboration,
        created_by,
        provenance,
        v_ig_version,
        v_profile_url,
        v_passed,
        v_medicaid_cin,
        COALESCE(v_interaction_start_time::TIMESTAMPTZ,NULL),
        COALESCE(v_interaction_end_time::TIMESTAMPTZ,NULL)
    ) RETURNING sat_interaction_fhir_request_id INTO v_return;  -- Return the generated UUID

    IF (v_return IS NOT NULL) THEN
        IF(uri='/Bundle' OR uri='/Bundle/') THEN
            CALL techbd_udi_ingress.insert_fhir_session_diagnostic(
                hub_interaction_id, 
                tenant_id, 
                uri, 
                v_bundle_session_id, 
                payload, 
                created_by, 
                provenance,
                sat_interaction_fhir_request_upserted.elaboration
            );
            IF(LOWER(sat_interaction_fhir_request_upserted.nature) = LOWER('techByDesignDisposition')) THEN
                CALL techbd_udi_ingress.insert_validation_issues(
                    hub_interaction_id, 
                    uri, 
                    payload, 
                    created_by, 
                    provenance,
                    sat_interaction_fhir_request_upserted.elaboration
                );
            END IF;              
            IF(LOWER(sat_interaction_fhir_request_upserted.nature) = LOWER('Original FHIR Payload')) THEN
                CALL techbd_udi_ingress.insert_fhir_screening_info(
                    hub_interaction_id, 
                    tenant_id, 
                    uri, 
                    v_created_at, 
                    payload,
                    created_by, 
                    provenance,
                    sat_interaction_fhir_request_upserted.elaboration
                );
                CALL techbd_udi_ingress.insert_fhir_screening_patient(
                    hub_interaction_id, 
                    tenant_id, 
                    uri, 
                    v_created_at, 
                    payload,
                    created_by, 
                    provenance,
                    sat_interaction_fhir_request_upserted.elaboration
                );
                CALL techbd_udi_ingress.insert_fhir_screening_organization(
                    hub_interaction_id, 
                    tenant_id, 
                    uri, 
                    v_created_at, 
                    payload,
                    created_by, 
                    provenance,
                    sat_interaction_fhir_request_upserted.elaboration
                );
            END IF;                  
        END IF;         
    END IF;        

    RETURN v_return;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    --RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		sat_interaction_fhir_request_upserted.uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
		RETURN NULL;
END;
$function$
;
/*******************************************************************************************
  This view provides a consolidated view of failed HTTP requests and associated interactions.
******************************************************************************************/
DROP VIEW IF EXISTS techbd_udi_ingress.interaction_http_request_forward_failure;
CREATE OR REPLACE VIEW techbd_udi_ingress.interaction_http_request_forward_failure
AS SELECT sat_interaction_fhir_request_id,
    hub_interaction_id AS interaction_id,
    tenant_id,
    uri,
    nature,
    created_at AS interaction_created_at,
    created_by AS interaction_created_by,
    provenance AS interaction_provenance,
    client_ip_address,
    user_agent,
    from_state,
    to_state,
    outbound_http_message,
    error_message AS error,
    issues_count,
    resource_type_set AS resource_types,
    patient_id,
    payload,
    patient_mrn,
    concat_ws('-'::text, tenant_id, organization_id, patient_mrn) AS source_mrn,
    (SELECT string_agg(concat_ws(': ', key, COALESCE(value, 'NULL')), ', ') FROM jsonb_each_text((payload->>'responseBody')::jsonb) AS json_data(key, value)) AS response_body_details
   FROM techbd_udi_ingress.sat_interaction_fhir_request intr_hreq
WHERE to_state = 'FAIL'::text;

/*******************************************************************************************************************************
Function to process a set of JSON action rules on a given JSON input.

Parameters:
input_json    - The JSONB input on which the rules will be applied (JSONB)
rule_namespace- The namespace for selecting action rules (TEXT)
key           - A unique key to validate the process (TEXT)
created_by    - The user who triggered the function (optional, default is NULL) (TEXT)
provenance    - The origin of the data or process (optional, default is NULL) (TEXT)

Returns:
Modified JSONB after applying the action rules.
*******************************************************************************************************************************/
DROP FUNCTION IF EXISTS techbd_udi_ingress.process_json_action_rules(jsonb,text,text,text,text);
CREATE OR REPLACE FUNCTION techbd_udi_ingress.process_json_action_rules(input_json jsonb, rule_namespace text, key text, created_by text DEFAULT NULL::text, provenance text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_current_rule 		RECORD;
    v_temp_json 		JSONB := process_json_action_rules.input_json;
    v_json_value 		JSONB;
   	v_json_path 		TEXT;
   	v_found_flag   		BOOLEAN;
   	v_new_action    	JSONB;
   	v_error_msg 		TEXT;
    v_error_type 		TEXT;
    v_sqlstate 			TEXT;
    v_pg_detail 		TEXT;
    v_pg_hint 			TEXT;
    v_pg_context 		TEXT;
   	v_issue_message		TEXT;
   	v_message_path		TEXT;
   	v_action_payload	JSONB;
    v_is_accept_flag	NUMERIC := 1;
BEGIN	
    v_temp_json := process_json_action_rules.input_json;

	IF(process_json_action_rules.key IS NULL) THEN
		RETURN NULL;	
	END IF;
    -- Loop through each row of json_action_rule within the given namespace
    FOR v_current_rule IN 
        SELECT json_path, action, reject_json, modify_json, condition, priority, "namespace" 
        FROM techbd_udi_ingress.json_action_rule 
        WHERE (namespace = process_json_action_rules.rule_namespace OR process_json_action_rules.rule_namespace IS NULL)
        ORDER BY priority DESC -- Apply rules in order of priority
    LOOP
		 -- Check if the json_path starts with '$.'
        IF LEFT(v_current_rule.json_path, 2) = '$.' THEN
            v_json_path := v_current_rule.json_path;
        ELSE
            v_json_path := '$.' || v_current_rule.json_path;
        END IF;
		
	     -- Check if the json_path content exists in v_temp_json
        v_found_flag := jsonb_path_exists( v_temp_json, v_json_path::jsonpath); -- Casting to jsonpath;   

		IF v_found_flag = false THEN
			CONTINUE;
		END IF; 
	
		IF v_current_rule.action = 'reject' THEN  					                                    	         
		
			-- Dynamically build the path to extract the "message" based on v_json_path
            v_message_path := v_json_path || '.message';          

            -- Retrieve the corresponding "message" value dynamically using v_message_path
            SELECT jsonb_path_query(v_temp_json, v_message_path::jsonpath) 
            INTO v_issue_message;   
           
            IF v_issue_message IS NULL THEN
           		SELECT jsonb_path_query(v_temp_json, v_json_path::jsonpath) 
            	INTO v_issue_message;   
            END IF;
           
            v_action_payload := jsonb_build_object('description', v_current_rule."namespace", 'message', v_issue_message);
		
            v_new_action := jsonb_build_object(
                'action', 'reject',
                'actionPayload', COALESCE(v_current_rule.reject_json, v_action_payload) -- Including reject_json as JSONB
            );           
           	
            -- Check if 'techByDesignDisposition' exists in response->responseBody->OperationOutcome
            IF v_temp_json->'response'->'responseBody'->'OperationOutcome' ? 'techByDesignDisposition' THEN
                -- Append to existing array
                v_temp_json := jsonb_set(
                    v_temp_json,
                    '{response,responseBody,OperationOutcome,techByDesignDisposition}',
                    (v_temp_json->'response'->'responseBody'->'OperationOutcome'->'techByDesignDisposition') || v_new_action
                );
            ELSE
                -- Create the array and add the new action
                v_temp_json := jsonb_set(
                    v_temp_json,
                    '{response,responseBody,OperationOutcome,techByDesignDisposition}', 
                    jsonb_build_array(v_new_action)
                );
            END IF;
           
            -- If any 'reject' rule is found, then set the v_is_accept_flag to 0, means it is not fully accepted
            v_is_accept_flag := 0;
		END IF;           
	
		-- Update the last_applied_at for the rule
		UPDATE techbd_udi_ingress.json_action_rule
			SET last_applied_at = current_timestamp
				WHERE json_path = v_current_rule.json_path 
					AND namespace = process_json_action_rules.rule_namespace;
				
		-- Initialize the varible with default values; 
		v_found_flag 		:= FALSE;
		v_json_path			:= NULL;
		v_new_action		:= NULL;
		v_message_path		:= NULL;
		v_action_payload	:= NULL;
    END LOOP;

    /*If all the selected rules are accepted, then add techByDesignDisposition tag with 'accepted'*/
    IF v_is_accept_flag = 1 THEN 
    	v_new_action := jsonb_build_object(
                'action', 'accept'
            );
   
	   IF v_temp_json->'response'->'responseBody'->'OperationOutcome' ? 'techByDesignDisposition' THEN
	        -- Append to existing array
	        v_temp_json := jsonb_set(
	            v_temp_json,
	            '{response,responseBody,OperationOutcome,techByDesignDisposition}',
	            (v_temp_json->'response'->'responseBody'->'OperationOutcome'->'techByDesignDisposition') || v_new_action
	        );
	    ELSE
	        -- Create the array and add the new action
	        v_temp_json := jsonb_set(
	            v_temp_json,
	            '{response,responseBody,OperationOutcome,techByDesignDisposition}', 
	            jsonb_build_array(v_new_action)
	        );
	    END IF;
    END IF;                      
   
    -- Return the modified JSON
    RETURN v_temp_json;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		PERFORM techbd_udi_ingress.register_issue(
        NULL,
		process_json_action_rules.interaction_key,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		process_json_action_rules.created_by,
		process_json_action_rules.provenance);
		RETURN NULL;
END;
$function$
;

/*******************************************************************************************************************************
Procedure for inserting FHIR session diagnostic data extracted from a JSONB payload.

Parameters:
hub_interaction_id  - Unique identifier of the hub interaction (UUID)
tenant_id           - Unique identifier of the tenant (UUID)
uri                 - URI associated with the FHIR session (TEXT)
v_bundle_session_id - Unique identifier of the bundle session (UUID)
payload             - JSONB object containing the FHIR response and validation results (JSONB)
created_by          - Identifier of the user or system creating the record (TEXT)
provenance          - Metadata providing the provenance or origin of the interaction (TEXT)

Returns:
No return value. Inserts diagnostic records into the 'sat_interaction_fhir_session_diagnostic' table for each issue found in the payload.
*******************************************************************************************************************************/
DROP PROCEDURE IF EXISTS techbd_udi_ingress.insert_fhir_session_diagnostic(text,text,text,text,jsonb,text,text);
CREATE OR REPLACE PROCEDURE techbd_udi_ingress.insert_fhir_session_diagnostic(
    IN hub_interaction_id TEXT,
    IN tenant_id TEXT,
    IN uri TEXT,
    IN bundle_session_id TEXT,
    IN payload JSONB,
    IN created_by TEXT,
    IN provenance TEXT,
    IN elaboration JSONB
)
LANGUAGE plpgsql
AS $$
DECLARE
    session_diagnostic_set          RECORD;
    v_exception_id 	                TEXT;
    v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  
BEGIN
    -- Extract values from the JSONB payload variable
    FOR session_diagnostic_set IN
        SELECT
            issue.value ->> 'severity'::text AS severity,
            issue.value ->> 'message'::text AS message,
            (issue.value -> 'location'::text) ->> 'line'::text AS line,
            (issue.value -> 'location'::text) ->> 'column'::text AS "column",
            (issue.value -> 'location'::text) ->> 'diagnostics'::text AS diagnostics,
            (insert_fhir_session_diagnostic.payload -> 'response'::text) ->> 'encounteredAt'::text AS encounteredAt,
            insert_fhir_session_diagnostic.elaboration
        FROM LATERAL jsonb_array_elements(
            (((insert_fhir_session_diagnostic.payload -> 'response'::text) -> 'responseBody'::text) -> 'OperationOutcome'::text) -> 'validationResults'::text
        ) validationresult(value),
        LATERAL jsonb_array_elements(validationresult.value -> 'issues'::text) issue(value)
    LOOP
        -- Insert extracted data into the target table
        INSERT INTO techbd_udi_ingress.sat_interaction_fhir_session_diagnostic (
            sat_interaction_fhir_session_diagnostic_id,
            hub_interaction_id,
            tenant_id,
            uri,
            session_id,
            severity,
            message,
            "line",
            "column",
            diagnostics,
            encountered_at,
            elaboration,
            created_by,
            provenance
        )
        VALUES (
            gen_random_uuid()::TEXT, 
            insert_fhir_session_diagnostic.hub_interaction_id,
            insert_fhir_session_diagnostic.tenant_id,
            insert_fhir_session_diagnostic.uri,
            insert_fhir_session_diagnostic.bundle_session_id,
            session_diagnostic_set.severity,
            session_diagnostic_set.message,
            session_diagnostic_set.line,
            session_diagnostic_set.column,
            session_diagnostic_set.diagnostics,
            session_diagnostic_set.encounteredAt,
            session_diagnostic_set.elaboration,
            insert_fhir_session_diagnostic.created_by,
            insert_fhir_session_diagnostic.provenance
        );
    END LOOP;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    -- RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		insert_fhir_session_diagnostic.uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
END;
$$;

DROP PROCEDURE IF EXISTS techbd_udi_ingress.insert_fhir_screening_info(text,text,text,TIMESTAMPTZ,jsonb,text,text,jsonb);
CREATE OR REPLACE PROCEDURE techbd_udi_ingress.insert_fhir_screening_info (
    IN hub_interaction_id TEXT,
    IN tenant_id TEXT,
    IN uri TEXT,
    IN created_at TIMESTAMPTZ,
    IN payload JSONB,
    IN created_by TEXT,
    IN provenance TEXT,
    IN elaboration JSONB
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_exception_id 	                TEXT;
    v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  
BEGIN
    INSERT INTO techbd_udi_ingress.sat_interaction_fhir_screening_info (
        sat_interaction_fhir_screening_info_id,
        hub_interaction_id,
        qe_name,
        submitted_date_time,
        survey_date_time,
        patient_mrn,
        full_name,
        last_name,
        first_name,
        org_id,
        org_name,
        areas_of_interest,
        total_safety_score,
        elaboration,
        created_by,
        provenance
    )
    SELECT 
        gen_random_uuid()::TEXT,
        insert_fhir_screening_info.hub_interaction_id,
        insert_fhir_screening_info.tenant_id,
        insert_fhir_screening_info.created_at,
        CASE
            WHEN (insert_fhir_screening_info.payload ->> 'resourceType' = 'Bundle') THEN (insert_fhir_screening_info.payload -> 'meta' ->> 'lastUpdated')
            ELSE NULL
        END AS survey_date_time,
        (SELECT (((entry.value -> 'resource') -> 'identifier') -> 0) ->> 'value'
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Patient'
         LIMIT 1) AS patient_mrn,
        (SELECT (((entry.value -> 'resource') -> 'name') -> 0) ->> 'text'
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Patient'
         LIMIT 1) AS full_name,
        (SELECT (((entry.value -> 'resource') -> 'name') -> 0) ->> 'family'
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Patient'
         LIMIT 1) AS last_name,
        (SELECT array_to_string(ARRAY(SELECT jsonb_array_elements_text((((entry.value -> 'resource') -> 'name') -> 0) -> 'given')), ' ')
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Patient'
         LIMIT 1) AS first_name,
        (SELECT string_agg((entry.value -> 'resource') ->> 'id', ', ')
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Organization'
         LIMIT 1) AS org_id,
        (SELECT string_agg((entry.value -> 'resource') ->> 'name', ', ')
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Organization'
         LIMIT 1) AS org_name,
        (SELECT string_agg(DISTINCT coding.value ->> 'display', ', ')
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
             JOIN LATERAL jsonb_array_elements((entry.value -> 'resource') -> 'category') category(value) ON true
             JOIN LATERAL jsonb_array_elements(category.value -> 'coding') coding(value) ON true
          WHERE ((entry.value -> 'resource') ->> 'resourceType') = 'Observation' AND (coding.value ->> 'system') = 'http://hl7.org/fhir/us/sdoh-clinicalcare/CodeSystem/SDOHCC-CodeSystemTemporaryCodes'
         LIMIT 1) AS areas_of_interest,
        (SELECT value_coding.value ->> 'display'
           FROM jsonb_array_elements(insert_fhir_screening_info.payload -> 'entry') entry(value)
             JOIN LATERAL jsonb_array_elements(((entry.value -> 'resource') -> 'code') -> 'coding') code_coding(value) ON true
             JOIN LATERAL jsonb_array_elements(((entry.value -> 'resource') -> 'valueCodeableConcept') -> 'coding') value_coding(value) ON true
          WHERE (code_coding.value ->> 'display') = 'Total Safety Score' AND (value_coding.value ->> 'code') = '{score}'
         LIMIT 1) AS total_safety_score,
        insert_fhir_screening_info.elaboration,
        insert_fhir_screening_info.created_by,
        insert_fhir_screening_info.provenance;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    -- RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		insert_fhir_screening_info.uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
END;         
$$;

DROP PROCEDURE IF EXISTS techbd_udi_ingress.insert_validation_issues(text,text,jsonb,text,text,jsonb);
CREATE OR REPLACE PROCEDURE techbd_udi_ingress.insert_validation_issues (
    IN hub_interaction_id TEXT,
    IN uri TEXT,
    IN payload JSONB,
    IN created_by TEXT,
    IN provenance TEXT,
    IN elaboration JSONB
)
LANGUAGE plpgsql
AS $$
DECLARE
    issue_set                       RECORD;
    v_exception_id 	                TEXT;
    v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  
BEGIN
    -- Extract values from the JSONB payload variable
    FOR issue_set IN
        SELECT
            jsonb_array_elements(validation_result -> 'issues'::text) AS issue,
            to_timestamp(((validation_result ->> 'completedAt'::text)::numeric)::double precision) AS date_time,
            validation_result ->> 'igVersion'::text AS ig_version,
            TRIM(BOTH FROM regexp_replace(
                (validation_result -> 'observability'::text) ->> 'name'::text, 
                '\(TODO:get from API instead of hard coding\) \(FHIR version 4.0.1\)\s*$'::text, ''::text)) AS validation_engine
        FROM LATERAL jsonb_array_elements(insert_validation_issues.payload -> 'OperationOutcome'-> 'validationResults'::text) validation_result
    LOOP
        -- Insert the extracted data into the target table
        INSERT INTO techbd_udi_ingress.sat_interaction_fhir_validation_issue (
            sat_interaction_fhir_validation_issue_id,
            hub_interaction_id,
            issue,
            date_time,
            validation_engine,
            ig_version,
            elaboration,
            created_by,
            provenance
        )
        VALUES (
            gen_random_uuid()::TEXT, 
            insert_validation_issues.hub_interaction_id,
            issue_set.issue ->> 'message'::text, 
            issue_set.date_time,
            issue_set.validation_engine,
            issue_set.ig_version,
            insert_validation_issues.elaboration,
            v_created_by,
            insert_validation_issues.provenance
        );
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        -- Capture exception details
        GET STACKED DIAGNOSTICS
            v_error_msg = MESSAGE_TEXT,
            v_sqlstate = RETURNED_SQLSTATE,
            v_pg_detail = PG_EXCEPTION_DETAIL,
            v_pg_hint = PG_EXCEPTION_HINT,
            v_pg_context = PG_EXCEPTION_CONTEXT;
            v_error_type = 'SQL';
        
        -- Log the exception, reusing the previous exception ID if it exists
        v_exception_id := techbd_udi_ingress.register_issue(
            COALESCE(v_exception_id, NULL),
            insert_validation_issues.uri,
            v_error_msg,
            v_error_type,
            v_sqlstate,
            v_pg_detail,
            v_pg_hint,
            v_pg_context,
            v_created_by,
            v_provenance
        );
END;       
$$;

/**
* The function techbd_udi_ingress.json_action_rule_upserted is designed to either insert a new record or 
* update an existing record in the json_action_rule table, depending on whether the action_rule_id is provided. 
* If the action_rule_id is not NULL, the function attempts to update the existing record. If action_rule_id is NULL, 
* a new record is inserted with a randomly generated UUID as the primary key.

* The function also handles exception logging. In the event of an error during the execution of an insert or 
* update operation, the exception details are captured, and the issue is logged in a diagnostic table using the * register_issue function.
*/
DROP FUNCTION IF EXISTS techbd_udi_ingress.json_action_rule_upserted(text, text, text, text, jsonb, jsonb, jsonb, int4, text, text, text);
CREATE OR REPLACE FUNCTION techbd_udi_ingress.json_action_rule_upserted(action_rule_id text, namespace text, json_path text, action text, condition jsonb, reject_json jsonb, modify_json jsonb, priority integer, updated_by text, created_by text, provenance text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    -- Declare variables to hold error and extracted data
    v_error_msg                 TEXT;
    v_error_type                TEXT;
    v_sqlstate                  TEXT;
    v_pg_detail                 TEXT;
    v_pg_hint                   TEXT;
    v_pg_context                TEXT;
    v_exception_id              TEXT;
    v_created_by                TEXT        := COALESCE(json_action_rule_upserted.created_by, current_user);  -- Default created_by to the current user if not provided    
    v_updated_by                TEXT        := COALESCE(json_action_rule_upserted.updated_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance                TEXT        := COALESCE(provenance, 'unknown');  -- Set default provenance
    v_return                    TEXT;
    
BEGIN
	
	
    -- First, attempt to update the record if it exists
	IF(json_action_rule_upserted.action_rule_id IS NOT null) THEN

		UPDATE techbd_udi_ingress.json_action_rule
		SET
			"namespace"         = json_action_rule_upserted.namespace,
			json_path           = json_action_rule_upserted.json_path,
			"action"            = json_action_rule_upserted.action,
			"condition"         = json_action_rule_upserted.condition,
			reject_json         = json_action_rule_upserted.reject_json,
			modify_json         = json_action_rule_upserted.modify_json,
			priority            = json_action_rule_upserted.priority,
			updated_at          = CURRENT_TIMESTAMP,
			updated_by          = v_updated_by,
			last_applied_at     = CURRENT_TIMESTAMP,
			provenance          = json_action_rule_upserted.provenance
			WHERE techbd_udi_ingress.json_action_rule.action_rule_id = json_action_rule_upserted.action_rule_id
			RETURNING techbd_udi_ingress.json_action_rule.action_rule_id INTO v_return 
		;	

		RETURN v_return;
	END IF;
   
   	INSERT INTO techbd_udi_ingress.json_action_rule (
        action_rule_id,
        "namespace",
        json_path,
        "action",
        "condition",
        reject_json,
        modify_json,
        priority,
        updated_at,
        updated_by,
        last_applied_at,
        created_at,
        created_by,
        provenance
    ) VALUES (
        gen_random_uuid()::TEXT,
        json_action_rule_upserted.namespace,
        json_action_rule_upserted.json_path,
        json_action_rule_upserted.action,
        json_action_rule_upserted.condition,
        json_action_rule_upserted.reject_json,
        json_action_rule_upserted.modify_json,
        json_action_rule_upserted.priority,
        CURRENT_TIMESTAMP,
        v_updated_by,
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP,
        json_action_rule_upserted.created_by,
        json_action_rule_upserted.provenance
    ) RETURNING json_action_rule.action_rule_id INTO v_return;
   
    -- Return a success message
    RETURN v_return;
EXCEPTION
   WHEN OTHERS THEN
        -- Capture exception details
        GET STACKED DIAGNOSTICS
            v_error_msg = MESSAGE_TEXT,
            v_sqlstate = RETURNED_SQLSTATE,
            v_pg_detail = PG_EXCEPTION_DETAIL,
            v_pg_hint = PG_EXCEPTION_HINT,
            v_pg_context = PG_EXCEPTION_CONTEXT;
        	v_error_type = 'SQL';

        RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
       
        -- Log the exception, reusing the previous exception ID if it exists
        PERFORM techbd_udi_ingress.register_issue(
            COALESCE(v_exception_id,NULL),
            'action_rule',
            v_error_msg,
            v_error_type,
            v_sqlstate,
            v_pg_detail,
            v_pg_hint,
            v_pg_context,
            v_created_by,
            v_provenance);

        RETURN NULL;
END;
$function$
;

DROP PROCEDURE IF EXISTS techbd_udi_ingress.insert_fhir_screening_patient(text,text,text,TIMESTAMPTZ,jsonb,text,text,jsonb);
CREATE OR REPLACE PROCEDURE techbd_udi_ingress.insert_fhir_screening_patient (
    IN hub_interaction_id TEXT,
    IN tenant_id TEXT,
    IN uri TEXT,
    IN created_at TIMESTAMPTZ,
    IN payload JSONB,
    IN created_by TEXT,
    IN provenance TEXT,
    IN elaboration JSONB
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_exception_id 	                TEXT;
    v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  
BEGIN
    WITH filtered_data AS (
        SELECT 
                insert_fhir_screening_patient.hub_interaction_id AS hub_interaction_id,
                insert_fhir_screening_patient.tenant_id AS tenant_id,
                v_created_by,
                v_provenance,
                insert_fhir_screening_patient.elaboration AS elaboration,
                insert_fhir_screening_patient.payload ->> 'created_at' AS created_at,
                (entry.value -> 'resource') ->> 'id' AS patient_id,
                (entry.value -> 'resource') ->> 'resourceType' AS patient_resource_type,
                (((entry.value -> 'resource') -> 'name') -> 0) ->> 'text' AS full_name,
                (((entry.value -> 'resource') -> 'name') -> 0) ->> 'family' AS last_name,
                array_to_string(ARRAY(
                    SELECT jsonb_array_elements_text((((entry.value -> 'resource') -> 'name') -> 0) -> 'given'))
                , ' ') AS first_name,
                (entry.value -> 'resource') ->> 'gender' AS gender,
                (entry.value -> 'resource') ->> 'birthDate' AS birth_date,
                (((entry.value -> 'resource') -> 'address') -> 0) ->> 'text' AS address,
                (((entry.value -> 'resource') -> 'address') -> 0) ->> 'city' AS city,
                (((entry.value -> 'resource') -> 'address') -> 0) ->> 'state' AS state,
                (((entry.value -> 'resource') -> 'address') -> 0) ->> 'postalCode' AS postal_code,
                ((((((entry.value -> 'resource') -> 'communication') -> 0) -> 'language') -> 'coding') -> 0) ->> 'code' AS language,
                (((entry.value -> 'resource') -> 'identifier') -> 0) ->> 'value' AS medical_record_number,
                (((entry.value -> 'resource') -> 'identifier') -> 3) ->> 'value' AS social_security_number,
                array_to_string(ARRAY(
                    SELECT replace((jsonb_array_elements((entry.value -> 'resource') -> 'identifier') -> 'assigner') ->> 'reference', 'Organization/', '')
                    FROM jsonb_array_elements((entry.value -> 'resource') -> 'identifier')
                ), ', ') AS organization_ids
        FROM LATERAL jsonb_array_elements(insert_fhir_screening_patient.payload -> 'entry') entry
        WHERE (entry.value -> 'resource') ->> 'resourceType' = 'Patient'
    )
    INSERT INTO techbd_udi_ingress.sat_interaction_fhir_screening_patient (
        sat_interaction_fhir_screening_patient_id,
        hub_interaction_id,
        qe_name,
        patient_mrn,
        patient_id,
        patient_type,
        patient_full_name,
        patient_first_name,
        patient_last_name,
        patient_gender,
        patient_birth_date,
        patient_address,
        patient_city,
        patient_state,
        patient_postal_code,
        patient_language,
        patient_ssn,
        org_id,
        elaboration,
        created_by,
        provenance
    )
    SELECT gen_random_uuid()::TEXT,
        filtered_data.hub_interaction_id,
        filtered_data.tenant_id,
        filtered_data.medical_record_number,
        filtered_data.patient_id,
        filtered_data.patient_resource_type,
        filtered_data.full_name,
        filtered_data.first_name,
        filtered_data.last_name,
        filtered_data.gender,
        filtered_data.birth_date,
        filtered_data.address,
        filtered_data.city,
        filtered_data.state,
        filtered_data.postal_code,
        filtered_data.language,
        filtered_data.social_security_number,
        filtered_data.organization_ids,
        filtered_data.elaboration,
        filtered_data.v_created_by,
        filtered_data.v_provenance
    FROM filtered_data;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    -- RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		insert_fhir_screening_patient.uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
END;         
$$;

DROP PROCEDURE IF EXISTS techbd_udi_ingress.insert_fhir_screening_organization(text,text,text,TIMESTAMPTZ,jsonb,text,text,jsonb);
CREATE OR REPLACE PROCEDURE techbd_udi_ingress.insert_fhir_screening_organization (
    IN hub_interaction_id TEXT,
    IN tenant_id TEXT,
    IN uri TEXT,
    IN created_at TIMESTAMPTZ,
    IN payload JSONB,
    IN created_by TEXT,
    IN provenance TEXT,
    IN elaboration JSONB
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_exception_id 	                TEXT;
    v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  
BEGIN
    WITH filtered_data AS (
        SELECT 
                insert_fhir_screening_organization.hub_interaction_id AS hub_interaction_id,
                insert_fhir_screening_organization.tenant_id AS tenant_id,
                v_created_by,
                v_provenance,
                insert_fhir_screening_organization.elaboration AS elaboration,
                insert_fhir_screening_organization.payload ->> 'created_at' AS created_at,
                (entry.value -> 'resource'::text) ->> 'id'::text AS org_id,
                (entry.value -> 'resource'::text) ->> 'resourceType'::text AS org_resource_type,
                (entry.value -> 'resource'::text) ->> 'name'::text AS org_name,
                (entry.value -> 'resource'::text) ->> 'active'::text AS org_active,
                (((entry.value -> 'resource'::text) -> 'address'::text) -> 0) ->> 'text'::text AS org_address,
                (((entry.value -> 'resource'::text) -> 'address'::text) -> 0) ->> 'city'::text AS org_city,
                (((entry.value -> 'resource'::text) -> 'address'::text) -> 0) ->> 'state'::text AS org_state,
                (((entry.value -> 'resource'::text) -> 'address'::text) -> 0) ->> 'postalCode'::text AS org_postal_code
        FROM LATERAL jsonb_array_elements(insert_fhir_screening_organization.payload -> 'entry') entry
        WHERE (entry.value -> 'resource') ->> 'resourceType' = 'Organization'
    )
    INSERT INTO techbd_udi_ingress.sat_interaction_fhir_screening_organization (
        sat_interaction_fhir_screening_organization_id,
        hub_interaction_id,
        qe_name,
        org_id,
        org_type,
        org_name,
        org_active,
        org_address,
        org_city,
        org_state,
        org_postal_code,
        elaboration,
        created_by,
        provenance
    )
    SELECT gen_random_uuid()::TEXT,
        filtered_data.hub_interaction_id,
        filtered_data.tenant_id,
        filtered_data.org_id,
        filtered_data.org_resource_type,
        filtered_data.org_name,
        filtered_data.org_active,
        filtered_data.org_address,
        filtered_data.org_city,
        filtered_data.org_state,
        filtered_data.org_postal_code,
        filtered_data.elaboration,
        filtered_data.v_created_by,
        filtered_data.v_provenance
    FROM filtered_data;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    -- RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		insert_fhir_screening_organization.uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
END;         
$$;

/*******************************************************************************************************************************
Function for upserting HL7 interaction request data from a JSONB payload.

Parameters:
hub_interaction_id   - Unique identifier of the hub interaction (TEXT)
tenant_id            - Unique identifier of the tenant (TEXT)
uri                  - URI associated with the HL7 request (TEXT)
nature               - Nature of the interaction request (TEXT)
from_state           - The initial state of the interaction (TEXT)
to_state             - The final state of the interaction after processing (TEXT)
payload              - JSONB object containing the HL7 request data (JSONB), default is NULL
state_transition_reason - Reason for transitioning between states (TEXT), default is NULL
created_at           - Timestamp of when the record was created (TIMESTAMPTZ), defaults to CURRENT_TIMESTAMP if not provided
created_by           - Identifier of the user or system creating the record (TEXT), defaults to the current user if not provided
provenance           - Metadata providing the provenance or origin of the interaction (TEXT), defaults to 'unknown'
elaboration          - JSONB object containing additional details about the interaction (JSONB), default is NULL

Returns:
The function returns the generated UUID of the newly inserted record in the 'sat_interaction_hl7_request' table or NULL if the 
interaction is not valid or the payload is null.

Description:
This function inserts HL7 interaction request data into the 'sat_interaction_hl7_request' table. It ensures that the hub interaction 
exists in the 'hub_interaction' table and that the payload is not null. If both conditions are met, a new record is inserted, 
generating a UUID for the 'sat_interaction_hl7_request_id'. The function also handles exceptions, logging errors with the 
'register_issue' procedure if any SQL or runtime errors occur during the insert operation.
*******************************************************************************************************************************/
DROP FUNCTION IF EXISTS techbd_udi_ingress.sat_interaction_hl7_request_upserted(text, text, text, text, text, text, jsonb, text, timestamp with time zone, text, text, jsonb);

CREATE OR REPLACE FUNCTION techbd_udi_ingress.sat_interaction_hl7_request_upserted(hub_interaction_id text, tenant_id text, uri text, nature text, from_state text, to_state text, payload jsonb DEFAULT NULL::jsonb, state_transition_reason text DEFAULT NULL::text, created_at timestamp with time zone DEFAULT NULL::timestamp with time zone, created_by text DEFAULT NULL::text, provenance text DEFAULT NULL::text, elaboration jsonb DEFAULT NULL::jsonb)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    -- Declare variables to hold error and extracted data
	v_error_msg 					TEXT;
    v_error_type 					TEXT;
    v_sqlstate 						TEXT;
    v_pg_detail 					TEXT;
    v_pg_hint 						TEXT;
    v_pg_context 					TEXT;   
    v_created_at 					TIMESTAMPTZ := COALESCE(created_at, CURRENT_TIMESTAMP);  -- Ensure created_at is not null
    v_created_by 					TEXT 		:= COALESCE(created_by, current_user);  -- Default created_by to the current user if not provided
    v_provenance 					TEXT 		:= COALESCE(provenance, 'unknown');  -- Set default provenance
    v_exception_id 					TEXT;
    
    -- Additional variables for extracting and holding data from the payload JSONB
    v_return 						TEXT 	:= NULL;

BEGIN	
	IF NOT EXISTS(SELECT 1 FROM techbd_udi_ingress.hub_interaction t
  		WHERE t.hub_interaction_id = sat_interaction_hl7_request_upserted.hub_interaction_id 
  		AND t."key" = sat_interaction_hl7_request_upserted.uri) THEN
  		RETURN NULL;	
  	END IF;
  
  	IF sat_interaction_hl7_request_upserted.payload IS NULL THEN
  		RETURN NULL;	
  	END IF;
  
  	-- The INSERT statement inserts a new record into the sat_interaction_hl7_request table, generating a UUID for the primary key.
    -- If the operation succeeds, the generated UUID is returned.
    INSERT INTO techbd_udi_ingress.sat_interaction_hl7_request (
        sat_interaction_hl7_request_id,
        hub_interaction_id,
        tenant_id,
        tenant_id_lower,
        uri,
        nature,
        payload,
        client_ip_address,
        user_agent,
        from_state,
        to_state,
        state_transition_reason,
        created_by,
        provenance,
        elaboration
    )
    VALUES (
        gen_random_uuid()::TEXT,  -- Generate a unique UUID for the primary key
        hub_interaction_id,
        tenant_id,
        LOWER(tenant_id),  -- Store the tenant ID in lowercase for consistency
        uri,
        nature,
        payload,
        null,
        null,
        from_state,
        to_state,
        state_transition_reason,
        created_by,
        provenance,
        elaboration
    ) RETURNING sat_interaction_hl7_request_id INTO v_return;  -- Return the generated UUID

    RETURN v_return;
EXCEPTION
   WHEN OTHERS THEN
	    -- Capture exception details
	    GET STACKED DIAGNOSTICS
	        v_error_msg = MESSAGE_TEXT,
	        v_sqlstate = RETURNED_SQLSTATE,
	        v_pg_detail = PG_EXCEPTION_DETAIL,
	        v_pg_hint = PG_EXCEPTION_HINT,
	        v_pg_context = PG_EXCEPTION_CONTEXT;
	        v_error_type = 'SQL';
	
	    RAISE NOTICE 'Error occurred: %', SQLERRM; /*Test purpose*/         
	       
	    -- Log the exception, reusing the previous exception ID if it exists
		v_exception_id := techbd_udi_ingress.register_issue(
        COALESCE(v_exception_id,NULL),
		sat_interaction_hl7_request_upserted.uri,
		v_error_msg,
		v_error_type,
		v_sqlstate,
		v_pg_detail,
		v_pg_hint,
		v_pg_context,
		v_created_by,
		v_provenance);
		RETURN NULL;
END;
$function$
;

DROP VIEW IF EXISTS techbd_udi_ingress.fhir_tenant_stats_view  CASCADE;
CREATE OR REPLACE VIEW techbd_udi_ingress.fhir_tenant_stats_view  AS  
    SELECT 
        sihr.tenant_id_lower::text AS qe_name,  
        sihr.created_at::date,
        COUNT(CASE 
                  WHEN sihr.nature = 'org.techbd.service.http.Interactions$RequestResponseEncountered' THEN 1 
                  ELSE NULL 
              END) AS qe_fhir_submission_count,        
        COUNT(CASE 
                  WHEN sihr.nature = 'Forwarded HTTP Response' THEN 1 
                  ELSE NULL 
              END) AS qe_fhir_pass_count,
        COUNT(CASE 
                  WHEN sihr.nature = 'Forwarded HTTP Response Error' THEN 1 
                  ELSE NULL 
              END) AS qe_fhir_fail_count
    FROM 
        techbd_udi_ingress.hub_interaction hintr
    JOIN 
        techbd_udi_ingress.sat_interaction_fhir_request sihr 
    ON 
        hintr.hub_interaction_id = sihr.hub_interaction_id
    WHERE 
        sihr.uri = ANY (ARRAY['/Bundle'::text, '/Bundle/'::text]) 
        AND sihr.tenant_id_lower::text IN ('healthelink', 'healtheconn', 'healthix', 'grrhio', 'hixny')
    AND sihr.created_at::date >= (CURRENT_DATE - INTERVAL '7 days')  -- Filter for last 7 days
GROUP BY 
    sihr.tenant_id_lower::text, sihr.created_at::date
ORDER BY 
    sihr.created_at::date DESC;