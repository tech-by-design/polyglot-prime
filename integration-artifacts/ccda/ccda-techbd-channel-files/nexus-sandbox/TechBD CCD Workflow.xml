<channel version="4.6.1">
  <id>0a09378a-5189-44b7-9ce2-009029f3865d</id>
  <nextMetaDataId>12</nextMetaDataId>
  <name>TechBD CCD Workflow</name>
  <description>Version 0.5.15
Revert the changes in bad gateway occur for CCDA.</description>
  <revision>8</revision>
  <sourceConnector version="4.6.1">
    <metaDataId>0</metaDataId>
    <name>sourceConnector</name>
    <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="4.6.1">
      <pluginProperties>
        <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="4.6.1">
  <authType>NONE</authType>
        </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
      </pluginProperties>
      <listenerConnectorProperties version="4.6.1">
        <host>0.0.0.0</host>
        <port>9002</port>
      </listenerConnectorProperties>
      <sourceConnectorProperties version="4.6.1">
        <responseVariable>finalResponse</responseVariable>
        <respondAfterProcessing>true</respondAfterProcessing>
        <processBatch>false</processBatch>
        <firstResponse>false</firstResponse>
        <processingThreads>1</processingThreads>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
        <queueBufferSize>1000</queueBufferSize>
      </sourceConnectorProperties>
      <xmlBody>false</xmlBody>
      <parseMultipart>false</parseMultipart>
      <includeMetadata>false</includeMetadata>
      <binaryMimeTypes>text/xml</binaryMimeTypes>
      <binaryMimeTypesRegex>false</binaryMimeTypesRegex>
      <responseContentType>application/json</responseContentType>
      <responseDataTypeBinary>false</responseDataTypeBinary>
      <responseStatusCode>${status}</responseStatusCode>
      <responseHeaders class="linked-hash-map">
        <entry>
          <string>Access-Control-Allow-Origin</string>
          <list>
            <string>${HUB_UI_URL}</string>
          </list>
        </entry>
        <entry>
          <string>Access-Control-Allow-Methods</string>
          <list>
            <string>GET, POST, OPTIONS</string>
          </list>
        </entry>
        <entry>
          <string>Access-Control-Allow-Headers</string>
          <list>
            <string>Content-Type,Authorization,X-TechBD-Tenant-ID,User-Agent,X-TechBD-REMOTE-IP,X-TechBD-Override-Request-URI,accept,X-TechBD-CIN,X-TechBD-OrgNPI,X-TechBD-OrgTIN,X-TechBD-Base-FHIR-URL,X-TechBD-Validation-Severity-Level,X-TechBD-Facility-ID,X-TechBD-Encounter-Type,X-TechBD-Screening-Code</string>
          </list>
        </entry>
        <entry>
          <string>Access-Control-Allow-Credentials</string>
          <list>
            <string>true</string>
          </list>
        </entry>
      </responseHeaders>
      <responseHeadersVariable></responseHeadersVariable>
      <useResponseHeadersVariable>false</useResponseHeadersVariable>
      <charset>DEFAULT_ENCODING</charset>
      <contextPath>/</contextPath>
      <timeout>300000</timeout>
      <staticResources/>
    </properties>
    <transformer version="4.6.1">
      <elements>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.6.1">
          <name>DB Save</name>
          <sequenceNumber>0</sequenceNumber>
          <enabled>true</enabled>
          <script>var PGobject = Packages.org.postgresql.util.PGobject;

function toJsonb(value) {
    var jsonbObj = new PGobject();
    jsonbObj.setType(&quot;jsonb&quot;);

	if (typeof value === &quot;object&quot;) {
        value = JSON.stringify(value);
    }
    
    jsonbObj.setValue(value);
    logger.info(&quot;jsonbObj: &quot; + jsonbObj);
    return jsonbObj;
}


function saveCcdaPayload(interactionId, tenantId, requestUri, payloadJson, operation) {
	
	logger.info(&quot;interactionId: &quot; + interactionId);
	logger.info(&quot;tenantId: &quot; + tenantId);
	logger.info(&quot;requestUri: &quot; + requestUri);
	logger.info(&quot;payloadJson: &quot; + payloadJson);
	logger.info(&quot;operation: &quot; + operation);
	
	var DriverManager = java.sql.DriverManager;
	var conn = null;
	var stmt = null;
	
	try {
	    logger.info(&quot;Inside DB Try&quot;);

	    // Database connection details
		var dbUrl = globalMap.get(&apos;jdbcUrl&apos;);
		var dbUser = globalMap.get(&apos;jdbcUsername&apos;);
		var dbPassword = globalMap.get(&apos;jdbcPassword&apos;);

		var ccdaAuthoringDevice = channelMap.get(&apos;ehrVendor&apos;);
	     logger.info(&quot;ccdaAuthoringDevice ================***: &quot; + ccdaAuthoringDevice);
	     //If any error happens in between, find the ccda source type from the input file
	if (operation === &quot;saveOgCCDAPayload&quot; &amp;&amp; typeof ccdaAuthoringDevice === &apos;undefined&apos; || ccdaAuthoringDevice === &quot;&quot; || ccdaAuthoringDevice === null){
		if (/epic/i.test(payloadJson)) { channelMap.put(&apos;ehrVendor&apos;, &apos;Epic&apos;); }
		if (/medent/i.test(payloadJson)) { channelMap.put(&apos;ehrVendor&apos;, &apos;Medent&apos;); }
		if (/athenahealth/i.test(payloadJson)) { channelMap.put(&apos;ehrVendor&apos;, &apos;AthenaHealth&apos;); }
		ccdaAuthoringDevice = channelMap.get(&apos;ehrVendor&apos;);
		logger.info(&quot;ccdaAuthoringDevice ================***: &quot; + ccdaAuthoringDevice);
	}
	if (ccdaAuthoringDevice == &apos;Other&apos;) { ccdaAuthoringDevice = null; }
		
		//Devl
	    conn = DriverManager.getConnection(dbUrl, dbUser, dbPassword);

	    logger.info(&quot;Database connection established successfully.&quot;);
	
		var sql = &quot;select techbd_udi_ingress.register_interaction_ccda_request(?::text,?::text,?::jsonb,?::text,?::text,?::text,?::jsonb,?::text,?::text,?::jsonb,?::text,?::text,?::text,?::text,?::text,?::text,?::text,?,?::text,?,?::text,?::text,?::text,?::text,?::text,?::text,?::text,?::text,?::text,?::text)&quot;;
	    stmt = conn.prepareCall(sql);

		stmt.setString(1, interactionId);
		stmt.setString(2, requestUri);		
		if(operation === &quot;saveOgCCDAPayload&quot;){
			stmt.setObject(3, toJsonb(JSON.stringify({
			    nature: &apos;Original CCDA Payload&apos;,
			    tenant_id: tenantId
			})), java.sql.Types.OTHER);
			stmt.setString(4, &quot;NONE&quot;);	
			stmt.setString(5, &quot;CCDA_ACCEPT&quot;);		
		} else if (operation === &quot;saveValidationSuccess&quot;) {
			stmt.setObject(3, toJsonb(JSON.stringify({
			    nature: &apos;CCDA Validation Result&apos;,
			    tenant_id: tenantId
			})), java.sql.Types.OTHER);
			stmt.setString(4, &quot;CCDA_ACCEPT&quot;);	
			stmt.setString(5, &quot;VALIDATION_SUCCESS&quot;);
		} else if (operation === &quot;saveConversionSuccess&quot;) {
			stmt.setObject(3, toJsonb(JSON.stringify({
			    nature: &apos;Converted to FHIR&apos;,
			    tenant_id: tenantId
			})), java.sql.Types.OTHER);
			stmt.setString(4, &quot;VALIDATION_SUCCESS&quot;);	
			stmt.setString(5, &quot;CONVERTED_TO_FHIR&quot;);
		} else {
			stmt.setObject(3, toJsonb(JSON.stringify({
			    nature: &apos;CCDA Validation Result&apos;,
			    tenant_id: tenantId
			})), java.sql.Types.OTHER);
			stmt.setString(4, &quot;CCDA_ACCEPT&quot;);	
			stmt.setString(5, &quot;VALIDATION_FAILED&quot;);
		}
		stmt.setNull(6, java.sql.Types.VARCHAR);

		if(operation === &quot;saveOgCCDAPayload&quot;){
			stmt.setNull(7, java.sql.Types.OTHER);
		} else {
			stmt.setObject(7, toJsonb(payloadJson), java.sql.Types.OTHER);	
		}
		
		if(operation == &quot;saveValidationSuccess&quot; || operation == &quot;saveValidationFailed&quot; || operation === &quot;saveConversionSuccess&quot;){
			stmt.setNull(8, java.sql.Types.OTHER);
		} else {
			stmt.setString(8, payloadJson);
		}			
		stmt.setNull(9, java.sql.Types.VARCHAR);
		stmt.setNull(10, java.sql.Types.OTHER);
		stmt.setNull(11, java.sql.Types.VARCHAR);
		stmt.setNull(12, java.sql.Types.VARCHAR);
		stmt.setNull(13, java.sql.Types.VARCHAR);
		stmt.setNull(14, java.sql.Types.VARCHAR);
		stmt.setNull(15, java.sql.Types.VARCHAR);
		stmt.setNull(16, java.sql.Types.VARCHAR);
		stmt.setNull(17, java.sql.Types.VARCHAR);
		stmt.setNull(18, java.sql.Types.TIMESTAMP_WITH_TIMEZONE);
		stmt.setNull(19, java.sql.Types.VARCHAR);
		stmt.setNull(20, java.sql.Types.BOOLEAN);
		stmt.setNull(21, java.sql.Types.VARCHAR);
		stmt.setNull(22, java.sql.Types.VARCHAR);
		stmt.setNull(23, java.sql.Types.VARCHAR);
		stmt.setNull(24, java.sql.Types.VARCHAR);
		stmt.setNull(25, java.sql.Types.VARCHAR);
		stmt.setNull(26, java.sql.Types.VARCHAR);
		stmt.setNull(27, java.sql.Types.VARCHAR);
		stmt.setNull(28, java.sql.Types.VARCHAR);
		stmt.setString(29, channelMap.get(&apos;filename&apos;));
		stmt.setString(30, ccdaAuthoringDevice);

	    var result = stmt.execute();
	    logger.info(&quot;Stored procedure executed, result: &quot; + result);
	
	} catch (e) {
	    logger.error(&quot;Error executing stored procedure: &quot; + e);
	} finally {
	    if (stmt != null) stmt.close();
	    if (conn != null) conn.close();
	    logger.info(&quot;DB connection closed.&quot;);
	}
}</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.6.1">
          <name>Common JS functions</name>
          <sequenceNumber>1</sequenceNumber>
          <enabled>true</enabled>
          <script>/**
* Replacer function to remove empty values
*/

var interactionId = java.util.UUID.randomUUID().toString();
channelMap.put(&apos;interactionId&apos;, interactionId);
var tenantId = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-Tenant-ID&apos;);
var requestedPath = sourceMap.get(&apos;contextPath&apos;);
		
function removeEmptyValues(key, value) {
  // Remove values that are empty strings, null, undefined, or empty objects/arrays
  if (value === &quot;&quot; || value === null || value === undefined || 
      (typeof value === &quot;object&quot; &amp;&amp; Object.keys(value).length === 0) ||
      (Array.isArray(value) &amp;&amp; value.length === 0)) {
    return undefined; // Exclude the key from the result
  }
  return value; // Keep the value as is
}


/**
* Util function to generate json string wit hstatus and message
*/
function createJsonResponse(status, message) {
    return JSON.stringify({ status: status, message: message });
}

/**
* Util function to set error response.
*/
function setErrorResponse(statusCode, errorMessage) {
    responseMap.put(&apos;status&apos;, String(statusCode)); // Convert statusCode to string
    responseMap.put(&apos;message&apos;, errorMessage);
    responseMap.put(&apos;finalResponse&apos;, createJsonResponse(statusCode, errorMessage));
}

/*
* Util function to generate json error message
*/
function getJsonInvalidOperationOutcome(errorMsg, code, severity ) {
	if (!severity) { severity = &quot;error&quot;;}
	return { &quot;OperationOutcome&quot;: {
                    &quot;validationResults&quot;: [
                        {
                            &quot;operationOutcome&quot;: {
                                &quot;resourceType&quot;: &quot;OperationOutcome&quot;,
                                &quot;interaction_id&quot;: channelMap.get(&apos;interactionId&apos;),
                                &quot;issue&quot;: [
                                    {
                                        &quot;severity&quot;: severity,
                                        &quot;code&quot;: code,
                                        &quot;details&quot;: {
                                            &quot;text&quot;: errorMsg
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                }
            };
}

function sendDataLedgerSync(payload) {
    logger.info(&quot;sendDataLedgerSync: &quot; + payload);
    
    var apiUrl = LookupHelper.get(&quot;Config&quot;, &quot;DATA_LEDGER_API_URL&quot;, ttlHours);

// 1️⃣ Load from Lookup Manager (NOT sensitive)
var dataLedgerApiKey = LookupHelper.get(&quot;Config-sensitive&quot;, &quot;TECHBD_NYEC_DATALEDGER_API_KEY&quot;, ttlHours);
&#xd;
// 3️⃣ Store real key into channelMap
channelMap.put(&quot;DATA_LEDGER_API_KEY&quot;, dataLedgerApiKey);

logger.info(&quot;✔ DataLedger API Key loaded from Lookup manager (Config-sensitive) group&quot;);

    logger.info(&quot;API URL: &quot; + apiUrl);

    if (apiUrl == null) {
        throw new Error(&quot;Environment variable DATA_LEDGER_API_URL is not set.&quot;);
    }
    if (dataLedgerApiKey == null) {
        throw new Error(&quot;Environment variable &apos;TECHBD_NYEC_DATALEDGER_API_KEY&apos; is not set.&quot;);
    }

    try {
        var HttpClients = org.apache.http.impl.client.HttpClients;
        var HttpPost = org.apache.http.client.methods.HttpPost;
        var StringEntity = org.apache.http.entity.StringEntity;
        var EntityUtils = org.apache.http.util.EntityUtils;

        var httpClient = HttpClients.createDefault();
        var httpPost = new HttpPost(apiUrl);

        httpPost.setHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);
        httpPost.setHeader(&quot;Accept&quot;, &quot;application/json&quot;);
       
        if (dataLedgerApiKey != null) {
        	httpPost.setHeader(&quot;x-api-key&quot;, dataLedgerApiKey); // ✅ Add x-api-key header
        }

        var entity = new StringEntity(payload, &quot;UTF-8&quot;);
        httpPost.setEntity(entity);

        var response = httpClient.execute(httpPost);
        try {
            var statusCode = response.getStatusLine().getStatusCode();
            logger.info(&quot;sendDataLedgerSync response status: &quot; + statusCode);
            var responseBody = EntityUtils.toString(response.getEntity());

            if (statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300) {
                logger.info(&quot;Data Ledger API Response: &quot; + responseBody);
                return {
                    statusCode: statusCode,
                    body: responseBody
                };
            } else {
                logger.error(&quot;Data Ledger API Error. Status: &quot; + statusCode + &quot;, Response: &quot; + responseBody);
                throw new Error(&quot;Request failed with status &quot; + statusCode);
            }
        } finally {
            EntityUtils.consumeQuietly(response.getEntity());
        }
    } catch (error) {
        logger.error(&quot;Data Ledger API Request Failed: &quot; + error.message);
        throw error;
    }
}

////////////////////////************///////////////////////////////
function saveDataLedgerSync(interactionId) {
	//*********** DATA LEDGER ***************
     var  currentTimestamEnd = new Date().toISOString().replace(/\.(\d{3})Z$/, function(match, millis) {
		// Add 3 more random digits to simulate microseconds
		var micros = millis + (Math.floor(Math.random() * 1000)).toString().padStart(3, &apos;0&apos;);
		return &apos;.&apos; + micros + &apos;Z&apos;;
	});
	var payload = JSON.stringify({
        executedAt: currentTimestamEnd,
        actor: &quot;TechBD&quot;,
        action: &quot;sent&quot;, 
        destination: &quot;Invalid - CCD Conversion Failed&quot;,
        dataId: interactionId,
        payloadType: &quot;hrsnBundle&quot;
  	});		
		
	// Check if tracking is enabled
	var trackingEnabled = java.lang.System.getenv(&quot;DATA_LEDGER_TRACKING&quot;);
	if (trackingEnabled != null &amp;&amp; trackingEnabled.toLowerCase() == &quot;true&quot;) {
	   logger.info(&quot;data ledger api call -BEGIN sent&quot;);
	   try {
        	sendDataLedgerSync(payload);
	   } catch (e) {
	        logger.error(&quot;Error occurred while sending data to Data Ledger: &quot; + e.message);
	   }
	   logger.info(&quot;data ledger api call -END sent&quot;);
	} else {
	   logger.info(&quot;DATA_LEDGER_TRACKING is not true; skipping Data Ledger sync for sent.&quot;);
	}
	//*********** DATA LEDGER ***************
}			
////////////////******************////////////////////////////////////////////////////////////////////////////////////////////




// Function to validate addr dates
function validateAddrDates(addr, contextTag) {
	try {
		default xml namespace = &quot;urn:hl7-org:v3&quot;; // Set default namespace
			
		for each (var period in addr.useablePeriod) {
		  var low = period.low.@value.toString();
		  var high = period.high.@value.toString();
		
		  if (low &amp;&amp; high &amp;&amp; high !== &quot;UNK&quot;) {
		      var lowDate = new Date(low.substring(0, 4), low.substring(4, 6) - 1, low.substring(6, 8));
		      var highDate = new Date(high.substring(0, 4), high.substring(4, 6) - 1, high.substring(6, 8));
		
		      if (highDate &lt; lowDate) {
		          var errorMessage = &apos;Validation Error: high date (&apos; + high + &apos;) is earlier than low date (&apos; + low + &apos;) in &apos; + contextTag + &apos;.useablePeriod.&apos;;
			     logger.error(errorMessage);
			     setErrorResponse(400, errorMessage); // Set the HTTP response status to 400 (Bad Request)
			     responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMessage, &quot;invalid&quot;)));
			     //throw errorMessage; // Stop further processing by throwing an exception
			     //throw new Error(errorMessage);--REMOVED
		       return;

		      }
		  }
		}
     } catch (error) {
        logger.error(&quot;Validation Error: &quot; + error.message);
        //throw new Error(&quot;Validation Error: &quot; + error.message);
        return;
     }
}
    
function validateLowHighDates(xmlData) {
	try {	
	    var xml = new XML(xmlData);
	    default xml namespace = &quot;urn:hl7-org:v3&quot;; // Set default namespace
	
	    // 1. patientRole → addr
	    for each (var recordTarget in xml.recordTarget) {
	        var patientRole = recordTarget.patientRole;
	        for each (var addr in patientRole.addr) {
	            validateAddrDates(addr, &quot;recordTarget.patientRole&quot;);
	        }
	    }
	
	    // 2. author → assignedAuthor → representedOrganization → addr
	    for each (var author in xml.author) {
	        var assignedAuthor = author.assignedAuthor;
	        if (assignedAuthor &amp;&amp; assignedAuthor.representedOrganization) {
	            for each (var addr in assignedAuthor.representedOrganization.addr) {
	                validateAddrDates(addr, &quot;author.assignedAuthor.representedOrganization&quot;);
	            }
	        }
	    }
	} catch (error) {
        logger.error(&quot;Validation Error: &quot; + error.message);
        throw new Error(&quot;Validation Error: &quot; + error.message);
     }
}

//////////////////////////////////////********************////////////////////////////////////

/**
 * Extract ClinicalDocument XML safely from raw input
 * @param rawXml - raw request body
 * @return extracted ClinicalDocument XML string OR null
 */
function extractClinicalDocumentFromRawXML(rawXml) {

    if (!rawXml) {
        return null;
    }

    try {
        // Normalize input
        rawXml = String(rawXml).replace(/^\uFEFF/, &apos;&apos;).trim();  //Remove BOM and leading/trailing whitespace

        var xmlDeclaration = &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&apos;;
        var hasXmlDeclaration = rawXml.indexOf(&apos;&lt;?xml&apos;) !== -1;

        var startTag = hasXmlDeclaration ? &apos;&lt;?xml&apos; : &apos;&lt;ClinicalDocument&apos;;
        var start = rawXml.indexOf(startTag);
        var end = rawXml.indexOf(&apos;&lt;/ClinicalDocument&gt;&apos;);

        if (start === -1 || end === -1) {
            return null;
        }

        end += &apos;&lt;/ClinicalDocument&gt;&apos;.length;
        var extractedXml = rawXml.substring(start, end);

        // Add XML declaration if missing
        if (!hasXmlDeclaration) {
            extractedXml = xmlDeclaration + extractedXml;
        }

        return extractedXml;

    } catch (e) {
        logger.error(&quot;extractClinicalDocumentFromRawXML failed: &quot; + e.message);
        return null;
    }
}

///////////////////////////////////////*******************************////////////////////////////////////////

function extractClinicalDocument(rawXml) {
	try {
		// Save Original Payload
	     saveCcdaPayload(
	        interactionId,
	        tenantId,
	        requestedPath,
	        rawXml,
	        &quot;saveOgCCDAPayload&quot;
	     );     

	     var extractedXml = extractClinicalDocumentFromRawXML(rawXml);

		if (!extractedXml || extractedXml.trim().length == 0 || extractedXml.trim() == &apos;&apos;) {
		    var errorMsg = &quot;Could not find ClinicalDocument boundaries in XML.&quot;;
		    var errorResponse = getJsonInvalidOperationOutcome(errorMsg, &quot;invalid&quot;);
		
		    saveCcdaPayload(
		        interactionId,
		        tenantId,
		        requestedPath,
		        errorResponse,
		        &quot;saveValidationFailed&quot;
		    );
		
		    responseMap.put(&apos;finalResponse&apos;, JSON.stringify(errorResponse));		    
		    return;
		}
		
		channelMap.put(&apos;fileContent&apos;, extractedXml);		
	    	return extractedXml;
		    
	} catch (e) {
        logger.error(&quot;extractClinicalDocument failed: &quot; + e.message);
        return null;
    }
}



///////////////////////////////////////////////

function failAndExit(errorMsg, code, severity, interactionId, tenantId, requestedPath) {
    var outcome = getJsonInvalidOperationOutcome(errorMsg, code, severity);
    try {
		saveCcdaPayload(interactionId, tenantId, requestedPath, outcome, &quot;saveValidationFailed&quot;);
		logger.info(&quot;Successfully saved validation failure information&quot;);
    } catch (e) {
        	logger.error(&quot;Failed to save validation failure: &quot; + e.message);
    }

    responseMap.put(&apos;finalResponse&apos;, JSON.stringify(outcome));
    channelMap.put(&apos;jsonResult&apos;, JSON.stringify(outcome));
    logger.error(&quot;STOPPING PROCESSING: &quot; + errorMsg);

    throw new Error(&quot;STOP_PROCESSING&quot;);
}

//function applyPhiFilter(xmlString) {
//    var xsltPath = channelMap.get(&apos;cdaPhiFilter&apos;);
//    var transformer = javax.xml.transform.TransformerFactory
//        .newInstance()
//        .newTransformer(
//            new javax.xml.transform.stream.StreamSource(
//                new java.io.File(xsltPath)
//            )
//        );
//
//    var writer = new java.io.StringWriter();
//    transformer.transform(
//        new javax.xml.transform.stream.StreamSource(new java.io.StringReader(xmlString)),
//        new javax.xml.transform.stream.StreamResult(writer)
//    );
//    return writer.toString();
//}
////////////////////////////////////////////////////////////////////////////
function applyPhiFilter(xmlString) {
    var xsltPath = channelMap.get(&apos;cdaPhiFilter&apos;);
    logger.info(&quot;xsltPath: &quot; + xsltPath);
    
    // ← ADDED: Extract filename from path
    var fileNameWithExt = xsltPath.substring(xsltPath.lastIndexOf(&apos;/&apos;) + 1);
    var fileName = fileNameWithExt.replace(&apos;.xslt&apos;, &apos;&apos;);
    logger.info(&quot;Extracted XSLT Key Name: &quot; + fileName);

    // ← ADDED: Retrieve XSLT content from LookupHelper
    var ttlHours = 24 * 20;
    var xsltContent = LookupHelper.get(&quot;SchemaFiles&quot;, fileName, ttlHours);
    logger.info(&quot;Retrieved XSLT from LookupHelper&quot;);

    // ← ADDED: Validation check
    if (!xsltContent) {
        throw new Error(&quot;LookupManager: No XSLT found for key &quot; + fileName);
    }
    
    // ← CHANGED: Create StreamSource from STRING CONTENT instead of FILE
    var xsltSource = new javax.xml.transform.stream.StreamSource(
        new java.io.StringReader(xsltContent)  // ← Using StringReader with content
    );
    
    var transformer = javax.xml.transform.TransformerFactory
        .newInstance()
        .newTransformer(xsltSource);  // ← Using xsltSource variable

    var writer = new java.io.StringWriter();
    transformer.transform(
        new javax.xml.transform.stream.StreamSource(new java.io.StringReader(xmlString)),
        new javax.xml.transform.stream.StreamResult(writer)
    );
    
    return writer.toString();
}


//////////////////////////////////////////////////////////////////////////////////
//function validateAgainstXsd(xmlString) {
//    var xsdFilePath = channelMap.get(&apos;xsdFilePath&apos;);
//    var schema = javax.xml.validation.SchemaFactory
//        .newInstance(javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI)
//        .newSchema(new javax.xml.transform.stream.StreamSource(new java.io.File(xsdFilePath)));
//
//    var validator = schema.newValidator();
//    validator.validate(
//        new javax.xml.transform.stream.StreamSource(
//            new java.io.StringReader(xmlString)
//        )
//    );
//}
///////////////////////////////////////////
function validateAgainstXsd(xmlString) {
    var xsdFilePath = channelMap.get(&apos;xsdFilePath&apos;);
    logger.info(&quot;Using XSD file path: &quot; + xsdFilePath);
    
    // ← ADDED: Extract filename from path
    var xsdFileName = xsdFilePath.substring(xsdFilePath.lastIndexOf(&apos;/&apos;) + 1);
    logger.info(&quot;Extracted XSD Lookup Key: &quot; + xsdFileName);
    
    var ttlHours = 24 * 24;
    
    // ← ADDED: Create temp directory for XSD files
    var File = Packages.java.io.File;
    var FileWriter = Packages.java.io.FileWriter;
    
    var tempDir = new File(&quot;/tmp/cda_xsd_cache&quot;);
    if (!tempDir.exists()) {
        tempDir.mkdirs();
    }
    
    logger.info(&quot;Temp XSD folder = &quot; + tempDir.getAbsolutePath());
    
    // ← ADDED: Load index.txt to get list of all XSD files
    logger.info(&quot;=== Loading XSD index from Lookup Manager ===&quot;);
    var rawIndex = LookupHelper.get(&quot;SchemaFiles&quot;, &quot;index.txt&quot;, ttlHours);
    
    // ← ADDED: Normalize rawIndex to string
    var indexText = null;
    if (rawIndex == null) {
        logger.error(&quot;Lookup returned NULL for index.txt&quot;);
        indexText = &quot;&quot;;
    } else if (typeof rawIndex === &quot;object&quot;) {
        if (rawIndex.content &amp;&amp; typeof rawIndex.content === &quot;string&quot;) {
            indexText = rawIndex.content;
        } else {
            indexText = String(rawIndex);
        }
    } else if (typeof rawIndex === &quot;string&quot;) {
        indexText = rawIndex;
    } else {
        indexText = String(rawIndex);
    }
    
    logger.info(&quot;indexText: &quot; + indexText);
    
    // ← ADDED: Parse XSD file list from index
    var xsdFiles = [];
    if (indexText.trim().length &gt; 0) {
        xsdFiles = indexText
            .split(/\r?\n/)
            .map(function(line) { return line.trim(); })
            .filter(function(line) { return line.length &gt; 0; });
    }
    
    logger.info(&quot;Final XSD list: &quot; + JSON.stringify(xsdFiles));
    
    // ← ADDED: Write each XSD file from LookupHelper to temp directory
    for (var i = 0; i &lt; xsdFiles.length; i++) {
        var name = xsdFiles[i];
        var content = LookupHelper.get(&quot;SchemaFiles&quot;, name, ttlHours);
        
        if (!content || content.trim().length === 0) {
            throw new Error(&quot;Missing XSD in LookupManager: &quot; + name);
        }
        
        var f = new File(tempDir, name);
        var fw = new FileWriter(f);
        fw.write(content);
        fw.close();
        
        logger.info(&quot;Wrote XSD to temp: &quot; + f.getAbsolutePath());
    }
    
    // ← CHANGED: Build schema from root XSD file in temp directory
    var schemaFactory = javax.xml.validation.SchemaFactory
        .newInstance(javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI);
    
    var rootFile = new File(tempDir, xsdFileName);  // ← Using temp directory
    var schemaSource = new javax.xml.transform.stream.StreamSource(rootFile);
    var schema = schemaFactory.newSchema(schemaSource);
    var validator = schema.newValidator();
    
    // Validate XML (unchanged)
    logger.info(&quot;Starting XML validation against CDA schema...&quot;);
    validator.validate(
        new javax.xml.transform.stream.StreamSource(
            new java.io.StringReader(xmlString)
        )
    );
}

///////////////////////////////////////////
//function convertCcdaToFhirBundle(phiFilteredXml) {
//
//    // -----------------------------------
//    // Load the XSLT template
//    // -----------------------------------
//    var xsltPath = channelMap.get(&apos;cdaPhiBundle&apos;);
//    var xsltFile = new java.io.File(xsltPath);
//    var xsltStream = new java.io.FileInputStream(xsltFile);
//
//    var transformerFactory = javax.xml.transform.TransformerFactory.newInstance();
//    var xsltSource = new javax.xml.transform.stream.StreamSource(xsltStream);
//    var transformer = transformerFactory.newTransformer(xsltSource);
//
//    // -----------------------------------
//    // Timestamp parameter
//    // -----------------------------------
//    // Set the current timestamp parameter in ISO 8601 format
//    var currentTimestamp = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SS&apos;Z&apos;&quot;).format(new java.util.Date());
//    transformer.setParameter(&quot;currentTimestamp&quot;, currentTimestamp);
//
//    transformer = set_fhir_resource_profile_urls(transformer); // Pass all the profile urls as parameters to XSLT
//
//    // -----------------------------------
//    // Base FHIR URL handling
//    // -----------------------------------
//    var customBaseFhirUrl = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-Base-FHIR-URL&apos;);  // Retrieve the X-TechBD-Base-FHIR-URL header
//    logger.info(&quot;X-TechBD-Base-FHIR-URL: &quot; + customBaseFhirUrl);
//    
//    var validUrlsEnv = Packages.java.lang.System.getenv(&quot;MC_VALID_FHIR_URLS&quot;); // Retrieve the VALID_URLS environment variable (comma-separated list)
//    logger.info(&quot;MC_VALID_FHIR_URLS from environment: &quot; + validUrlsEnv);
//	
//    // Convert VALID_URLS to an array for validation
//    var validUrls = validUrlsEnv ? validUrlsEnv.split(&quot;,&quot;).map(function(url) { return url.trim(); }) : [];
//	
//    // Check if the header value is valid
//    if (customBaseFhirUrl !== null &amp;&amp; customBaseFhirUrl.trim() != &quot;&quot;) {
//	    if (validUrls.includes(customBaseFhirUrl)) {
//	        // Store valid value in channelMap
//	        transformer.setParameter(&quot;baseFhirUrl&quot;, customBaseFhirUrl);
//		   channelMap.put(&apos;baseFhirUrl&apos;, customBaseFhirUrl);
//	    } else {
//	        // Throw a Bad Request error if the URL is not in the valid list
//			var errorMessage = &apos;The provided X-TechBD-Base-FHIR-URL is invalid. Base-FHIR-URL taken from the environment variable.&apos;;
//			logger.error(errorMessage);
//	    }
//    }
//
//    // -----------------------------------
//    // Transform CCDA → FHIR Bundle
//    // -----------------------------------
//    var writer = new java.io.StringWriter();
//    transformer.transform(
//        new javax.xml.transform.stream.StreamSource(
//            new java.io.StringReader(phiFilteredXml)
//        ),
//        new javax.xml.transform.stream.StreamResult(writer)
//    );
//
//    // -----------------------------------
//    // Clean JSON
//    // -----------------------------------
//    var rawJson = writer.toString();
//    var jsonObject = JSON.parse(rawJson);
//    var cleanedJsonString = JSON.stringify(jsonObject, removeEmptyValues, 2);
//
//    logger.info(&quot;Cleaned FHIR Bundle JSON : &quot; + cleanedJsonString);	
//    channelMap.put(&apos;ccd_fhir_bundle&apos;, cleanedJsonString);
//    return cleanedJsonString;
//}

//////////////////////////////////////////////////////////
function convertCcdaToFhirBundle(phiFilteredXml) {

    // -----------------------------------
    // Load the XSLT template
    // -----------------------------------
    var xsltPath = channelMap.get(&apos;cdaPhiBundle&apos;);
    logger.info(&quot;xsltPath: &quot; + xsltPath);
    
    var fileNameWithExt = xsltPath.substring(xsltPath.lastIndexOf(&apos;/&apos;) + 1);
    var fileName = fileNameWithExt.replace(&apos;.xslt&apos;, &apos;&apos;);
    logger.info(&quot;Extracted XSLT Key Name: &quot; + fileName);

    var ttlHours = 24 * 20;
    var xsltContent = LookupHelper.get(&quot;SchemaFiles&quot;, fileName, ttlHours);
    logger.info(&quot;Value from cdaPhiBundle XSLT: &quot; + xsltContent);

    if (!xsltContent) {
        throw new Error(&quot;LookupManager: No XSLT found for key &quot; + fileName);
    }
    
    // Convert XSLT to StreamSource
    var xsltSource = new javax.xml.transform.stream.StreamSource(
        new java.io.StringReader(xsltContent)
    );

    var transformerFactory = javax.xml.transform.TransformerFactory.newInstance();
    var transformer = transformerFactory.newTransformer(xsltSource);

    // -----------------------------------
    // Timestamp parameter
    // -----------------------------------
    var currentTimestamp = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SS&apos;Z&apos;&quot;).format(new java.util.Date());
    transformer.setParameter(&quot;currentTimestamp&quot;, currentTimestamp);

    transformer = set_fhir_resource_profile_urls(transformer); // Pass all the profile urls as parameters to XSLT

    // -----------------------------------
    // Base FHIR URL handling
    // -----------------------------------
    var customBaseFhirUrl = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-Base-FHIR-URL&apos;);
    logger.info(&quot;X-TechBD-Base-FHIR-URL: &quot; + customBaseFhirUrl);
    
    var validUrlsEnv = LookupHelper.get(&quot;Config&quot;, &quot;MC_VALID_FHIR_URLS&quot;, ttlHours);
    logger.info(&quot;MC_VALID_FHIR_URLS from LookupHelper: &quot; + validUrlsEnv);
	
    // Convert VALID_URLS to an array for validation
    var validUrls = validUrlsEnv ? validUrlsEnv.split(&quot;,&quot;).map(function(url) { return url.trim(); }) : [];
	
    // Check if the header value is valid
    if (customBaseFhirUrl !== null &amp;&amp; customBaseFhirUrl.trim() != &quot;&quot;) {
	    if (validUrls.includes(customBaseFhirUrl)) {
	        transformer.setParameter(&quot;baseFhirUrl&quot;, customBaseFhirUrl);
		   channelMap.put(&apos;baseFhirUrl&apos;, customBaseFhirUrl);
	    } else {
			var errorMessage = &apos;The provided X-TechBD-Base-FHIR-URL is invalid. Base-FHIR-URL taken from the environment variable.&apos;;
			logger.error(errorMessage);
	    }
    }

    // -----------------------------------
    // Transform CCDA → FHIR Bundle
    // -----------------------------------
    var writer = new java.io.StringWriter();
    transformer.transform(
        new javax.xml.transform.stream.StreamSource(
            new java.io.StringReader(phiFilteredXml)
        ),
        new javax.xml.transform.stream.StreamResult(writer)
    );

    // -----------------------------------
    // Clean JSON
    // -----------------------------------
    var rawJson = writer.toString();
    var jsonObject = JSON.parse(rawJson);
    var cleanedJsonString = JSON.stringify(jsonObject, removeEmptyValues, 2);

    logger.info(&quot;Cleaned FHIR Bundle JSON : &quot; + cleanedJsonString);	
    channelMap.put(&apos;ccd_fhir_bundle&apos;, cleanedJsonString);
    return cleanedJsonString;
}</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.6.1">
          <name>Validate HTTP Request and collect headers</name>
          <sequenceNumber>2</sequenceNumber>
          <enabled>true</enabled>
          <script>logger.info(&quot;HTTP request validation started.&quot;);
///////////////////////////////////////////////////////////////////////////////////////////
///*******************************
//    AWS Secrets Manager Loader
//********************************/
//
//function fetchSecret(secretName) {
//    var region = &quot;us-east-1&quot;;
//
//    var Region = Packages.software.amazon.awssdk.regions.Region;
//    var SecretsManagerClient = Packages.software.amazon.awssdk.services.secretsmanager.SecretsManagerClient;
//    var GetSecretValueRequest = Packages.software.amazon.awssdk.services.secretsmanager.model.GetSecretValueRequest;
//
//    try {
//        var client = SecretsManagerClient.builder()
//            .region(Region.of(region))
//            .build();
//
//        var request = GetSecretValueRequest.builder()
//            .secretId(secretName)
//            .build();
//
//        var response = client.getSecretValue(request);
//        client.close();
//
//        var value = response.secretString();
//        logger.info(&quot;★ Successfully fetched secret: &quot; + secretName);
//
//        return value;
//
//    } catch (e) {
//        logger.error(&quot;❌ Failed fetching secret: &quot; + secretName + &quot; | Error: &quot; + e.message);
//        throw e;
//    }
//}

/********************************************
    1️⃣ Fetch JDBC configuration from Lookup Manager(Config-sensitive)
********************************************/

try {
  
var jdbc_Passord = LookupHelper.get(&quot;Config-sensitive&quot;, &quot;MC_JDBC_PASSWORD&quot;, ttlHours);
channelMap.put(&quot;JDBC_PASSWORD&quot;, jdbc_Passord);
logger.info(&quot;✔**************************** jdbc_Passord loaded into channelMap&quot; + jdbc_Passord);
var jdbc_Username = LookupHelper.get(&quot;Config-sensitive&quot;, &quot;MC_JDBC_USERNAME&quot;, ttlHours);
channelMap.put(&quot;JDBC_USERNAME&quot;, jdbc_Username);
logger.info(&quot;✔**************************** jdbc_Username loaded into channelMap&quot; + jdbc_Username);    
    
} catch (e) {
    logger.error(&quot;❌ Error processing JDBC Attributes: &quot; + e.message);
}

/********************************************
    2️⃣ FETCH DATA LEDGER API KEY (Plain text)
********************************************/

try {
    var dataLedgerKey = LookupHelper.get(&quot;Config-sensitive&quot;, &quot;TECHBD_NYEC_DATALEDGER_API_KEY&quot;, ttlHours);
    
    channelMap.put(&quot;DATA_LEDGER_API_KEY&quot;, dataLedgerKey);

    logger.info(&quot;✔ DataLedger API Key loaded into channelMap :&quot;);

} catch (e) {
    logger.error(&quot;❌ Error processing DataLedger API Config-sensitive group: &quot; + e.message);
}

/********************************************
    3️⃣ FETCH FHIR BUNDLE SUBMISSION API URL (Plain text)
********************************************/
try {
    var fhirApiUrl = LookupHelper.get(&quot;Config&quot;, &quot;MC_FHIR_BUNDLE_SUBMISSION_API_URL&quot;, ttlHours);

    if (!fhirApiUrl || fhirApiUrl.trim() === &quot;&quot;) {
        throw &quot;Lookup Manager configuration  for FHIR API URL returned empty.&quot;;
    }

    channelMap.put(&quot;FHIR_API_URL&quot;, fhirApiUrl);
    globalMap.put(&quot;fhirBundleSubmissionApiUrl&quot;, fhirApiUrl);
    logger.info(&quot;✔ FHIR API URL loaded from Lookup Manager configuration&quot;);

} catch (e) {
    logger.error(&quot;❌ Error fetching FHIR API URL: &quot; + e);
    setErrorResponse(500, &quot;Failed to load FHIR API URL&quot;);
    throw e;
}

/********************************************
    6️⃣ FETCH JDBC URL (Plain text)
********************************************/
try {

    // Get REAL jdbc URL from Config-sensitive group
    var jdbcUrl = LookupHelper.get(&quot;Config-sensitive&quot;, &quot;MC_JDBC_URL&quot;, ttlHours);
    

    if (!jdbcUrl || jdbcUrl.trim() === &quot;&quot;) {
        throw &quot;Lookup Manager(config) for MC_JDBC_URL returned empty.&quot;;
    }

    jdbcUrl = jdbcUrl.trim(); // IMPORTANT: remove trailing spaces
    channelMap.put(&quot;jdbcUrl&quot;, jdbcUrl);
    logger.info(&quot;✔************************ JDBC URL loaded from Config-sensitive group: &quot; + jdbcUrl);

} catch (e) {
    logger.error(&quot;❌ Error fetching JDBC URL: &quot; + e);
    setErrorResponse(500, &quot;Failed to load JDBC URL&quot;);
    throw e;
}

/********************************************
    4️⃣ FETCH CSV SERVICE API URL (Plain text)
********************************************/
try {
    var csvServiceUrl = LookupHelper.get(&quot;Config&quot;, &quot;TECHBD_CSV_SERVICE_API_URL&quot;, ttlHours);

    if (!csvServiceUrl || csvServiceUrl.trim() === &quot;&quot;) {
        throw &quot;Lookup Manager configuration for CSV Service URL returned empty.&quot;;
    }

    channelMap.put(&quot;CSV_SERVICE_API_URL&quot;, csvServiceUrl);
    globalMap.put(&quot;csvServiceApiUrl&quot;, csvServiceUrl);
    logger.info(&quot;✔ CSV Service API URL loaded from Lookup Manager(config)r&quot;);

} catch (e) {
    logger.error(&quot;❌ Error fetching CSV Service API URL: &quot; + e);
    setErrorResponse(500, &quot;Failed to load CSV Service API URL&quot;);
    throw e;
}

/********************************************
    5️⃣ FETCH DEFAULT DATALAKE API URL (Plain text)
********************************************/
try {
    var datalakeApiUrl = LookupHelper.get(&quot;Config&quot;, &quot;TECHBD_DEFAULT_DATALAKE_API_URL&quot;, ttlHours);

    if (!datalakeApiUrl || datalakeApiUrl.trim() === &quot;&quot;) {
        throw &quot;Lookup Manager configuration for DataLake API URL returned empty.&quot;;
    }

    channelMap.put(&quot;DATALAKE_API_URL&quot;, datalakeApiUrl);
    globalMap.put(&quot;datalakeApiUrl&quot;, datalakeApiUrl);
    logger.info(&quot;✔ Datalake API URL loaded from Lookup Manager(config)&quot;);

} catch (e) {
    logger.error(&quot;❌ Error fetching Datalake API URL: &quot; + e);
    setErrorResponse(500, &quot;Failed to load Datalake API URL&quot;);
    throw e;
}
/////////////////////////////////////////////////////
/********************************************
    5️⃣ FETCH DEFAULT DATALAKE API URL (Plain text)
    WITH HEADER OVERRIDE SUPPORT
********************************************/

    // First, check if the header override is provided
    var headerDataLakeApiUrl = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-DataLake-API-URL&apos;);
    
    if (headerDataLakeApiUrl &amp;&amp; String(headerDataLakeApiUrl).trim() !== &quot;&quot;) {
        // Header provided - use it as override
        headerDataLakeApiUrl = headerDataLakeApiUrl.trim();
        channelMap.put(&quot;DATALAKE_API_URL&quot;, headerDataLakeApiUrl);
        globalMap.put(&quot;datalakeApiUrl&quot;, headerDataLakeApiUrl);
        logger.info(&quot;✔DataLake API URL overridden from request header: &quot; + headerDataLakeApiUrl);
    } 

/********************************************
    9️⃣ FETCH DATA LEDGER  DATA_LEDGER_TRACKING (Plain text)
********************************************/
 
try {
    var dataLedgerTracking = LookupHelper.get(&quot;Config&quot;, &quot;DATA_LEDGER_TRACKING&quot;, ttlHours);
    
    channelMap.put(&quot;DATA_LEDGER_TRACKING&quot;, dataLedgerTracking);
    globalMap.put(&quot;DATA_LEDGER_TRACKING&quot;, dataLedgerTracking);
 
    logger.info(&quot;✔ DataLedger Tracking loaded into channelMap&quot;);
 
} catch (e) {
    logger.error(&quot;❌ Error processing DataLedger Lookup Manager(config): &quot; + e.message);
}
////
/********************************************
    8️⃣ FETCH DATA LEDGER API URL (Plain text)
********************************************/

try {
    var ledgerUrl = LookupHelper.get(&quot;Config&quot;, &quot;DATA_LEDGER_API_URL&quot;, ttlHours);
    
     globalMap.put(&quot;DATA_LEDGER_API_URL&quot;, ledgerUrl);

    logger.info(&quot;✔ DataLedger API URL loaded into channelMap&quot; + ledgerUrl);

} catch (e) {
    logger.error(&quot;❌ Error processing DataLedger API URL from Lookup Manager(config): &quot; + e.message);
}
/********************************************
    7️⃣ FETCH HUB UI URL (Plain text)
********************************************/
// Retrieves the Hub UI URL used to populate the Access-Control-Allow-Origin header
try {
    var hubUiUrl = LookupHelper.get(&quot;Config&quot;, &quot;HUB_UI_URL&quot;, ttlHours);
 
    if (!hubUiUrl || hubUiUrl.trim() === &quot;&quot;) {
        throw &quot;Lookup Manager(config) for HUB_UI_URL returned empty.&quot;;
    }
 
    hubUiUrl = hubUiUrl.trim();
 
    channelMap.put(&quot;HUB_UI_URL&quot;, hubUiUrl);
    globalMap.put(&quot;HUB_UI_URL&quot;, hubUiUrl);
 
    logger.info(&quot;✔ HUB UI URL loaded from Lookup Manager(config): &quot;);
 
} catch (e) {
    logger.error(&quot;❌ Error fetching HUB UI URL: &quot; + e);
    setErrorResponse(500, &quot;Failed to load HUB UI URL&quot;);
    throw e;
}

/********************************************
    DONE
********************************************/

var requestedPath = sourceMap.get(&apos;contextPath&apos;);
logger.info(&quot;Request URL: &quot; + requestedPath);

if (requestedPath == &quot;/&quot;) {
	return;
}

// Initialize missing headers array
var missingHeaders = [];

// Helper to check and store missing header
function checkRequiredHeader(headerName, displayName, storeInMap, mapKey) {
    var value = $(&apos;headers&apos;).getHeader(headerName);
    logger.info(headerName + &quot;: &quot; + value);

    if (value == null || String(value).trim() === &quot;&quot;) {
        missingHeaders.push(&quot;Missing required header &quot; + displayName);
    } else if (storeInMap) {
        channelMap.put(mapKey || headerName, value);
    }

    return value;
}

///////////////////////////////////////////////////////////////////////////
// Access the required header values using getHeader method
// Mandatory: X-TechBD-Tenant-ID
checkRequiredHeader(&apos;X-TechBD-Tenant-ID&apos;, &apos;X-TechBD-Tenant-ID&apos;, true, &apos;tenantId&apos;);

// Retrieve the Content-Type header
var contentType = $(&apos;headers&apos;).getHeader(&apos;Content-Type&apos;);
// Check if the Content-Type is &apos;multipart/form-data&apos; and contains a boundary
if (!contentType || !contentType.startsWith(&apos;multipart/form-data&apos;) /*|| !contentType.includes(&apos;boundary=&apos;)*/) {
    missingHeaders.push(&quot;Content-Type must be &apos;multipart/form-data&apos; with boundary details&quot;);
}

// Get User-Agent header to set at HTTP Writer not to show &apos;Mirth connect&apos; as Agent at the application side.
var userAgent = $(&apos;headers&apos;).getHeader(&apos;User-Agent&apos;);
channelMap.put(&apos;userAgent&apos;, userAgent);
logger.info(&quot;User-Agent: &quot; + userAgent);

var severityLevel = String($(&apos;headers&apos;).getHeader(&apos;X-TechBD-Validation-Severity-Level&apos;) || &quot;&quot;).trim();
channelMap.put(&apos;SeverityLevel&apos;, severityLevel || &quot;error&quot;);
logger.info(&quot;SeverityLevel: &quot; + (severityLevel || &quot;error&quot;));

channelMap.put(&apos;uri&apos;, sourceMap.get(&apos;uri&apos;));
channelMap.put(&apos;contextPath&apos;, sourceMap.get(&apos;contextPath&apos;));

//** Get CIN, NPI and TIN from headers for CCDA FHIR Bundle - Required for FHIR Bundle conversion only**//
if (requestedPath == &quot;/ccda/Bundle/&quot; || requestedPath == &quot;/ccda/Bundle&quot;) {
	//1.CIN
	checkRequiredHeader(&apos;X-TechBD-CIN&apos;, &apos;X-TechBD-CIN&apos;, true, &apos;patientCIN&apos;);
	
	//2.NPI
	var organizationNPI = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-OrgNPI&apos;);
	logger.info(&quot;X-TechBD-OrgNPI: &quot; + organizationNPI);
	
	//3.TIN
	var organizationTIN = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-OrgTIN&apos;);
	logger.info(&quot;X-TechBD-OrgTIN: &quot; + organizationTIN);
	
	// Check if both are missing — only then it&apos;s an error
	if ((organizationNPI == null || String(organizationNPI).trim() === &quot;&quot;) &amp;&amp;
	    (organizationTIN == null || String(organizationTIN).trim() === &quot;&quot;)) {
	    missingHeaders.push(&quot;Missing required header X-TechBD-OrgNPI and X-TechBD-OrgTIN. One is mandatory.&quot;);
	} else {
	    if (organizationNPI &amp;&amp; String(organizationNPI).trim() !== &quot;&quot;) {
	        channelMap.put(&apos;organizationNPI&apos;, organizationNPI);
	    }
	    if (organizationTIN &amp;&amp; String(organizationTIN).trim() !== &quot;&quot;) {
	        channelMap.put(&apos;organizationTIN&apos;, organizationTIN);
	    }
	}
	
	//4. Facility Code
	checkRequiredHeader(&apos;X-TechBD-Facility-ID&apos;, &apos;X-TechBD-Facility-ID&apos;, true, &apos;facilityID&apos;);

	//5. Encounter Type
	checkRequiredHeader(&apos;X-TechBD-Encounter-Type&apos;, &apos;X-TechBD-Encounter-Type&apos;, true, &apos;encounterType&apos;);

	//Screening code (used for Grouper resource) for Epic CCD files
	var screeningCode = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-Screening-Code&apos;);	
	logger.info(&quot;X-TechBD-Screening-Code: &quot; + screeningCode);
	if (screeningCode &amp;&amp; String(screeningCode).trim() !== &quot;&quot;) {
	    channelMap.put(&apos;X-TechBD-Screening-Code&apos;, screeningCode);
	}
}

// If any missing headers were found, throw a single error
if (missingHeaders.length &gt; 0) {
    var errorMessage = &quot;Bad Request: &quot; + missingHeaders.join(&quot;; &quot;);
    logger.error(errorMessage);
    setErrorResponse(400, errorMessage);
    throw errorMessage;
}

///////////////////////////////////////////////////////////////////////////
// Parse the incoming request (assumes multipart form data)
var rawData = connectorMessage.getRawData();

// Check if rawData is empty
if (!rawData || rawData.trim().length == 0 || rawData.trim() == &apos;&apos;) {
    errorMessage = &quot;Uploaded file is empty or missing.&quot;;
    setErrorResponse(400, errorMessage);
    throw errorMessage;
}

// Parse the rawData as multipart form data
var boundary = rawData.split(&quot;\r\n&quot;)[0];
var parts = rawData.split(boundary);

// Initialize variables to store file content
//var fileContent = null;
////------------------------------------------------------------------------------------
//// Loop through parts to find the file part
//var i = 0;
//for each (var part in parts) {
//    if (part.indexOf(&apos;Content-Disposition: form-data; name=&quot;file&quot;;&apos;) !== -1) {
//        logger.info(&quot;Part count &quot; + ++i);
//        // Extract the file content (skip headers)
//        var contentStartIndex = part.indexOf(&quot;\r\n\r\n&quot;) + 4;
//        fileContent = part.substring(contentStartIndex, part.lastIndexOf(&quot;\r\n&quot;));
//        break;
//    }
//}
//
//// Validate the file content
//if (!fileContent || fileContent == &apos;&apos; || fileContent.trim().length == 0) {
//    errorMessage = &quot;Uploaded file is empty or missing.&quot;;
//    // Set the HTTP response status to 400 (Bad Request)
//    setErrorResponse(400, errorMessage);
//    throw errorMessage;
//} else {
//    logger.info(&quot;fileContent not null. Size: &quot; + fileContent.length + &quot; bytes.&quot;);
//    logger.info(&quot;File content: (input validation) - &quot; + fileContent);
//}
//------------------------------------------------------------------------------------
//var xml = new XML(rawData);
//var CCDAMessage = xml.Content.Part.Content.toString();
//logger.info(&quot;CCDAMessage : &quot; + CCDAMessage);
//
//var CCDAMessage = String(rawData[&apos;Content&apos;][&apos;Part&apos;][&apos;Content&apos;]);
//logger.info(&quot;CCDA DATA : &quot; + CCDAMessage);
//
// Safety check
//if (CCDAMessage == null || CCDAMessage.trim() === &quot;&quot;) {
//	logger.warn(&quot;No CCDA content found in uploaded file.&quot;);
//    var errorMessage = &quot;Uploaded file is empty or missing.&quot;;
//    	setErrorResponse(400, errorMessage);
//    	throw errorMessage;
//}
//------------------------------------------------------------------------------------
//Check the file type, only .xml and .txt allowed
var filename = null;
var filenameMatch = rawData.match(/filename=&quot;([^&quot;]+)&quot;/); // Use regex to extract the filename from the Content-Disposition line

if (filenameMatch &amp;&amp; filenameMatch.length &gt; 1) {
    filename = filenameMatch[1];
    logger.info(&quot;Filename: &quot; + filename);
    channelMap.put(&apos;filename&apos;, filename);

    //var extensionMatch = filename.match(/\.([0-9a-z]+)(?=[?#])?/i);
    var extensionMatch = filename.match(/\.([0-9a-z]+)$/i);
    var extension = extensionMatch ? extensionMatch[1].toLowerCase().trim() : null;
    logger.info(&quot;File extension: &quot; + extension);

    if (extension !== &quot;xml&quot; &amp;&amp; extension !== &quot;txt&quot;) {
       var errorMessage = &quot;Unsupported file extension: &quot; + extension + &quot;. Only .xml and .txt are allowed.&quot;;
       setErrorResponse(400, errorMessage); // Set the HTTP response status to 400 (Bad Request)
    	  throw errorMessage; // Stop further processing by throwing an exception
    }
} else {
    logger.warn(&quot;Filename not found in message content.&quot;);
    errorMessage = &quot;Uploaded file is empty or missing.&quot;;
    setErrorResponse(400, errorMessage);
    throw errorMessage;
}

var xmlExtracted = extractClinicalDocument(rawData);
if (!xmlExtracted || xmlExtracted.trim().length == 0 || xmlExtracted.trim() == &apos;&apos;) {
    errorMessage = &quot;Could not find ClinicalDocument boundaries in XML.&quot;;
    throw errorMessage;
}

//////////////////////////////////////////////////////
// Read environment variables and set to global map //
//////////////////////////////////////////////////////

// Initialize missing environment variables array
var missingEnvVars = [];

// get the key from Lookup Manager
var fhirBundleSubmissionApiUrl = LookupHelper.get(&quot;Config&quot;, &quot;MC_FHIR_BUNDLE_SUBMISSION_API_URL&quot;, ttlHours).trim();
&#xd;
    if (!fhirBundleSubmissionApiUrl || fhirBundleSubmissionApiUrl.trim() === &quot;&quot;) {
        missingEnvVars.push(&quot;Lookup Manager configuration for MC_FHIR_BUNDLE_SUBMISSION_API_URL returned empty value&quot;);
    } else {
        // 3️⃣ Store real value for later use
        globalMap.put(&apos;fhirBundleSubmissionApiUrl&apos;, fhirBundleSubmissionApiUrl);
        logger.info(&quot;FHIR Bundle Submission API URL (from Config): &quot; + fhirBundleSubmissionApiUrl);
    }
/////////////////////////////////////

// Fetch and check environment variable: MC_CCDA_SCHEMA_FOLDER
var ccdaSchemaFolder = LookupHelper.get(&quot;Config&quot;, &quot;MC_CCDA_SCHEMA_FOLDER&quot;, ttlHours);
if (ccdaSchemaFolder != null) {
    channelMap.put(&apos;ccdaSchemaFolder&apos;, ccdaSchemaFolder);
    logger.info(&quot;ccdaSchemaFolder: &quot; + ccdaSchemaFolder);
    channelMap.put(&apos;xsdFilePath&apos;, ccdaSchemaFolder + &apos;/CDA.xsd&apos;);
    logger.info(&quot;using xsdFilePath: &quot; + channelMap.get(&apos;xsdFilePath&apos;));
} else {
    missingEnvVars.push(&quot;MC_CCDA_SCHEMA_FOLDER is not set&quot;);
}

// If any env vars are missing, throw a single error
if (missingEnvVars.length &gt; 0) {
    var errorMessage = &quot;Server Error: &quot; + missingEnvVars.join(&quot;; &quot;);
    logger.error(errorMessage);
    setErrorResponse(500, errorMessage); // Internal Server Error
    throw errorMessage;
}

///////////////////////////////////////////
// Set path for schema and related files //
///////////////////////////////////////////

/*
* Util function to get vender identifier details and choose the xslt file according to the vendor
*/
function getManufacturerModelName(xmlData) {
	try {
		if (xmlData) {
			var ccdaSchemaFolder = channelMap.get(&apos;ccdaSchemaFolder&apos;);
			var xmlDoc = new XML(xmlData); // Convert XML string to XML object
			var cdaPhiFilterXsltPath = ccdaSchemaFolder + &quot;/cda-phi-filter.xslt&quot;;
			var cdaFhirBundleXsltPath = ccdaSchemaFolder + &quot;/cda-fhir-bundle.xslt&quot;;
			
			var manufacturerModelName = &apos;&apos;;
			var softwareName = &apos;&apos;;
			var ehrVendor = &apos;&apos;;
			var lowerName = &apos;&apos;;
			var modelNode = &apos;&apos;;
			////////////////////////////////************////////////////////
			// To get the ehrVendor name check both manufacturerModelName as well as softwareName -- update done for Greenway
			var device = xmlDoc.*::author.*::assignedAuthor.*::assignedAuthoringDevice[0];
		     if (device) {
		        var modelEl = device.*::manufacturerModelName[0];
		        if (modelEl) {manufacturerModelName = modelEl.toString().trim();}
		
		        var softwareEl = device.*::softwareName[0];
		        if (softwareEl) {softwareName = softwareEl.toString().trim();}
		     }
		     logger.info(&quot;Manufacturer Model Name: &quot; + manufacturerModelName);
			logger.info(&quot;Software Name: &quot; + softwareName);

			combinedVendorText = (manufacturerModelName + &quot; &quot; + softwareName).trim();
			if (combinedVendorText.length &gt; 0) {
			    lowerName = combinedVendorText.toLowerCase();
			} else {
			    logger.warn(&quot;Both manufacturerModelName and softwareName are empty&quot;);
			    lowerName = &quot;&quot;;
			}
			   /////////////////////////////*****************/////////////////////////////                 
			if (lowerName.indexOf(&quot;epic&quot;) !== -1) {
			    	ehrVendor = &quot;Epic&quot;;
			    	cdaPhiFilterXsltPath = ccdaSchemaFolder + &quot;/cda-phi-filter-epic.xslt&quot;;
				cdaFhirBundleXsltPath = ccdaSchemaFolder + &quot;/cda-fhir-bundle-epic.xslt&quot;;
			} else if (lowerName.indexOf(&quot;medent&quot;) !== -1) {
			    	ehrVendor = &quot;Medent&quot;;
			    	cdaPhiFilterXsltPath = ccdaSchemaFolder + &quot;/cda-phi-filter-medent.xslt&quot;;
				cdaFhirBundleXsltPath = ccdaSchemaFolder + &quot;/cda-fhir-bundle-medent.xslt&quot;;
			} else if (lowerName.indexOf(&quot;athenahealth&quot;) !== -1) {
			    	ehrVendor = &quot;Athenahealth&quot;;
			    	cdaPhiFilterXsltPath = ccdaSchemaFolder + &quot;/cda-phi-filter-athenahealth.xslt&quot;;
				cdaFhirBundleXsltPath = ccdaSchemaFolder + &quot;/cda-fhir-bundle-athenahealth.xslt&quot;;
			} else {
			    	ehrVendor = &quot;Other&quot;;
			    	cdaPhiFilterXsltPath = ccdaSchemaFolder + &quot;/cda-phi-filter.xslt&quot;;
				cdaFhirBundleXsltPath = ccdaSchemaFolder + &quot;/cda-fhir-bundle.xslt&quot;;
			}
			
			logger.info(&quot;ehrVendor: &quot; + ehrVendor);
			channelMap.put(&apos;ehrVendor&apos;, ehrVendor);
			channelMap.put(&apos;cdaPhiFilter&apos;, cdaPhiFilterXsltPath);
			channelMap.put(&apos;cdaPhiBundle&apos;, cdaFhirBundleXsltPath);
			
			logger.info(&quot;using cdaPhiFilter: &quot; + channelMap.get(&apos;cdaPhiFilter&apos;));
			logger.info(&quot;using cdaPhiBundle: &quot; + channelMap.get(&apos;cdaPhiBundle&apos;));

		} else {
		    logger.error(&quot;xmlData is undefined or empty.&quot;);
		}
	} catch (e) {
        //logger.warn(&quot;Error parsing manufacturerModelName: &quot; + e);
        var errorMsg;
        if (e instanceof JavaException) {
           errorMsg = &quot;Error parsing manufacturerModelName: &quot; + e.toString();
        } else {
           errorMsg = &quot;Unexpected error during validation: &quot; + e.message;
        }
        logger.error(errorMsg);

        // Failure: Return an OperationOutcome JSON response with validation errors
        responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMsg, &quot;invalid&quot;)));

        throw new Error(errorMsg);
     }
}

var jdbcUrl = channelMap.get(&quot;jdbcUrl&quot;);
if(jdbcUrl != null) {
    globalMap.put(&apos;jdbcUrl&apos;, jdbcUrl);
    logger.info(&quot;jdbcUrl is loaded into globalMap&quot;);
} else {
    var errorMessage = &apos;MC_JDBC_URL variable is not set&apos;;
    logger.error(errorMessage);
    setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
    throw errorMessage; // Stop further processing by throwing an exception
}

var jdbcUsername = channelMap.get(&quot;JDBC_USERNAME&quot;);
if(jdbcUsername != null) {
    globalMap.put(&apos;jdbcUsername&apos;, jdbcUsername);
    logger.info(&quot;jdbcUsername loaded to globalmap &quot;);
} else {
    var errorMessage = &apos;JDBC_USERNAME missing from Lookup manager (Config-sensitive).&apos;;
    logger.error(errorMessage);
    setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
    throw errorMessage; // Stop further processing by throwing an exception
}
var jdbcPassword = channelMap.get(&quot;JDBC_PASSWORD&quot;);

  if(jdbcPassword != null) {
    globalMap.put(&apos;jdbcPassword&apos;, jdbcPassword);
logger.info(&quot;jdbcPassword loaded successfully.&quot;);
} else {
    var errorMessage = &apos;JDBC_PASSWORD missing from from Lookup manager (Config-sensitive)&apos;;
    logger.error(errorMessage);
    setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
    throw errorMessage; // Stop further processing by throwing an exception
}</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.6.1">
          <name>step_validate_profile_urls_env_variables</name>
          <sequenceNumber>3</sequenceNumber>
          <enabled>true</enabled>
          <script>/**
* Util function to generate a hash string using sha-256 that can be used as the resource id in FHIR Bundle.
*/
function generateSHA256(inputString) {
    var md = Packages.java.security.MessageDigest.getInstance(&quot;SHA-256&quot;);
    md.update(inputString.getBytes(&quot;UTF-8&quot;));   
    var digest = md.digest();
    return bytesToHex(digest);
}

function bytesToHex(byteArray) {
    var hexString = new java.lang.StringBuilder();
    for (var i = 0; i &lt; byteArray.length; i++) {
        var hex = java.lang.Integer.toHexString(0xff &amp; byteArray[i]);
        if (hex.length == 1) hexString.append(&apos;0&apos;);
        hexString.append(hex);
    }
    return hexString.toString();
}
/////////////////////////////////S/////////////////////////////////
function getPatientMRN(patientRoles) {
    var extensionAttr = &apos;&apos;;
    var ehrVendor = channelMap.get(&apos;ehrVendor&apos;);

    function isSSNFormat(ext) {
    	    return (
	        ext &amp;&amp; 
	        String.fromCharCode(ext.charCodeAt(3)) == &apos;-&apos; &amp;&amp;
	        String.fromCharCode(ext.charCodeAt(6)) == &apos;-&apos; &amp;&amp;
	        /^\d{3}-\d{2}-\d{4}$/.test(ext)
	    );
    }

	if (patientRoles != undefined) {
        var patientRole = patientRoles;
        var idNodes = patientRole.*::id;

        // Step 1: Check for Medent MRN
        if (ehrVendor == &apos;Medent&apos;) {
             for each (var idNode in idNodes) {
                var root = idNode.@root.toString();
                var ext = idNode.@extension.toString();

                if (root !== &quot;2.16.840.1.113883.4.1&quot; &amp;&amp; !isSSNFormat(ext)) {
                    extensionAttr = ext;
                    logger.info(&quot;Patient MRN (Medent): &quot; + extensionAttr);
                    break;
                }
            }
        }
	   // Step 2: Athenahealth MRN (from first ID, after &quot;P-&quot;)
        else if (ehrVendor == &apos;Athenahealth&apos;) {
            for each (var idNode in idNodes) {
                var ext = idNode.@extension.toString();

                // Only process if &quot;P-&quot; exists
                if (ext.indexOf(&quot;P-&quot;) &gt; -1) {
                    var mrnPart = ext.split(&quot;P-&quot;)[1]; // part after &quot;P-&quot;
                    // Check if the extracted part is not SSN
                    if (!isSSNFormat(mrnPart)) {
                        extensionAttr = mrnPart;
                        logger.info(&quot;Patient MRN (Athenahealth): &quot; + extensionAttr);
                        break; // Only first valid occurrence
                    }
                }
            }
        }
	   else if (ehrVendor == &apos;Epic&apos;){	
        // Step 3: If Epic
            for each (var idNode in idNodes) {
                var root = idNode.@root.toString();
                var ext = idNode.@extension.toString();
                var assigningAuthorityName = idNode.@assigningAuthorityName.toString();

                if (assigningAuthorityName === &quot;EPI&quot; &amp;&amp;
                    (root === &quot;1.2.840.114350.1.13.570.2.7.5.737384.14&quot; || root !== &quot;1.2.840.114350.1.1&quot;) &amp;&amp;
                    !isSSNFormat(ext)
                ) {
                    extensionAttr = ext;
                    logger.info(&quot;Patient MRN (Epic): &quot; + extensionAttr);
                    break;
                }
            }
	   }
	   else {
	   	//fallback to id.extension
	   	for each (var idNode in idNodes) {
                var ext = idNode.@extension.toString();
                if (!isSSNFormat(ext)) {
                    extensionAttr = ext;
                    logger.info(&quot;Patient MRN (Epic): &quot; + extensionAttr);
                    break;
                }
            }
	   }        
    } else {
        logger.error(&quot;PatientRole not found in the XML.&quot;);
    }

    if (!extensionAttr) {
       logger.warn(&quot;No matching MRN found.&quot;);
    }

    channelMap.put(&apos;Patient-MRN&apos;, extensionAttr);
}
////////////////////////////////E////////////////////////////////////////////
function getEncounterEffectiveTime(encounterNodeList) {
    var fallbackTime = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SS&apos;Z&apos;&quot;).format(new java.util.Date());
    var effectiveTimeOut = &apos;&apos;;

    if (!encounterNodeList || encounterNodeList.length === 0) {	
        return fallbackTime;
    }

    var encounterNode = encounterNodeList[0];

    // Try to get low/@value
    var lowValue = encounterNode.*::effectiveTime.*::low.@value.toString();
    if (lowValue &amp;&amp; lowValue.length &gt; 0) {
        logger.info(&quot;effectiveTime (low): &quot; + lowValue);
        return lowValue;
    }

    // Try to get effectiveTime/@value
    var directValue = encounterNode.*::effectiveTime.@value.toString();
    if (directValue &amp;&amp; directValue.length &gt; 0) {
        logger.info(&quot;effectiveTime (direct): &quot; + directValue);
        return directValue;
    }

    return fallbackTime;
}

function generateSHA256Id(resource, resourceName, resourceIdName, transformer, additionalString) {
    if (resource != undefined) { 
        // Get MRN and CIN from channelMap
        var mrn = channelMap.get(&apos;Patient-MRN&apos;) || &quot;&quot;;
        var cin = channelMap.get(&apos;patientCIN&apos;) || &quot;&quot;;
        var combinedText = mrn + cin;

        if (typeof additionalString !== &apos;undefined&apos; &amp;&amp; additionalString != null &amp;&amp; additionalString !== &apos;&apos;) {
            combinedText += additionalString;
            logger.info(&quot;Including additionalString in SHA-256: &quot; + additionalString);
        }

        var resourceText = resourceName + resource.toString().trim();
        combinedText += resourceText;

        // Generate SHA-256 hash
        var sha256Hash = generateSHA256(new java.lang.String(combinedText));
        transformer.setParameter(resourceIdName, sha256Hash);
        logger.info(resourceIdName + &quot; : &quot; + sha256Hash);
    } else {
        logger.error(resourceName + &quot; not found in the XML.&quot;);
    }

    return transformer;
}

function getCategoryDisplay(code) {
    switch (code) {
        case &apos;71802-3&apos;:
            return &apos;Housing Instability&apos;;
        case &apos;96778-6&apos;:
            return &apos;Inadequate Housing&apos;;
        case &apos;96779-4&apos;:
            return &apos;Utility Insecurity&apos;;
        case &apos;88122-7&apos;:
        case &apos;88123-5&apos;:
            return &apos;Food Insecurity&apos;;
        case &apos;93030-5&apos;:
            return &apos;Transportation Insecurity&apos;;
        case &apos;96780-2&apos;:
            return &apos;Employment Status&apos;;
        case &apos;96782-8&apos;:
        case &apos;95618-5&apos;:
        case &apos;95617-7&apos;:
        case &apos;95616-9&apos;:
        case &apos;95615-1&apos;:
        case &apos;95614-4&apos;:
            return &apos;SDOH Category Unspecified&apos;;
        default:
            return &apos;SDOH Category Unspecified&apos;;
    }
}

function getCategoryCode(code) {
    switch (code) {
        case &apos;71802-3&apos;:
            return &apos;housing-instability&apos;;
        case &apos;96778-6&apos;:
            return &apos;inadequate-housing&apos;;
        case &apos;96779-4&apos;:
            return &apos;utility-insecurity&apos;;
        case &apos;88122-7&apos;:
        case &apos;88123-5&apos;:
            return &apos;food-insecurity&apos;;
        case &apos;93030-5&apos;:
            return &apos;transportation-insecurity&apos;;
        case &apos;96780-2&apos;:
            return &apos;employment-status&apos;;
        case &apos;96782-8&apos;:
        case &apos;95618-5&apos;:
        case &apos;95617-7&apos;:
        case &apos;95616-9&apos;:
        case &apos;95615-1&apos;:
        case &apos;95614-4&apos;:
            return &apos;sdoh-category-unspecified&apos;;
        default:
            return null;
    }
}

// Define Namespace Resolver
function getObservationCategoryCodes(transformer, observations) {    
    var xml = new XML(observations); // Parse the source message as XML    
    var ccda = new Namespace(&quot;urn:hl7-org:v3&quot;); // Define the CCDA namespace    
    default xml namespace = ccda; // Set default namespace so ccda tags can be used without prefix

    // Extract all observation code attributes
    if (channelMap.get(&apos;ehrVendor&apos;) == &apos;Medent&apos; || channelMap.get(&apos;ehrVendor&apos;)  == &apos;Athenahealth&apos;) {
	    var codes = xml..component
	                   .structuredBody
	                   .component
	                   .section.(@ID == &apos;observations&apos;)
	                   .entry
	                   .observation
	                   .entryRelationship
	                   .observation
	                   .code.@code;
     }
     else {
     	var codes = xml..component
	                   .structuredBody
	                   .component
	                   .section.(@ID == &apos;observations&apos;)
	                   .entry
	                   .observation
	                   .entryRelationship
	                   .observation
	                   .entryRelationship
	                   .observation
	                   .code.@code;
     }

	// collect unique category codes
	var categorySet = {};
	for (var i = 0; i &lt; codes.length(); i++) {
	    var code = getCategoryCode(codes[i].toString().trim());
	    if (code &amp;&amp; !(code in categorySet)) {
	        categorySet[code] = getCategoryDisplay(codes[i].toString().trim());  
	    }
	}
	
	var categoryJsonArray = [];
	for (var code in categorySet) {
	    categoryJsonArray.push({
	        code: code,
	        display: categorySet[code]
	    });
	}

	//Build Category json from Category codes to pass to the xslt file as transformer parameter
	var categoryXml = &apos;[&apos;;
	for (var i = 0; i &lt; categoryJsonArray.length; i++) {
	    categoryXml += &apos;{&apos; +
	        &apos;&quot;system&quot;: &quot;http://hl7.org/fhir/us/sdoh-clinicalcare/CodeSystem/SDOHCC-CodeSystemTemporaryCodes&quot;,&apos; +
	        &apos;&quot;code&quot;: &quot;&apos; + categoryJsonArray[i].code + &apos;&quot;,&apos; +
	        &apos;&quot;display&quot;: &quot;&apos; + categoryJsonArray[i].display + &apos;&quot;}&apos;;
	
	    if (i !== categoryJsonArray.length - 1) {
	        categoryXml += &apos;,&apos;;
	    }
	}	
	categoryXml += &apos;]&apos;;              
	
	// set context variable
	//msg[&apos;categoryXml&apos;] = categoryXml;
	transformer.setParameter(&apos;categoryXml&apos;, categoryXml);
	logger.info(&quot;categoryXml : &quot; + categoryXml);
	return transformer;
}

function getMultipleAnswersForComponent(transformer, observations) {
	if (observations == null) {
        return transformer;
    }
    
    //var xml = new XML(observations); // Parse the source message as XML    
    var xml;
    try {
        xml = new XML(observations.toString()); // Safely parse the XML
    } catch (e) {
        logger.error(&quot;Error parsing observations XML: &quot; + e.toString());
        return transformer;
    }
    var ccda = new Namespace(&quot;urn:hl7-org:v3&quot;); // Define the CCDA namespace    
    default xml namespace = ccda; // Set default namespace so ccda tags can be used without prefix
    var matchingObservations = [];

    // Extract all observation code attributes
    try {
	    if (channelMap.get(&apos;ehrVendor&apos;) == &apos;Medent&apos; || channelMap.get(&apos;ehrVendor&apos;)  == &apos;Athenahealth&apos;) {
		    matchingObservations = xml..component
		        .structuredBody
		        .component
		        .section.(@ID == &apos;observations&apos;)
		        .entry
		        .observation
		        .entryRelationship
		        .observation.(code.@code == &apos;96778-6&apos;);
	     }
	     else {
	     	matchingObservations = xml..component
		        .structuredBody
		        .component
		        .section.(@ID == &apos;observations&apos;)
		        .entry
		        .observation
		        .entryRelationship
		        .observation
		        .entryRelationship
		        .observation.(code.@code == &apos;96778-6&apos;);
	     }
     } catch (err) {
        logger.error(&quot;XPath error while extracting observations: &quot; + err.toString());
        return transformer;
    }

	var seenCodes = {};
	var codingArray = [];
	
	for each (var obs in matchingObservations) {
	    for each (var val in obs.value) {
	        var code = val.@code.toString();
	        var display = val.@displayName.toString();
	
	        if (code &amp;&amp; !seenCodes[code]) {
	            codingArray.push({
	                &quot;system&quot;: &quot;http://loinc.org&quot;,
	                &quot;code&quot;: code,
	                &quot;display&quot;: display
	            });
	            seenCodes[code] = true;
	        }
	    }
	}

	transformer.setParameter(&apos;componentAnswersXml&apos;, JSON.stringify(codingArray));
	logger.info(&quot;componentAnswersXml : &quot; + JSON.stringify(codingArray));
	return transformer;
}

// Define Namespace Resolver
function setResourceIdParameters(transformer) {
    	// Parse XML
	var sourceXml = $(&apos;phi_filtered_ccd&apos;);
	var xmlDoc = new XML(sourceXml);
	default xml namespace = &quot;urn:hl7-org:v3&quot;;
	
	// Generate Bundle resource Id
	var ccda_fhir_bundle_id = channelMap.get(&apos;interactionId&apos;);
	if (ccda_fhir_bundle_id) {
		transformer.setParameter(&apos;bundleId&apos;, ccda_fhir_bundle_id);
		logger.info(&apos;bundleId : &apos; + ccda_fhir_bundle_id);
	}
	else {
		transformer = generateSHA256Id(xmlDoc, &quot;ClinicalDocument&quot;, &quot;bundleId&quot;, transformer);
	}
	
	// Extract `patientRole`
	var patientRoles = xmlDoc.*::recordTarget.*::patientRole[0];
	//getPatientMRN(patientRoles);
	transformer = generateSHA256Id(patientRoles, &quot;patientRole&quot;, &quot;patientResourceId&quot;, transformer);
	
	// Extract `consent`
	var consent = xmlDoc.*::authorization.*::consent[0];
	var currentTimestamp = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SS&apos;Z&apos;&quot;).format(new java.util.Date());
	transformer = generateSHA256Id(consent, &quot;consent&quot;, &quot;consentResourceId&quot;, transformer, currentTimestamp);
	
	// Extract `author (organization)`
	var author = xmlDoc.*::author[0];
	transformer = generateSHA256Id(author, &quot;Author&quot;, &quot;organizationResourceId&quot;, transformer);

	// Extract `Questionnaire`
	var Questionnaire = xmlDoc.*::component
                              .*::structuredBody
                              .*::component
                              .*::section.(@ID != &apos;sexualOrientation&apos;)
                              .*::entry;
	transformer = generateSHA256Id(Questionnaire, &quot;Questionnaire&quot;, &quot;questionnaireResourceId&quot;, transformer);
	
	// Extract `observations`
	try {
		var observations = xmlDoc.*::component
	                         .*::structuredBody
	                         .*::component
	                         .*::section.(@ID == &apos;observations&apos;)
	                         .*::entry
	                         .*::observation
	                         .*::entryRelationship
	                         .*::observation
	                         .*::entryRelationship;
		transformer = generateSHA256Id(observations, &quot;observations&quot;, &quot;observationResourceSha256Id&quot;, transformer);
	} catch (e) {
	    logger.error(&quot;Error accessing Observations: &quot; + e);
	}
	
	// Extract `sexualOrientation`
	var sexualOrientation = xmlDoc.*::component
                              .*::structuredBody
                              .*::component
                              .*::section.(@ID == &apos;sexualOrientation&apos;)
                              .*::entry
                              .*::observation;
	transformer = generateSHA256Id(sexualOrientation, &quot;sexualOrientation&quot;, &quot;sexualOrientationResourceId&quot;, transformer);

	// Extract `encompassingEncounter`
	try {
		var encounter = xmlDoc.*::componentOf.*::encompassingEncounter;
		if (encounter != undefined &amp;&amp; encounter.length() &gt; 0) {
		    var encounterEffectiveTime = getEncounterEffectiveTime(encounter);	
		    transformer = generateSHA256Id(encounter, &quot;encounter&quot;, &quot;encounterResourceId&quot;, transformer, encounterEffectiveTime);
		} else {
		    // Try fallback to `encounter`
		    var encounters = xmlDoc.*::component
	                     .*::structuredBody
	                     .*::component
	                     .*::section.(@ID == &apos;encounters&apos;)
	                     .*::entry[0]
	                     .*::encounter;
		    if (encounters != undefined &amp;&amp; encounters.length() &gt; 0) {
		        var encounterEffectiveTime = getEncounterEffectiveTime(encounters);
		        transformer = generateSHA256Id(encounters, &quot;encounter&quot;, &quot;encounterResourceId&quot;, transformer, encounterEffectiveTime);
		    } else {
		        logger.error(&quot;Encounter resource not found in the XML.&quot;);
		    }
		}
	} catch (e) {
	    logger.error(&quot;Error accessing encounter: &quot; + e);
	}

	///Grouper Observation Resource 
	var mrn = channelMap.get(&apos;Patient-MRN&apos;) || &quot;&quot;;
     var cin = channelMap.get(&apos;patientCIN&apos;) || &quot;&quot;;
     var currentTimestamp = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SS&apos;Z&apos;&quot;).format(new java.util.Date());
	var combinedText = mrn + cin + &apos;Grouper Observation Resource&apos; + currentTimestamp;
     var sha256Hash = generateSHA256(new java.lang.String(combinedText)); 
    
     transformer.setParameter(&apos;grouperObservationResourceSha256Id&apos;, sha256Hash);
     logger.info(&apos;grouperObservationResourceSha256Id&apos; + &quot; : &quot; + sha256Hash);

     transformer = getObservationCategoryCodes(transformer, sourceXml); //observations
     transformer = getMultipleAnswersForComponent(transformer, sourceXml); //observations

     //For Epic files, use the value of the header variable,&apos;X-TechBD-Screening-Code&apos;, as the Grouper Screening Code, otherwise use the LOINC code &apos;100698-0&apos;
     //For Medent files, take the value from code.code
     var grouperScreeningCode = channelMap.get(&apos;X-TechBD-Screening-Code&apos;);
     if ((channelMap.get(&apos;ehrVendor&apos;) == &apos;Epic&apos; || channelMap.get(&apos;ehrVendor&apos;) == &apos;Athenahealth&apos;)
     	&amp;&amp; (!grouperScreeningCode || grouperScreeningCode.trim() === &apos;&apos;)) {
	    grouperScreeningCode = &apos;100698-0&apos;;
	    logger.info(&quot;Defaulting grouperScreeningCode to 100698-0 for Epic&quot;);
	}
	if (!grouperScreeningCode) {
	    grouperScreeningCode = &apos;&apos;;
	}
     transformer.setParameter(&apos;grouperScreeningCode&apos;, String(grouperScreeningCode));
     logger.info(&apos;grouperScreeningCode&apos; + &quot; : &quot; + grouperScreeningCode);

	// Extract `location`
     try {
	    var location;
	    var location_name;
	    var location_address;
	
	    // Primary location path: componentOf → encompassingEncounter → location → healthCareFacility → location
	    if (
	        xmlDoc.componentOf &amp;&amp;
	        xmlDoc.componentOf.encompassingEncounter &amp;&amp;
	        xmlDoc.componentOf.encompassingEncounter.location &amp;&amp;
	        xmlDoc.componentOf.encompassingEncounter.location.healthCareFacility &amp;&amp;
	        xmlDoc.componentOf.encompassingEncounter.location.healthCareFacility.location
	    ) {
	        location = xmlDoc.componentOf.encompassingEncounter.location.healthCareFacility.location;
	        location_name = xmlDoc.componentOf.encompassingEncounter.location.healthCareFacility.location.name;
	        location_address = xmlDoc.componentOf.encompassingEncounter.location.healthCareFacility.location.addr;
	    }
	
	    // Fallback path: structuredBody → encounters section → encounter → participant → participantRole → playingEntity → name
	    if (!location || location.length() == 0) {
	        var section = xmlDoc.component.structuredBody.component.section.(@ID == &apos;encounters&apos;);
	        if (
	            section &amp;&amp;
	            section.entry &amp;&amp;
	            section.entry.length() &gt; 0 &amp;&amp;
	            section.entry[0].encounter &amp;&amp;
	            section.entry[0].encounter.participant &amp;&amp;
	            section.entry[0].encounter.participant.participantRole &amp;&amp;
	            section.entry[0].encounter.participant.participantRole.playingEntity
	        ) {
	            location = section.entry[0].encounter.participant.participantRole;
	            location_name = section.entry[0].encounter.participant.participantRole.playingEntity.name;
	            location_address = section.entry[0].encounter.participant.participantRole.addr;
	        }
	    }
	
	    if (
	        location &amp;&amp;
	        location_name != undefined &amp;&amp; location_name.toString().trim() !== &quot;&quot; &amp;&amp;
	        location_address != undefined &amp;&amp; location_address.toString().trim() !== &quot;&quot;
	    ) {
	        transformer = generateSHA256Id(location, &quot;Location&quot;, &quot;locationResourceId&quot;, transformer);
	    } else {
	        logger.info(&quot;Location not found in the XML.&quot;);
	    }
	
	} catch (e) {
	    logger.info(&quot;Error accessing location: &quot; + e);
	}
     	
	return transformer;
}

/**
* Util function to get FHIR resource profile URLs and set as parameters to the transformer which converts the XML file to FHIR Bundle.
*/
function set_profile_url(transformer, profileUrl, urlEnv, metaProfileUrlName) {
	if(profileUrl != null) {
		transformer.setParameter(metaProfileUrlName, profileUrl);
		channelMap.put(metaProfileUrlName, profileUrl);
		logger.info(metaProfileUrlName + &quot;: &quot; + profileUrl);
	} else {
		var errorMessage = urlEnv + &apos; variable is not set&apos;;
		logger.error(errorMessage);
		setErrorResponse(500, errorMessage); // Set the HTTP response status to 500 (Server error)
		throw errorMessage; // Stop further processing by throwing an exception
	}
	return transformer;
}

function set_fhir_resource_profile_urls(transformer) {
	var baseFhirUrl = LookupHelper.get(&quot;Config&quot;, &quot;BASE_FHIR_URL&quot;, ttlHours);   
	var bundleMetaProfileUrl = LookupHelper.get(&quot;Config&quot;, &quot;PROFILE_URL_BUNDLE&quot;, ttlHours); 
	var patientMetaProfileUrl = LookupHelper.get(&quot;Config&quot;, &quot;PROFILE_URL_PATIENT&quot;, ttlHours);
	var encounterMetaProfileUrl = LookupHelper.get(&quot;Config&quot;, &quot;PROFILE_URL_ENCOUNTER&quot;, ttlHours);
	var consentMetaProfileUrl = LookupHelper.get(&quot;Config&quot;, &quot;PROFILE_URL_CONSENT&quot;, ttlHours); 
	var organizationMetaProfileUrl = LookupHelper.get(&quot;Config&quot;, &quot;PROFILE_URL_ORGANIZATION&quot;, ttlHours);
	var observationMetaProfileUrl = LookupHelper.get(&quot;Config&quot;, &quot;PROFILE_URL_OBSERVATION&quot;, ttlHours);
	var observationSexualOrientationMetaProfileUrl = LookupHelper.get(&quot;Config&quot;, &quot;PROFILE_URL_SEXUAL_ORIENTATION&quot;, ttlHours);
	var questionnaireMetaProfileUrl = LookupHelper.get(&quot;Config&quot;, &quot;PROFILE_URL_QUESTIONNAIRE&quot;, ttlHours);
	var questionnaireResponseMetaProfileUrl = LookupHelper.get(&quot;Config&quot;, &quot;PROFILE_URL_QUESTIONNAIRE_RESPONSE&quot;, ttlHours);
	var practitionerMetaProfileUrl = LookupHelper.get(&quot;Config&quot;, &quot;PROFILE_URL_PRACTITIONER&quot;, ttlHours);
	var procedureMetaProfileUrl = LookupHelper.get(&quot;Config&quot;, &quot;PROFILE_URL_PROCEDURE&quot;, ttlHours);
	var locationMetaProfileUrl = LookupHelper.get(&quot;Config&quot;, &quot;PROFILE_URL_LOCATION&quot;, ttlHours);
	//logger.info(&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*************************???????????????????????????????&quot; + &quot;: &quot; + locationMetaProfileUrl);
	//&quot;http://hl7.org/fhir/us/sdoh-clinicalcare/StructureDefinition/SDOHCC-Location&quot;;

	transformer = set_profile_url(transformer, baseFhirUrl, &apos;BASE_FHIR_URL&apos;, &apos;baseFhirUrl&apos;);
	transformer = set_profile_url(transformer, bundleMetaProfileUrl, &apos;PROFILE_URL_BUNDLE&apos;, &apos;bundleMetaProfileUrl&apos;);
	transformer = set_profile_url(transformer, patientMetaProfileUrl, &apos;PROFILE_URL_PATIENT&apos;, &apos;patientMetaProfileUrl&apos;);
	transformer = set_profile_url(transformer, encounterMetaProfileUrl, &apos;PROFILE_URL_ENCOUNTER&apos;, &apos;encounterMetaProfileUrl&apos;);
	transformer = set_profile_url(transformer, consentMetaProfileUrl, &apos;PROFILE_URL_CONSENT&apos;, &apos;consentMetaProfileUrl&apos;);
	transformer = set_profile_url(transformer, organizationMetaProfileUrl, &apos;PROFILE_URL_ORGANIZATION&apos;, &apos;organizationMetaProfileUrl&apos;);
	transformer = set_profile_url(transformer, observationMetaProfileUrl, &apos;PROFILE_URL_OBSERVATION&apos;, &apos;observationMetaProfileUrl&apos;);
	transformer = set_profile_url(transformer, observationSexualOrientationMetaProfileUrl, &apos;PROFILE_URL_SEXUAL_ORIENTATION&apos;, &apos;observationSexualOrientationMetaProfileUrl&apos;);
	transformer = set_profile_url(transformer, questionnaireMetaProfileUrl, &apos;PROFILE_URL_QUESTIONNAIRE&apos;, &apos;questionnaireMetaProfileUrl&apos;);
	transformer = set_profile_url(transformer, questionnaireResponseMetaProfileUrl, &apos;PROFILE_URL_QUESTIONNAIRE_RESPONSE&apos;, &apos;questionnaireResponseMetaProfileUrl&apos;);
	transformer = set_profile_url(transformer, practitionerMetaProfileUrl, &apos;PROFILE_URL_PRACTITIONER&apos;, &apos;practitionerMetaProfileUrl&apos;);
	transformer = set_profile_url(transformer, procedureMetaProfileUrl, &apos;PROFILE_URL_PROCEDURE&apos;, &apos;procedureMetaProfileUrl&apos;);
	transformer = set_profile_url(transformer, locationMetaProfileUrl, &apos;PROFILE_URL_LOCATION&apos;, &apos;locationMetaProfileUrl&apos;);

	transformer.setParameter(&quot;patientCIN&quot;, channelMap.get(&apos;patientCIN&apos;)); // Pass the parameter to XSLT
	if (channelMap.get(&apos;organizationNPI&apos;)) {
		transformer.setParameter(&quot;organizationNPI&quot;, channelMap.get(&apos;organizationNPI&apos;)); // Pass the parameter to XSLT
	}		
	if (channelMap.get(&apos;organizationTIN&apos;)) {
		transformer.setParameter(&quot;organizationTIN&quot;, channelMap.get(&apos;organizationTIN&apos;)); // Pass the parameter to XSLT
	}
	if (channelMap.get(&apos;facilityID&apos;)) {
		transformer.setParameter(&quot;facilityID&quot;, channelMap.get(&apos;facilityID&apos;)); // Pass the parameter to XSLT
	}
	if (channelMap.get(&apos;encounterType&apos;)) {
		transformer.setParameter(&quot;encounterType&quot;, channelMap.get(&apos;encounterType&apos;)); // Pass the parameter to XSLT
	}

	//Generate resource ids and set as parameter to pass to xslt 
	transformer = setResourceIdParameters(transformer);
	
	return transformer;
}

/**
*	Function to Check the existance of Consent section in the CCDA xml file and set the header variable &apos;X-TechBD-Elaboration&apos;.
*	This function is called while the /Bundle request
*/
function getConsentResourceStatus(sourceXml) {
	try {
		var consentInfo = {};
	    	consentInfo.code = &apos;Consent-Status&apos;;
	    	consentInfo.status = &quot;TechBD-Generated&quot;;
	    	///////////////////////////////////////////////////////////////////////////////////////////////
	    	var ehrVendor = (channelMap.get(&apos;ehrVendor&apos;) || &apos;&apos;).toLowerCase();
	    	var ccdaConsentCode = ehrVendor == &apos;athenahealth&apos; ? &apos;29762-2&apos; : &apos;47519-4&apos;;
		///////////////////////////////////////////////////////////////////////////////////////////
		var xmlDoc = new XML(sourceXml); // Convert XML string to XML object			
		default xml namespace = &quot;urn:hl7-org:v3&quot;; // Default namespace for HL7 documents
	///////////////////////////////////s//////////////////////////////////////
		// If consent section is there, the consentInfo.status should be &quot;provided&quot;.
		var consentSection = xmlDoc.*::authorization.*::consent;
		if (consentSection != null &amp;&amp; consentSection.length() &gt; 0) {
			consentInfo.status = &quot;provided&quot;;
		}
		///////////////////////////////e//////////////////////////
		else {
			// Iterate through all &lt;section&gt; elements
			for each (var section in xmlDoc..section) {
			    var sectionCode = section.code.@code.toString();
			
			    if (sectionCode == ccdaConsentCode) {
			        // Inside the correct section
			        for each (var entry in section.entry) {
			            for each (var observation in entry.observation) {
			                for each (var entryRel in observation.entryRelationship) {
			                    for each (var nestedObs in entryRel.observation) {
			                        var obsCode = nestedObs.code.@code.toString();
			                        if (obsCode == &quot;105511-0&quot;) {
			                            consentInfo.status = &quot;provided&quot;;
			                            break;
			                        }
			                    }
			                }
			            }
			        }
			    }
			}
		}		
		// Convert to JSON string (optional, for sending/logging)
		var consentJsonString = JSON.stringify(consentInfo);
		logger.info(&quot;Consent Info JSON: &quot; + consentJsonString);
		channelMap.put(&apos;elaboration&apos;, consentJsonString);
	} catch (e) {
        var errorMsg;
        if (e instanceof JavaException) {
           errorMsg = &quot;Error parsing Consent Resource: &quot; + e.toString();
        } else {
           errorMsg = &quot;Unexpected error during getting Consent Resource: &quot; + e.message;
        }
        logger.error(errorMsg);

        // Failure: Return an OperationOutcome JSON response with validation errors
        responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMsg, &quot;invalid&quot;)));

        throw new Error(errorMsg);
     }
}</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.6.1">
          <name>Validate Mandatory Fields</name>
          <sequenceNumber>4</sequenceNumber>
          <enabled>true</enabled>
          <script>/**
 * Validate mandatory fields for CCDA → FHIR conversion
 * @return null OR OperationOutcome JSON
 */
function validateMandatoryFields() {
    	var sourceXml = channelMap.get(&apos;phi_filtered_ccd&apos;);
	var ccdaXml = new XML(sourceXml);
	default xml namespace = &quot;urn:hl7-org:v3&quot;;
	var errors = [];

	var patientRole = ccdaXml.*::recordTarget.*::patientRole[0];
	getPatientMRN(patientRole);
	
    	// --------------------------------------------------------------------------------------------------------------------
    	// I. Patient Resource
    	// -----------------------------
    	// 1. PatientRole existence
    	try {	   
    		if (!patientRole || patientRole.length() === 0) {
	        errors.push(&quot;PatientRole is missing. FHIR Patient resource cannot be created.&quot;);
	    	} else {
	        var patient = patientRole.*::patient[0];
	        // 2. Patient Name
	        var name = patient ? patient.*::name[0] : null;
	        var givenName = name ? name.*::given.toString() : &quot;&quot;;
	        var familyName = name ? name.*::family.toString() : &quot;&quot;;
	        if (!givenName) { errors.push(&quot;Patient name (given) -&gt; ClinicalDocument.recordTarget.patientRole.patient.name.given.&quot;); }
		   if (!familyName) { errors.push(&quot;Patient name (family) -&gt; ClinicalDocument.recordTarget.patientRole.patient.name.family.&quot;); }

	        // 3. Gender
	        var genderCode = &quot;&quot;;
			if (patient) {
			    var genderEl = patient.*::administrativeGenderCode[0];
			    if (genderEl &amp;&amp; genderEl.@code) {
			        genderCode = genderEl.@code.toString();
			    }
			}			
			if (genderCode === &quot;&quot;) {
			    errors.push(&quot;Patient gender -&gt; ClinicalDocument.recordTarget.patientRole.patient.administrativeGenderCode.&quot;);
			}

	        // 4. Birth Date
	        var birthDate = &quot;&quot;;
		   if (patient) {
			    var birthEl = patient.*::birthTime[0];
			    if (birthEl &amp;&amp; birthEl.@value) {
			        birthDate = birthEl.@value.toString();
			    }
		   }			
		   if (birthDate === &quot;&quot;) {
			    errors.push(&quot;Patient birthDate -&gt; ClinicalDocument.recordTarget.patientRole.patient.birthTime.&quot;);
		   }
	
		   // 5. Patient MRN
	       var patientMrn = channelMap.get(&apos;Patient-MRN&apos;);
		   if (patientMrn === null || String(patientMrn).trim() === &quot;&quot;) {
		   		errors.push(&quot;Patient MRN -&gt; ClinicalDocument.recordTarget.patientRole.id.extension.&quot;);
		   }
	    	}
    	} catch (e) {
	    logger.error(&quot;Error accessing patientRole: &quot; + e);
	}

    	// --------------------------------------------------------------------------------------------------------------------
    	// II. Encounter Resource
    	// -----------------------------
    	/*try {
	     var encompassingEncounter = ccdaXml.*::componentOf.*::encompassingEncounter[0];
		if (encompassingEncounter) {
		    // 1. Encounter class
		    var encounterClass = encompassingEncounter.*::code.@code.toString();
		    if (!encounterClass) {
		        errors.push(&quot;Encounter class -&gt; ClinicalDocument.componentOf.encompassingEncounter.code.code.&quot;);
		    }		
		} else {
			logger.info(&quot;encompassingEncounter not found&quot;);

		    // Try fallback to `encounter`
		    var encounters = ccdaXml.*::component
	                     .*::structuredBody
	                     .*::component
	                     .*::section.(@ID == &apos;encounters&apos;)
	                     .*::entry[0]
	                     .*::encounter;
		    if (encounters) {
			    // 1. Encounter class
			    var encounterClass = encounters.*::code.@code.toString();
			    if (!encounterClass) {
			        errors.push(&quot;Encounter class -&gt; ClinicalDocument.component.structuredBody.component.section[code.code=&apos;46240-8&apos;].entry[0].encounter.code.code.&quot;);
			    }			        
		    } else {
		        logger.error(&quot;Encounter Entry not found in the XML.&quot;);
		    }
		}
	} catch (e) {
	    logger.error(&quot;Error accessing encounter: &quot; + e);
	}*/

	// --------------------------------------------------------------------------------------------------------------------
    	// III. Organization (Location / Author Organization)
	// -----------------------------
	var organizationName = &quot;&quot;;
	var organizationNameXPath = &quot;&quot;;
	
	// 1.️ Try Encounter → Location → Organization name
	try {
	    var orgFromEncounter =
	        ccdaXml.*::component
	               .*::structuredBody
	               .*::component
	               .*::section.(@ID == &quot;encounters&quot;)
	               .*::entry[0]
	               .*::encounter
	               .*::participant.(@typeCode == &quot;LOC&quot;)
	               .*::participantRole.(@classCode == &quot;SDLOC&quot;)
	               .*::playingEntity
	               .*::name[0];
	
	    if (orgFromEncounter) {
	        organizationName = orgFromEncounter.toString().trim();	      
	    }
	} catch (e) {
	    logger.warn(&quot;Encounter organization name not found.&quot;);
	}
	
	// 2.️ Fallback → assignedAuthor → representedOrganization → name
	if (organizationName === &quot;&quot;) {
	    try {
	        var orgFromAuthor =
	            ccdaXml.*::author[0]
	                   .*::assignedAuthor
	                   .*::representedOrganization
	                   .*::name[0];
	
	        if (orgFromAuthor) {
	            organizationName = orgFromAuthor.toString().trim();
	        }
	    } catch (e) {
	        logger.warn(&quot;Author organization name not found.&quot;);
	    }
	}
		
	// 3.️ Mandatory validation
	organizationNameXPath = &quot;ClinicalDocument.component.structuredBody.component.section[code.code=&apos;46240-8&apos;].entry[0].encounter.participant.participantRole.playingEntity.name. OR ClinicalDocument.author.assignedAuthor.representedOrganization.name.&quot;;
	if (organizationName === &quot;&quot;) {
	    errors.push(&quot;Organization name -&gt; &quot; + organizationNameXPath);
	}
	
	logger.info(&quot;Organization Name resolved as: &quot; + organizationName);

    // -----------------------------
    // Return OperationOutcome if errors exist
    // -----------------------------
    if (errors.length &gt; 0) {
    	   logger.info(errors.toString());			
        return errors;
    }

    return null; // validation passed
}</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.6.1">
          <name>API endpoint processing</name>
          <sequenceNumber>5</sequenceNumber>
          <enabled>true</enabled>
          <script>///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var requestedPath = sourceMap.get(&apos;contextPath&apos;);
logger.info(&quot;Request URL: &quot; + requestedPath);

channelMap.put(&quot;requestUri&quot;, requestedPath);

if (requestedPath == &quot;/&quot;) {
	return;
}

//Extract the name and extension of the file received before processing.
msg = channelMap.get(&apos;fileContent&apos;);
logger.info(&quot;msg: &quot; + msg);
var ttlHours = 24 * 20;
// Route based on the API call
if (requestedPath == &quot;/ccda/Bundle/$validate/&quot; ||
	requestedPath == &quot;/ccda/Bundle/$validate&quot;) {
    // Forward to the channel or logic for $validate
    channelMap.put(&quot;endpoint&quot;, &quot;validate&quot;);

    var interactionId = channelMap.get(&apos;interactionId&apos;);
    var tenantId = channelMap.get(&apos;tenantId&apos;);
    logger.info(&quot;InteractionId: &quot; + interactionId);

    // -----------------------------------
    // 1. Parse XML safely
    // -----------------------------------
    var ccdaXml;
    var sourceXml;

    //try {
	try {
        ccdaXml = new XML(msg);
        sourceXml = ccdaXml.toXMLString();
        if (!sourceXml || sourceXml.length === 0) {
            failAndExit(
                &quot;No XML data received in the request.&quot;,
                &quot;invalid&quot;, &quot;error&quot;,
                interactionId, tenantId, requestedPath
            );
        }
    	} catch (e) {
        failAndExit(
            &quot;XML structure validation failed. &quot; + e.message,
            &quot;invalid&quot;, &quot;error&quot;,
            interactionId, tenantId, requestedPath
        );
    	}

	// -----------------------------------
    	// 2. Pre-processing
    	// -----------------------------------
	//Replace the space in between &quot;X-SDOH-FLO-1570000066-Patient unable to answer&quot; with hiphen
	sourceXml = sourceXml
        .replace(/X-SDOH-FLO-1570000066-Patient unable to answer/g, &quot;X-SDOH-FLO-1570000066-Patient-unable-to-answer&quot;)
        .replace(/X-SDOH-FLO-1570000066-Patient declined/g, &quot;X-SDOH-FLO-1570000066-Patient-declined&quot;);

	validateLowHighDates(sourceXml); //Check the low and high dates in address
	getManufacturerModelName(sourceXml); //Check Manufacturer Model Name and set Vender
	
	// -----------------------------------
    	// 3. PHI Filter
    	// -----------------------------------
    	var phiFilteredXml;
    	try {
        phiFilteredXml = applyPhiFilter(sourceXml);
        channelMap.put(&apos;phi_filtered_ccd&apos;, phiFilteredXml);
        logger.info(&quot;PHI Filtered CCD: &quot; + phiFilteredXml);
    	} catch (e) {
        failAndExit(
            &quot;CCD XML PHI filtering failed. &quot; + e.message,
            &quot;invalid&quot;, &quot;error&quot;,
            interactionId, tenantId, requestedPath
        );
    	}

    	// -----------------------------------
    	// 4. XSD Validation
    	// -----------------------------------
    	try {
		validateAgainstXsd(phiFilteredXml);
        logger.info(&quot;CCD XML is valid according to the XSD.&quot;);
    	} catch (e) {
        failAndExit(
            &quot;CCD XML validation failed. &quot; + e.message,
            &quot;invalid&quot;, &quot;error&quot;,
            interactionId, tenantId, requestedPath
        );
    	}

    	// -----------------------------------
    	// 5. Mandatory fields Validation
    	// -----------------------------------
    	var mandatoryErrors = validateMandatoryFields(phiFilteredXml);
     if (mandatoryErrors &amp;&amp; mandatoryErrors.length &gt; 0) {
        failAndExit(&quot;The following fields are mandatory as per FHIR. \n\n- &quot; + mandatoryErrors.join(&quot;\n- &quot;),
            &quot;invalid&quot;, &quot;error&quot;,
            interactionId, tenantId, requestedPath
        );
     }

	// -----------------------------------
    	// 6. SUCCESS
    	// -----------------------------------
    	var successResponse = getJsonInvalidOperationOutcome(
        &quot;The CCDA XML passed structural (XSD) validation, and all mandatory field validations were successful.&quot;,
        &quot;informational&quot;,
        &quot;information&quot;
    	);

    	responseMap.put(&apos;finalResponse&apos;, JSON.stringify(successResponse));
    	saveCcdaPayload(interactionId, tenantId, requestedPath, successResponse, &quot;saveValidationSuccess&quot;);

    	return &apos;dest_bundle_validate&apos;;

}

///////////////////
else if (requestedPath == &quot;/ccda/Bundle&quot; || requestedPath == &quot;/ccda/Bundle/&quot;) {

	channelMap.put(&quot;endpoint&quot;, &quot;bundle&quot;);

    	var interactionId = channelMap.get(&apos;interactionId&apos;);
    	var tenantId = channelMap.get(&apos;tenantId&apos;);
    	logger.info(&quot;InteractionId: &quot; + interactionId);

	//*********** DATA LEDGER ***************
	    var randomSuffix = Math.floor(Math.random() * 10000);
	    channelMap.put(&apos;uri&apos;, sourceMap.get(&apos;uri&apos;));
	    // Generate current timestamp in ISO format with microsecond precision
	    var currentTimestampBegin = new Date().toISOString().replace(/\.(\d{3})Z$/, function(match, millis) {
		    // Add 3 more random digits to simulate microseconds
		    var micros = millis + (Math.floor(Math.random() * 1000)).toString().padStart(3, &apos;0&apos;);
		    return &apos;.&apos; + micros + &apos;Z&apos;;
	    });	
	
	    var payload = JSON.stringify({
	        executedAt: currentTimestampBegin,
	        actor: &quot;TechBD&quot;,
	        action: &quot;received&quot;, 
	        destination: &quot;TechBD&quot;,
	        dataId: interactionId,
	        payloadType: &quot;hrsnBundle&quot;
	    });
		
		// Check if tracking is enabled
		var trackingEnabled = java.lang.System.getenv(&quot;DATA_LEDGER_TRACKING&quot;);
		if (trackingEnabled != null &amp;&amp; trackingEnabled.toLowerCase() == &quot;true&quot;) {
		    logger.info(&quot;data ledger api call -BEGIN received&quot;);
		    try {
		        sendDataLedgerSync(payload);
		    } catch (e) {
		        logger.error(&quot;Error occurred while sending data to Data Ledger: &quot; + e.message);
		    }
		    logger.info(&quot;data ledger api call -END received&quot;);
		} else {
		    logger.info(&quot;DATA_LEDGER_TRACKING is not true; skipping Data Ledger sync.&quot;);
		}
	//*********** DATA LEDGER ***************


    /* -------------------------------------------------
     * 1. Parse XML safely
     * ------------------------------------------------- */
    var ccdaXml, sourceXml;
    try {
        ccdaXml = new XML(msg);
        sourceXml = ccdaXml.toXMLString();

        if (!sourceXml || sourceXml.length === 0) {
            failAndExit(
                &quot;No XML data received in the request.&quot;,
                &quot;invalid&quot;, &quot;error&quot;,
                interactionId, tenantId, requestedPath
            );
        }
    } catch (e) {
        failAndExit(
            &quot;XML structure validation failed. &quot; + e.message,
            &quot;invalid&quot;, &quot;error&quot;,
            interactionId, tenantId, requestedPath
        );
    }

    /* -------------------------------------------------
     * 2. Pre-processing
     * ------------------------------------------------- */
    sourceXml = sourceXml
        .replace(/X-SDOH-FLO-1570000066-Patient unable to answer/g, &quot;X-SDOH-FLO-1570000066-Patient-unable-to-answer&quot;)
        .replace(/X-SDOH-FLO-1570000066-Patient declined/g, &quot;X-SDOH-FLO-1570000066-Patient-declined&quot;);

    validateLowHighDates(sourceXml);
    getManufacturerModelName(sourceXml); // Get the ehrVendor from manufacturerModelName/softwareName
    getConsentResourceStatus(sourceXml); // Check the existence of Consent section in the CCDA xml file and set the header variable &apos;X-TechBD-Elaboration&apos;

    /* -------------------------------------------------
     * 3. PHI Filter
     * ------------------------------------------------- */
    var phiFilteredXml;
    try {
        phiFilteredXml = applyPhiFilter(sourceXml);
        channelMap.put(&apos;phi_filtered_ccd&apos;, phiFilteredXml);
        logger.info(&quot;PHI Filtered CCD: &quot; + phiFilteredXml);
    } catch (e) {
        failAndExit(
            &quot;CCD XML PHI filtering failed. &quot; + e.message,
            &quot;invalid&quot;, &quot;error&quot;,
            interactionId, tenantId, requestedPath
        );
    }

    /* -------------------------------------------------
     * 4. XSD Validation
     * ------------------------------------------------- */
    try {
        validateAgainstXsd(phiFilteredXml);
        logger.info(&quot;CCD XML is valid according to the XSD.&quot;);
    } catch (e) {
        failAndExit(
            &quot;CCD XML validation failed. &quot; + e.message,
            &quot;invalid&quot;, &quot;error&quot;,
            interactionId, tenantId, requestedPath
        );

        		//*********** DATA LEDGER ***************
        		saveDataLedgerSync(interactionId);
	          /*var  currentTimestamEnd = new Date().toISOString().replace(/\.(\d{3})Z$/, function(match, millis) {
				// Add 3 more random digits to simulate microseconds
				var micros = millis + (Math.floor(Math.random() * 1000)).toString().padStart(3, &apos;0&apos;);
				return &apos;.&apos; + micros + &apos;Z&apos;;
			});
			var payload = JSON.stringify({
		        executedAt: currentTimestamEnd,
		        actor: &quot;TechBD&quot;,
		        action: &quot;sent&quot;, 
		        destination: &quot;Invalid - CCD Conversion Failed&quot;,
		        dataId: interactionId,
		        payloadType: &quot;hrsnBundle&quot;
		  	});		
				
			if (trackingEnabled != null &amp;&amp; trackingEnabled.toLowerCase() == &quot;true&quot;) {
			    logger.info(&quot;data ledger api call -BEGIN sent&quot;);
			   try {
		        sendDataLedgerSync(payload);
			    } catch (e) {
			        logger.error(&quot;Error occurred while sending data to Data Ledger: &quot; + e.message);
			    }
			    logger.info(&quot;data ledger api call -END sent&quot;);
			} else {
			    logger.info(&quot;DATA_LEDGER_TRACKING is not true; skipping Data Ledger sync for sent.&quot;);
			}*/
			//*********** DATA LEDGER ***************
    }

    /* -------------------------------------------------
     * 5. Mandatory Field Validation (FHIR / SHIN-NY)
     * ------------------------------------------------- */
    var mandatoryErrors = validateMandatoryFields(phiFilteredXml);
    if (mandatoryErrors &amp;&amp; mandatoryErrors.length &gt; 0) {
        //failAndExit(mandatoryErrors.join(&quot;\n&quot;),
        failAndExit(&quot;The following fields are mandatory as per FHIR. \n\n- &quot; + mandatoryErrors.join(&quot;\n- &quot;),
            &quot;invalid&quot;, &quot;error&quot;,
            interactionId, tenantId, requestedPath
        );

        //*********** DATA LEDGER ***************
        saveDataLedgerSync(interactionId);
        //*********** DATA LEDGER ***************
    }

    /* -------------------------------------------------
     * 6. Save Validation Result
     * ------------------------------------------------- */
    var successResponse = getJsonInvalidOperationOutcome(
        &quot;The CCDA XML passed structural (XSD) validation, and all mandatory field validations were successful.&quot;,
        &quot;informational&quot;,
        &quot;information&quot;
    );
    saveCcdaPayload(interactionId, tenantId, requestedPath, successResponse, &quot;saveValidationSuccess&quot;);

    /* -------------------------------------------------
     * 7. CCDA → FHIR Bundle Conversion
     * ------------------------------------------------- */
    var cleanedJsonString;
    try {
        cleanedJsonString = convertCcdaToFhirBundle(phiFilteredXml);
    } catch (e) {
        failAndExit(
            &quot;CCD to FHIR conversion failed. &quot; + e.message,
            &quot;exception&quot;, &quot;error&quot;,
            interactionId, tenantId, requestedPath
        );
    }

    /* -------------------------------------------------
     * 8. Save Fhir bundle + Respond
     * ------------------------------------------------- */
    saveCcdaPayload(interactionId, tenantId, requestedPath,
        cleanedJsonString, &quot;saveConversionSuccess&quot;);
        
	channelMap.put(&apos;jsonResult&apos;, cleanedJsonString);
	responseMap.put(&apos;finalResponse&apos;, JSON.stringify(cleanedJsonString));
     return &apos;dest_bundle&apos;;
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//else if (requestedPath == &quot;/ccda/Bundle/&quot; || requestedPath == &quot;/ccda/Bundle&quot;) {
//	channelMap.put(&quot;requestUri&quot;, requestedPath);
//	try {
//	
//	    //*********** DATA LEDGER ***************
//	    var randomSuffix = Math.floor(Math.random() * 10000);
//	    channelMap.put(&apos;uri&apos;, sourceMap.get(&apos;uri&apos;));
//	    // Generate current timestamp in ISO format with microsecond precision
//	
//	   var currentTimestampBegin = new Date().toISOString().replace(/\.(\d{3})Z$/, function(match, millis) {
//	    // Add 3 more random digits to simulate microseconds
//	    var micros = millis + (Math.floor(Math.random() * 1000)).toString().padStart(3, &apos;0&apos;);
//	    return &apos;.&apos; + micros + &apos;Z&apos;;
//	   });
//	
//	
//	    var interactionId = channelMap.get(&apos;interactionId&apos;);
//	    logger.info(&quot;InteractionId: &quot; + interactionId);
//	    var payload = JSON.stringify({
//	        executedAt: currentTimestampBegin,
//	        actor: &quot;TechBD&quot;,
//	        action: &quot;received&quot;, 
//	        destination: &quot;TechBD&quot;,
//	        dataId: interactionId,
//	        payloadType: &quot;hrsnBundle&quot;
//	    });
//	
//	
//		// Check if tracking is enabled
//		var trackingEnabled = globalMap.get(&quot;DATA_LEDGER_TRACKING&quot;);
//		//LookupHelper.get(&quot;Config&quot;, &quot;DATA_LEDGER_TRACKING&quot;, ttlHours);
//		if (trackingEnabled != null &amp;&amp; trackingEnabled.toLowerCase() == &quot;true&quot;) {
//		    logger.info(&quot;data ledger api call -BEGIN received&quot;);
//		    try {
//		        sendDataLedgerSync(payload);
//		    } catch (e) {
//		        logger.error(&quot;Error occurred while sending data to Data Ledger: &quot; + e.message);
//		    }
//		    logger.info(&quot;data ledger api call -END received&quot;);
//		} else {
//		    logger.info(&quot;DATA_LEDGER_TRACKING is not true; skipping Data Ledger sync.&quot;);
//		}
//		//*********** DATA LEDGER ***************
//			
//		channelMap.put(&quot;endpoint&quot;, &quot;bundle&quot;);
//
//		try {
//			var ccda_msg = new XML(msg);
//			var sourceXml = ccda_msg.toXMLString();    		
//		
//		     if (!sourceXml || sourceXml.length === 0) {
//		         logger.error(&quot;No XML data received in the request.&quot;);
//		         responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(&quot;No XML data received in the request.&quot;)));
//		         throw new Error(&quot;No XML data received in the request.&quot;);
//		     }
//		
//			logger.info(&quot;Source XML Content: &quot; + sourceXml); 
//		} catch (e) {
//	            var errorMsg;
//	            if (e instanceof JavaException) {
//	                errorMsg = &quot;XML Structure validation failed: &quot; + e.toString();
//				   var errorResponse = getJsonInvalidOperationOutcome(errorMsg, &quot;invalid&quot;);
//			        var operation = &quot;saveValidationFailed&quot;;
//			        saveCcdaPayload(interactionId, tenantId, requestedPath, errorResponse, operation);
//				   logger.info(&quot;Successfully saved validation failure information&quot;);
//				   
//				   logger.error(&quot;XML Structure validation failed.&quot;);
//		              responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(&quot;XML Structure validation failed.&quot;)));
//		              throw new Error(&quot;XML Structure validation failed.&quot;);	 
//	            } else {
//	                errorMsg = &quot;Unexpected error during saving: &quot; + e.message;
//	            }
//	
//	            // Failure: Return an OperationOutcome JSON response with validation errors
//	            responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMsg, &quot;invalid&quot;)));
//	            logger.error(errorMsg);
//	            throw new Error(errorMsg);
//	     }
//	     
//		//Replace the space in between &quot;X-SDOH-FLO-1570000066-Patient unable to answer&quot; with hiphen
//		sourceXml = sourceXml.replace(/X-SDOH-FLO-1570000066-Patient unable to answer/g, &quot;X-SDOH-FLO-1570000066-Patient-unable-to-answer&quot;);
//		sourceXml = sourceXml.replace(/X-SDOH-FLO-1570000066-Patient declined/g, &quot;X-SDOH-FLO-1570000066-Patient-declined&quot;);
//
//		validateLowHighDates(sourceXml); //Check the low and high dates in address
//	        
//		/*Phi filter ccda file before validation*/
//	     getManufacturerModelName(sourceXml); // Load the XSLT template
//	     getConsentResourceStatus(sourceXml); // Check the existance of Consent section in the CCDA xml file and set the header variable &apos;X-TechBD-Elaboration&apos;
//	     
//		// Load the XSLT template
////		var xsltPath = channelMap.get(&apos;cdaPhiFilter&apos;);
////		var xsltFile = new java.io.File(xsltPath);
////		var xsltStream = new java.io.FileInputStream(xsltFile);
//          var xsltPath = channelMap.get(&apos;cdaPhiFilter&apos;);
//		logger.info(&quot;xsltPath: &quot; + xsltPath);
//		var fileNameWithExt = xsltPath.substring(xsltPath.lastIndexOf(&apos;/&apos;) + 1);
//		var fileName = fileNameWithExt.replace(&apos;.xslt&apos;, &apos;&apos;);
//          logger.info(&quot;Extracted XSLT Key Name: &quot; + fileName);
//
//		var ttlHours = 24 * 20; // Time to live in hours
//		var xsltContent = LookupHelper.get(&quot;SchemaFiles&quot;, fileName , ttlHours);
//		logger.info(&quot;Value from hl7v2-fhir-bundle.xslt : &quot; + xsltContent);
//
//			if (!xsltContent) {
//			    throw new Error(&quot;LookupManager: No XSLT found for key &quot; + fileName);
//			}
//			
//			// Convert XSLT to StreamSource
//			var xsltSource = new javax.xml.transform.stream.StreamSource(
//			    new java.io.StringReader(xsltContent)
//			);
//		
//		// Create the transformer
//		var transformerFactory = javax.xml.transform.TransformerFactory.newInstance();
////		var xsltSource = new javax.xml.transform.stream.StreamSource(xsltStream);
//		var transformer = transformerFactory.newTransformer(xsltSource);
//		
//		// Prepare input and output streams
//		var xmlInputStream = new java.io.StringReader(sourceXml);
//		var xmlOutputStream = new java.io.StringWriter();
//		var originalCcdFile = new javax.xml.transform.stream.StreamSource(xmlInputStream);
//		var phiFilterOutput = new javax.xml.transform.stream.StreamResult(xmlOutputStream);
//		
//		// Perform the transformation
//		try {
//			transformer.transform(originalCcdFile, phiFilterOutput);
//		
//			// Store the transformed XML in the channel map
//			var phiFilteredXml = xmlOutputStream.toString();
//			channelMap.put(&apos;phi_filtered_ccd&apos;, phiFilteredXml);
//			logger.info(&quot;PHI Filtered CCD: &quot; + phiFilteredXml);
//		} catch (e) {
//	            var errorMsg;
//	            if (e instanceof JavaException) {
//	                errorMsg = &quot;CCDA XML phi filtering failed: &quot; + e.toString();
//	            } else {
//	                errorMsg = &quot;Unexpected error during phi filtering: &quot; + e.message;
//	            }
//	
//	            // Failure: Return an OperationOutcome JSON response with validation errors
//	            responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMsg, &quot;invalid&quot;)));
//	            logger.error(errorMsg);
//	            throw new Error(errorMsg);
//	     }
//		/*End of phi filter*/
//	
//	//**/////////CCDA Validation Begin///////////////**///
//		   // Validate CCD
////	        var xsdFilePath = channelMap.get(&apos;xsdFilePath&apos;);
////	        logger.info(&quot;Using XSD file path: &quot; + xsdFilePath);    
////	
////	        // Load the XSD schema
////	        var xsdFile = new java.io.File(xsdFilePath);
////	        var schemaInputStream = new javax.xml.transform.stream.StreamSource(xsdFile);
////	        var schema = javax.xml.validation.SchemaFactory
////	            .newInstance(javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI)
////	            .newSchema(schemaInputStream);&#xd;//&#xd;////============================New Chnges ===========================================//&#xd;//// Validate CCD
//        var xsdFilePath = channelMap.get(&apos;xsdFilePath&apos;);
//        logger.info(&quot;Using XSD file path: &quot; + xsdFilePath);    
//        var xsdFileName = xsdFilePath.substring(xsdFilePath.lastIndexOf(&apos;/&apos;) + 1);
//        logger.info(&quot;Extracted XSD Lookup Key: &quot; + xsdFileName);
//        var xsdContent  = LookupHelper.get(&quot;SchemaFiles&quot;, xsdFileName , ttlHours);
//	   logger.info(&quot;Value from XSD file : &quot; + xsdContent );
//
//			if (!xsdContent ) {
//			    throw new Error(&quot;LookupManager: No XSLT found for key &quot; + xsdFileName);
//			}
////==========================================================================
//		var ttlHours = 24 * 24;
//			
//			var lookupResource = &quot;SchemaFiles&quot;;
//			 
//			var File = Packages.java.io.File;
//               var FileWriter = Packages.java.io.FileWriter;
//
//			
//			var tempDir = new File(&quot;/tmp/cda_xsd_cache&quot;);
//			if (!tempDir.exists()) {
//			    tempDir.mkdirs();
//			}
//			
//			logger.info(&quot;Temp XSD folder = &quot; + tempDir.getAbsolutePath());
//			
//			// ===============================================================
//			// 2. List all XSD files required
//			// ===============================================================
//			var ttl = 24 * 24;
//			
//			logger.info(&quot;=== Loading XSD index from Lookup Manager ===&quot;);
//			var rawIndex = LookupHelper.get(&quot;SchemaFiles&quot;, &quot;index.txt&quot;, ttl);
//			
//			logger.info(&quot;typeof rawIndex = &quot; + typeof rawIndex);
//			logger.info(&quot;rawIndex: &quot; + JSON.stringify(rawIndex));
//			
//			var indexText = null;
//
//				// ========== NORMALIZE rawIndex TO A STRING ==========
//				if (rawIndex == null) {
//				    logger.error(&quot;Lookup returned NULL for index.txt — fallback to empty string&quot;);
//				    indexText = &quot;&quot;;
//				} 
//				else if (typeof rawIndex === &quot;object&quot;) {
//				    // Mirth sometimes returns {content:&quot;text&quot;} OR sometimes the object itself is stringifiable
//				    if (rawIndex.content &amp;&amp; typeof rawIndex.content === &quot;string&quot;) {
//				        indexText = rawIndex.content;
//				    } else {
//				        // Convert entire object to string safely
//				        indexText = String(rawIndex);
//				        logger.warn(&quot;Converted rawIndex OBJECT to string: &quot; + indexText);
//				    }
//				}
//				else if (typeof rawIndex === &quot;string&quot;) {
//				    indexText = rawIndex;
//				} 
//				else {
//				    // Unexpected type (number, boolean, etc)
//				    indexText = String(rawIndex);
//				    logger.warn(&quot;Converted NON-STRING rawIndex to string: &quot; + indexText);
//				}
//				
//				logger.info(&quot;indexText (final extracted): &gt;&gt;&gt;&quot; + indexText + &quot;&lt;&lt;&lt;&quot;);
//				
//				// ========== PARSE INTO ARRAY ==========
//				var xsdFiles = [];
//				
//				if (indexText.trim().length &gt; 0) {
//				    xsdFiles = indexText
//				        .split(/\r?\n/)
//				        .map(function (line) { return line.trim(); })
//				        .filter(function (line) { return line.length &gt; 0; });
//				}
//				
//				logger.info(&quot;Final XSD list: &quot; + JSON.stringify(xsdFiles));
//
//			// ===============================================================
//			// 3. Write each XSD from LookupManager into temp directory
//			// ===============================================================
//			for (var i = 0; i &lt; xsdFiles.length; i++) {
//			    var name = xsdFiles[i];
//			    var content = LookupHelper.get(&quot;SchemaFiles&quot;, name, ttl);
//			
//			    if (!content || content.trim().length === 0) {
//			        throw new Error(&quot;Missing XSD in LookupManager: &quot; + name);
//			    }
//			
//			    var f = new File(tempDir, name);
//			    var fw = new FileWriter(f);
//			    fw.write(content);
//			    fw.close();
//			
//			    logger.info(&quot;Wrote XSD to temp: &quot; + f.getAbsolutePath());
//			}
//			
//			// ===============================================================
//			// 4. Load ONLY the root CDA.xsd from the temp directory
//			// ===============================================================
//			var schemaFactory = javax.xml.validation.SchemaFactory
//			    .newInstance(javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI);
//			
//			var rootFile = new File(tempDir, xsdFileName);
//			var schemaSource = new javax.xml.transform.stream.StreamSource(rootFile);
//			
//			// ===============================================================
//			// 5. Build the schema — includes work automatically from disk
//			// ===============================================================
//			var schema = schemaFactory.newSchema(schemaSource);
//		//==============================new changes end =====================================//	&#xd;
//	        
//	        var validator = schema.newValidator(); // Set up the validator       
//	        var xmlSource = new javax.xml.transform.stream.StreamSource(new java.io.StringReader(phiFilteredXml)); // Set up the input source for the XML
//
//			// Success: Return a structured OperationOutcome JSON response
//            var successResponse = {
//                &quot;OperationOutcome&quot;: {
//                    &quot;validationResults&quot;: [
//                        {
//                            &quot;operationOutcome&quot;: {
//                                &quot;resourceType&quot;: &quot;OperationOutcome&quot;,
//                                &quot;issue&quot;: [
//                                    {
//                                        &quot;severity&quot;: &quot;information&quot;,
//                                        &quot;interaction_id&quot;: channelMap.get(&apos;interactionId&apos;),
//                                        &quot;code&quot;: &quot;informational&quot;,
//                                        &quot;details&quot;: {
//                                            &quot;text&quot;: &quot;CCDA XML is valid according to the XSD.&quot;
//                                        }
//                                    }
//                                ]
//                            }
//                        }
//                    ]
//                }
//            };
//	
//	        // Perform the validation
//	        try {
//	        	validator.validate(xmlSource);
//	          logger.info(&quot;CCDA XML is valid according to the XSD.&quot;);
//
//			// SAVE VALIDATION RESULT
//			logger.info(&quot;DB Validation Save inside Bundle&quot;);
//		     var tenantId = channelMap.get(&apos;tenantId&apos;);
//		     logger.info(&quot;tenant Id: &quot; + tenantId);
//		     var operation = &quot;saveValidationSuccess&quot;;
//		     var result = saveCcdaPayload(
//			    interactionId,
//			   tenantId,
//			   requestedPath,
//			   successResponse,
//			   operation
//			);
//	                      
//	        } catch (e) {
//	            var errorMsg;
//	            if (e instanceof JavaException) {
//	                errorMsg = &quot;CCDA XML validation failed: &quot; + e.toString();
//	            } else {
//	                errorMsg = &quot;Unexpected error during validation: &quot; + e.message;
//	            }
//
//	            var errorResponse = getJsonInvalidOperationOutcome(errorMsg, &quot;invalid&quot;);
//
////	            if (sourceXml &amp;&amp; sourceXml.length &gt; 0) {
////		            try {
////		            	var operation = &quot;saveOgCCDAPayload&quot;;
////		                saveCcdaPayload(interactionId, tenantId, requestedPath, sourceXml, operation);
////		                logger.info(&quot;Successfully saved original CCDA payload for failed validation&quot;);
////		            } catch (saveError) {
////		                logger.error(&quot;Failed to save original CCDA payload: &quot; + saveError.message);
////		            }
////		        } else {
////		            logger.warn(&quot;No source XML available to save for interactionId: &quot; + interactionId);
////		        }
//	
//				// Save Validation Failed
//		        try {
//		        	  var operation = &quot;saveValidationFailed&quot;;
//		            saveCcdaPayload(interactionId, tenantId, requestedPath, errorResponse, operation);
//		            logger.info(&quot;Successfully saved validation failure information&quot;);
//		        } catch (saveError) {
//		            logger.error(&quot;Failed to save validation failure: &quot; + saveError.message);
//		        }
//	
//	            // Failure: Return an OperationOutcome JSON response with validation errors
//	            responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMsg, &quot;invalid&quot;)));
//	
//			
//	
//			//*********** DATA LEDGER ***************
//	          var  currentTimestamEnd = new Date().toISOString().replace(/\.(\d{3})Z$/, function(match, millis) {
//			// Add 3 more random digits to simulate microseconds
//			var micros = millis + (Math.floor(Math.random() * 1000)).toString().padStart(3, &apos;0&apos;);
//			return &apos;.&apos; + micros + &apos;Z&apos;;
//			});
//			  var payload = JSON.stringify({
//		        executedAt: currentTimestamEnd,
//		        actor: &quot;TechBD&quot;,
//		        action: &quot;sent&quot;, 
//		        destination: &quot;Invalid - CCD Conversion Failed&quot;,
//		        dataId: interactionId,
//		        payloadType: &quot;hrsnBundle&quot;
//		  	  });
//		
//		
//				
//			if (trackingEnabled != null &amp;&amp; trackingEnabled.toLowerCase() == &quot;true&quot;) {
//			    logger.info(&quot;data ledger api call -BEGIN sent&quot;);
//			   try {
//		        sendDataLedgerSync(payload);
//			    } catch (e) {
//			        logger.error(&quot;Error occurred while sending data to Data Ledger: &quot; + e.message);
//			    }
//			    logger.info(&quot;data ledger api call -END sent&quot;);
//			} else {
//			    logger.info(&quot;DATA_LEDGER_TRACKING is not true; skipping Data Ledger sync for sent.&quot;);
//			}
//			//*********** DATA LEDGER ***************
//	
//	            // Failure: Return an OperationOutcome JSON response with validation errors
//	            //responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMsg, &quot;invalid&quot;)));
//	            logger.error(errorMsg);
//	            throw new Error(errorMsg);
//	        }
//	//**/////////CCDA Validation End////////////////**///
//	
//		// Perform the transformation
//		try {
//		    
//			/////////  Step 2  //////////
//			// Load the XSLT template
//			var xsltPath = channelMap.get(&apos;cdaPhiBundle&apos;);
////			var xsltFile = new java.io.File(xsltPath);
////			var xsltStream = new java.io.FileInputStream(xsltFile);
//
////=====================================new changes ====================================//
//               logger.info(&quot;xsltPath: &quot; + xsltPath);
//	          var fileNameWithExt = xsltPath.substring(xsltPath.lastIndexOf(&apos;/&apos;) + 1);
//			var fileName = fileNameWithExt.replace(&apos;.xslt&apos;, &apos;&apos;);
//	          logger.info(&quot;Extracted XSLT Key Name: &quot; + fileName);
//			var ttlHours = 24 * 20; // Time to live in hours
//			var xsltContent = LookupHelper.get(&quot;SchemaFiles&quot;, fileName , ttlHours);
//			logger.info(&quot;Value from hl7v2-fhir-bundle.xslt : &quot; + xsltContent);
//
//			if (!xsltContent) {
//			    throw new Error(&quot;LookupManager: No XSLT found for key &quot; + fileName);
//			}
//			
//			// Convert XSLT to StreamSource
//			var xsltSource = new javax.xml.transform.stream.StreamSource(
//			    new java.io.StringReader(xsltContent)
//			);   
////=======================================new changes end =================================//			
//			// Create the transformer
//			var transformerFactory = javax.xml.transform.TransformerFactory.newInstance();
////			var xsltSource = new javax.xml.transform.stream.StreamSource(xsltStream);
//			var transformer = transformerFactory.newTransformer(xsltSource);
//	
//			// Set the current timestamp parameter in ISO 8601 format
//			var currentTimestamp = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SS&apos;Z&apos;&quot;).format(new java.util.Date());
//			transformer.setParameter(&quot;currentTimestamp&quot;, currentTimestamp); // Pass the parameter to XSLT
//			transformer = set_fhir_resource_profile_urls(transformer); // Pass all the profile urls as parameters to XSLT
//	
//			// Retrieve the X-TechBD-Base-FHIR-URL header
//			var customBaseFhirUrl = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-Base-FHIR-URL&apos;);
//			logger.info(&quot;X-TechBD-Base-FHIR-URL: &quot; + customBaseFhirUrl);
//			
//			// Retrieve the VALID_URLS environment variable (comma-separated list)
//			var validUrlsEnv = LookupHelper.get(&quot;Config&quot;, &quot;MC_VALID_FHIR_URLS&quot;, ttlHours);
//			logger.info(&quot;MC_VALID_FHIR_URLS from environment: &quot; + validUrlsEnv);
//			
//			// Convert VALID_URLS to an array for validation
//			var validUrls = validUrlsEnv ? validUrlsEnv.split(&quot;,&quot;).map(function(url) { return url.trim(); }) : [];
//			
//			// Check if the header value is valid
//			if (customBaseFhirUrl !== null &amp;&amp; customBaseFhirUrl.trim() != &quot;&quot;) {
//			    if (validUrls.includes(customBaseFhirUrl)) {
//			        // Store valid value in channelMap
//			        transformer.setParameter(&quot;baseFhirUrl&quot;, customBaseFhirUrl);
//				   channelMap.put(&apos;baseFhirUrl&apos;, customBaseFhirUrl);
//			    } else {
//			        // Throw a Bad Request error if the URL is not in the valid list
//					var errorMessage = &apos;The provided X-TechBD-Base-FHIR-URL is invalid. Base-FHIR-URL taken from the environment variable.&apos;;
//					logger.error(errorMessage);
//			    }
//			}
//	
//			logger.info(&quot;Current Timestamp: &quot; + currentTimestamp); // Log the timestamp
//	
//			// Prepare input and output streams
//			var xmlInputStream = new java.io.StringReader(phiFilteredXml);
//			var xmlOutputStream = new java.io.StringWriter();
//			var phiFilteredCcdFile = new javax.xml.transform.stream.StreamSource(xmlInputStream);
//			var bundleOutput = new javax.xml.transform.stream.StreamResult(xmlOutputStream);
//			
//			// Perform the transformation
//			try {
//				transformer.transform(phiFilteredCcdFile, bundleOutput);
//			
//				// Store the transformed XML in the channel map
//				var ccdFhirBundle = xmlOutputStream.toString();
//				channelMap.put(&apos;ccd_fhir_bundle&apos;, ccdFhirBundle);
//				logger.info(&quot;CCD FHIR Bundle: &quot; + ccdFhirBundle);
//	
//				var jsonObject = JSON.parse(ccdFhirBundle); // Parse the string into an object
//				var cleanedJsonString = JSON.stringify(jsonObject, removeEmptyValues, 2);
//				
//				logger.info(&quot;Cleaned JSON : &quot; + cleanedJsonString);
//
//				//Save Converted FHIR
//				logger.info(&quot;FHIR Conversion Save inside Bundle&quot;);
//			     var tenantId = channelMap.get(&apos;tenantId&apos;);
//			     logger.info(&quot;tenant Id: &quot; + tenantId);
//			     var operation = &quot;saveConversionSuccess&quot;;
//			     var result = saveCcdaPayload(
//				    interactionId,
//				   tenantId,
//				   requestedPath,
//				   cleanedJsonString,
//				   operation
//				);
//				
//			} catch (e) {
//				var errorMsg = &quot;Error processing XML file upload: &quot; + e.message;	
//	        		// Failure: Return an OperationOutcome JSON response for general errors
//			    responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMsg, &quot;exception&quot;)));
//				        
//			    logger.error(&quot;Error during CCD FHIR bundle transformation: &quot; + e);
//			    throw e;
//			}
//	
//	
//			// Convert the XML document to JSON
//			const jsonResult = cleanedJsonString;
//			channelMap.put(&apos;jsonResult&apos;, jsonResult);
//			responseMap.put(&apos;finalResponse&apos;, JSON.stringify(jsonResult));
//			
//		    return &apos;dest_bundle&apos;; // HTTP Sender
//	    
//		} catch (e) {
//			var errorMsg = &quot;Error processing XML file upload: &quot; + e.message;
//	         // Failure: Return an OperationOutcome JSON response for general errors
//	         responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMsg, &quot;exception&quot;)));
//	         
//		    logger.error(&quot;Error during transformation: &quot; + e);
//		    throw e;
//		}
//	} catch (e) {
//	        var errorMsg = &quot;Error processing XML file upload: &quot; + e.message;
//
//	        var errorResponse = getJsonInvalidOperationOutcome(errorMsg, &quot;invalid&quot;);
//	        var operation = &quot;saveValidationFailed&quot;;
//	        saveCcdaPayload(interactionId, tenantId, requestedPath, errorResponse, operation);
//		   logger.info(&quot;Successfully saved validation failure information&quot;);
//	
//	        // Failure: Return an OperationOutcome JSON response for general errors
//	        responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMsg, &quot;exception&quot;)));
//	        logger.error(errorMsg);
//	        throw e;
//	}
//////////////////////////////////////////////
//}
else {
    // Handle invalid paths  
    var errorMsg = &quot;Error processing XML file upload: &quot; + e.message;
    // Failure: Return an OperationOutcome JSON response for general errors
    responseMap.put(&apos;finalResponse&apos;, JSON.stringify(getJsonInvalidOperationOutcome(errorMsg, &quot;exception&quot;)));
    
    logger.info(&quot;Invalid endpoint: &quot; + requestedPath);
    throw new Error(&quot;Invalid endpoint: &quot; + requestedPath);
}</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
      </elements>
      <inboundTemplate encoding="base64"></inboundTemplate>
      <outboundTemplate encoding="base64"></outboundTemplate>
      <inboundDataType>XML</inboundDataType>
      <outboundDataType>RAW</outboundDataType>
      <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="4.6.1">
        <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="4.6.1">
          <stripNamespaces>false</stripNamespaces>
        </serializationProperties>
        <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="4.6.1">
          <splitType>Element_Name</splitType>
          <elementName></elementName>
          <level>1</level>
          <query></query>
          <batchScript></batchScript>
        </batchProperties>
      </inboundProperties>
      <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.6.1">
        <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.6.1">
          <splitType>JavaScript</splitType>
          <batchScript></batchScript>
        </batchProperties>
      </outboundProperties>
    </transformer>
    <filter version="4.6.1">
      <elements>
        <com.mirth.connect.plugins.rulebuilder.RuleBuilderRule version="4.6.1">
          <name>Accept message if &quot;sourceMap.get(&apos;contextPath&apos;)&quot; equals &apos;/ccda/Bundle/$validate/&apos; or &apos;/ccda/Bundle/$validate&apos; or &apos;/ccda/Bundle/&apos; or &apos;/ccda/Bundle&apos;</name>
          <sequenceNumber>0</sequenceNumber>
          <enabled>true</enabled>
          <field>sourceMap.get(&apos;contextPath&apos;)</field>
          <condition>EQUALS</condition>
          <values>
            <string>&apos;/ccda/Bundle/$validate/&apos;</string>
            <string>&apos;/ccda/Bundle/$validate&apos;</string>
            <string>&apos;/ccda/Bundle/&apos;</string>
            <string>&apos;/ccda/Bundle&apos;</string>
          </values>
        </com.mirth.connect.plugins.rulebuilder.RuleBuilderRule>
        <com.mirth.connect.plugins.rulebuilder.RuleBuilderRule version="4.6.1">
          <name>Accept message if &quot;sourceMap.get(&apos;method&apos;)&quot; equals &apos;POST&apos;</name>
          <sequenceNumber>1</sequenceNumber>
          <enabled>false</enabled>
          <operator>AND</operator>
          <field>sourceMap.get(&apos;method&apos;)</field>
          <condition>EQUALS</condition>
          <values>
            <string>&apos;POST&apos;</string>
          </values>
        </com.mirth.connect.plugins.rulebuilder.RuleBuilderRule>
      </elements>
    </filter>
    <transportName>HTTP Listener</transportName>
    <mode>SOURCE</mode>
    <enabled>true</enabled>
    <waitForPrevious>true</waitForPrevious>
  </sourceConnector>
  <destinationConnectors>
    <connector version="4.6.1">
      <metaDataId>1</metaDataId>
      <name>dest_bundle_validate</name>
      <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="4.6.1">
        <pluginProperties/>
        <destinationConnectorProperties version="4.6.1">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <channelId>none</channelId>
        <channelTemplate>${message.encodedData}</channelTemplate>
        <mapVariables/>
      </properties>
      <transformer version="4.6.1">
        <elements/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.6.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.6.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.6.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.6.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="4.6.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.6.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.6.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.6.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.6.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="4.6.1">
        <elements>
          <com.mirth.connect.plugins.rulebuilder.RuleBuilderRule version="4.6.1">
            <name>Accept message if &quot;$(&apos;endpoint&apos;)&quot; equals &apos;validate&apos;</name>
            <sequenceNumber>0</sequenceNumber>
            <enabled>true</enabled>
            <field>$(&apos;endpoint&apos;)</field>
            <condition>EQUALS</condition>
            <values>
              <string>&apos;validate&apos;</string>
            </values>
          </com.mirth.connect.plugins.rulebuilder.RuleBuilderRule>
        </elements>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
    <connector version="4.6.1">
      <metaDataId>2</metaDataId>
      <name>dest_bundle</name>
      <properties class="com.mirth.connect.connectors.http.HttpDispatcherProperties" version="4.6.1">
        <pluginProperties/>
        <destinationConnectorProperties version="4.6.1">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <host>${fhirBundleSubmissionApiUrl}</host>
        <useProxyServer>false</useProxyServer>
        <proxyAddress></proxyAddress>
        <proxyPort></proxyPort>
        <method>post</method>
        <headers class="linked-hash-map">
          <entry>
            <string>X-TechBD-Tenant-ID</string>
            <list>
              <string>${tenantId}</string>
            </list>
          </entry>
          <entry>
            <string>Content-Type</string>
            <list>
              <string>application/fhir+json</string>
            </list>
          </entry>
          <entry>
            <string>User-Agent</string>
            <list>
              <string>${userAgent}</string>
            </list>
          </entry>
          <entry>
            <string>X-TechBD-Override-Request-URI</string>
            <list>
              <string>${requestUri}</string>
            </list>
          </entry>
          <entry>
            <string>Access-Control-Allow-Origin</string>
            <list>
              <string>*</string>
            </list>
          </entry>
          <entry>
            <string>Access-Control-Allow-Methods</string>
            <list>
              <string>GET, POST, OPTIONS</string>
            </list>
          </entry>
          <entry>
            <string>Access-Control-Allow-Headers</string>
            <list>
              <string>Content-Type,Authorization,X-TechBD-Tenant-ID,User-Agent,X-TechBD-REMOTE-IP,X-TechBD-Override-Request-URI,accept,X-TechBD-CIN,X-TechBD-OrgNPI,X-TechBD-OrgTIN,X-TechBD-Base-FHIR-URL,X-TechBD-Validation-Severity-Level,X-TechBD-Facility-ID,X-TechBD-Encounter-Type,X-TechBD-Screening-Code</string>
            </list>
          </entry>
          <entry>
            <string>Access-Control-Allow-Credentials</string>
            <list>
              <string>true</string>
            </list>
          </entry>
          <entry>
            <string>X-TechBD-REMOTE-IP</string>
            <list>
              <string>${uri}</string>
            </list>
          </entry>
          <entry>
            <string>X-TechBD-Elaboration</string>
            <list>
              <string>${elaboration}</string>
            </list>
          </entry>
          <entry>
            <string>X-TechBD-Validation-Severity-Level</string>
            <list>
              <string>${SeverityLevel}</string>
            </list>
          </entry>
          <entry>
            <string>X-Correlation-ID</string>
            <list>
              <string>${interactionId}</string>
            </list>
          </entry>
          <entry>
            <string>X-TechBD-Interaction-ID</string>
            <list>
              <string>${interactionId}</string>
            </list>
          </entry>
          <entry>
            <string>X-TechBD-Source-Type</string>
            <list>
              <string>CCDA</string>
            </list>
          </entry>
          <entry>
            <string>requestUri</string>
            <list>
              <string>${requestUri}</string>
            </list>
          </entry>
          <entry>
            <string>X-SHIN-NY-IG-Version</string>
            <list>
              <string>${igVersion}</string>
            </list>
          </entry>
          <entry>
            <string>X-TechBD-DataLake-API-URL</string>
            <list>
              <string>${DATALAKE_API_URL}</string>
            </list>
          </entry>
        </headers>
        <parameters class="linked-hash-map">
          <entry>
            <string>source</string>
            <list>
              <string>CCDA</string>
            </list>
          </entry>
        </parameters>
        <useHeadersVariable>false</useHeadersVariable>
        <headersVariable></headersVariable>
        <useParametersVariable>false</useParametersVariable>
        <parametersVariable></parametersVariable>
        <responseXmlBody>false</responseXmlBody>
        <responseParseMultipart>true</responseParseMultipart>
        <responseIncludeMetadata>false</responseIncludeMetadata>
        <responseBinaryMimeTypes>application/fhir+json</responseBinaryMimeTypes>
        <responseBinaryMimeTypesRegex>true</responseBinaryMimeTypesRegex>
        <multipart>false</multipart>
        <useAuthentication>false</useAuthentication>
        <authenticationType>Basic</authenticationType>
        <usePreemptiveAuthentication>false</usePreemptiveAuthentication>
        <username></username>
        <password></password>
        <content>${jsonResult}</content>
        <contentType>application/fhir+json</contentType>
        <dataTypeBinary>false</dataTypeBinary>
        <charset>UTF-8</charset>
        <socketTimeout>300000</socketTimeout>
      </properties>
      <transformer version="4.6.1">
        <elements/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.6.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.6.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.6.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.6.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="4.6.1">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.6.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.6.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.6.1">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.6.1">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="4.6.1">
        <elements>
          <com.mirth.connect.plugins.rulebuilder.RuleBuilderRule version="4.6.1">
            <name>Accept message if &quot;$(&apos;endpoint&apos;)&quot; equals &apos;bundle&apos;</name>
            <sequenceNumber>0</sequenceNumber>
            <enabled>true</enabled>
            <field>$(&apos;endpoint&apos;)</field>
            <condition>EQUALS</condition>
            <values>
              <string>&apos;bundle&apos;</string>
            </values>
          </com.mirth.connect.plugins.rulebuilder.RuleBuilderRule>
          <com.mirth.connect.plugins.rulebuilder.RuleBuilderRule version="4.6.1">
            <name>Accept message if &quot;sourceMap.get(&apos;contextPath&apos;)&quot; equals &apos;/ccda/Bundle/&apos; or &apos;/ccda/Bundle&apos;</name>
            <sequenceNumber>1</sequenceNumber>
            <enabled>true</enabled>
            <operator>AND</operator>
            <field>sourceMap.get(&apos;contextPath&apos;)</field>
            <condition>EQUALS</condition>
            <values>
              <string>&apos;/ccda/Bundle/&apos;</string>
              <string>&apos;/ccda/Bundle&apos;</string>
            </values>
          </com.mirth.connect.plugins.rulebuilder.RuleBuilderRule>
        </elements>
      </filter>
      <transportName>HTTP Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
  </destinationConnectors>
  <preprocessingScript>return message;
</preprocessingScript>
  <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map

// Version: 0.4.3 - Added support for X-TechBD-Base-FHIR-URL
// Version: 0.4.15 - Added filters to source and bundle destination and changed the globalMap usage to channelMap

var endpoint = channelMap.get(&quot;endpoint&quot;);
if(endpoint == &apos;bundle&apos;) {
	// Get the response from the HTTP Writer destination
	var destinationName = &quot;dest_bundle&quot;;
	var destinationResponse = responseMap.get(destinationName);
	logger.info(&quot;destinationResponse &quot; + destinationResponse + &quot;:&quot;);
	
	// Check if the response exists
	if (destinationResponse) {
	    var responseStatus = destinationResponse.getStatus();  // HTTP status code
	    var responseData = destinationResponse.getMessage();   // Response message body
		responseMap.put(&apos;finalResponse&apos;, responseData);
		
	    // Log the response details
	    logger.info(&quot;Response from &quot; + destinationName + &quot;:&quot;);
	    logger.info(&quot;Status Code: &quot; + responseStatus);
	    logger.info(&quot;Response Data: &quot; + responseData);
	} else {
	    logger.info(&quot;No response found for destination: &quot; + destinationName);
	}
}

return;</postprocessingScript>
  <deployScript>
return;
</deployScript>
  <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
  <properties version="4.6.1">
    <clearGlobalChannelMap>true</clearGlobalChannelMap>
    <messageStorageMode>METADATA</messageStorageMode>
    <encryptData>false</encryptData>
    <encryptAttachments>false</encryptAttachments>
    <encryptCustomMetaData>false</encryptCustomMetaData>
    <removeContentOnCompletion>false</removeContentOnCompletion>
    <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
    <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
    <initialState>STARTED</initialState>
    <storeAttachments>false</storeAttachments>
    <metaDataColumns>
      <metaDataColumn>
        <name>SOURCE</name>
        <type>STRING</type>
        <mappingName>message_source</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>TYPE</name>
        <type>STRING</type>
        <mappingName>message_type</mappingName>
      </metaDataColumn>
    </metaDataColumns>
    <attachmentProperties version="4.6.1">
      <type>None</type>
      <properties/>
    </attachmentProperties>
    <resourceIds class="linked-hash-map">
      <entry>
        <string>Default Resource</string>
        <string>[Default Resource]</string>
      </entry>
    </resourceIds>
  </properties>
  <exportData>
    <metadata>
      <enabled>true</enabled>
      <lastModified>
        <time>1770870276083</time>
        <timezone>Asia/Calcutta</timezone>
      </lastModified>
      <pruningSettings>
        <archiveEnabled>true</archiveEnabled>
        <pruneErroredMessages>false</pruneErroredMessages>
      </pruningSettings>
      <userId>1</userId>
    </metadata>
    <channelTags>
      <channelTag>
        <id>c3d4a03d-caef-4d7b-aa16-f7fc7021f5d2</id>
        <name>0_5_15</name>
        <channelIds>
          <string>0a09378a-5189-44b7-9ce2-009029f3865d</string>
        </channelIds>
        <backgroundColor>
          <red>128</red>
          <green>0</green>
          <blue>0</blue>
          <alpha>255</alpha>
        </backgroundColor>
      </channelTag>
    </channelTags>
  </exportData>
</channel>